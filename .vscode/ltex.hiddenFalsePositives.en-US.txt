{"rule":"LC_AFTER_PERIOD","sentence":"^\\QSo equivalently we can express our recursor for natural numbers as:\n  }\n  \\codeblock{lean}\n  {\n    def recNat {C : Type} (z : C) (s : C → C) : ℕ → C\n      | 0       => z\n      | n + 1   => s (recNat z s n)\n  }\n  \\p{\n    If we examine the actual type signature generated by \\code{#check Nat.rec} we have:\n    }\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Q\\codeblock{lean}{\n    def three : Nat := Nat.succ (Nat.succ (Nat.succ Nat.zero))\n  }\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Qdef natToNode : ℕ → Node\n      | 0       => Node.start\n      | n + 1   => succNode (natToNode n)\n  }\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Qdef natToNode : ℕ → Node :=\n        Nat.rec\n          Node.start            -- | 0     => Node.start\n          (fun n => succNode n) -- | n + 1 => succNode (natToNode n)\n    }\n  }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis provides us with the means to construct expressions like:\n    }\n    \\codeblock{lean}{\n      #check Expr.binop BinOp.add (Expr.const 10) (Expr.const 20)\n    }\n    \\p{\n      If we want to actually define the semantics of how to evaluate these expression we'll need to define a set of rewrite rules that describe how we can take an expression and reduce it to a value i.e. evaluate it.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Qinductive Step : Expr -> Expr -> Prop\n      | ST_BinOp1 (op : BinOp)\n          (e₁ e₁' e₂ : Expr)\n          (h : Step e₁ e₁') :\n          Step (Expr.binop op e₁ e₂)\n               (Expr.binop op e₁' e₂)\n      | ST_BinOp2 (op : BinOp)\n          (v₁ : Nat)\n          (e₂ e₂' : Expr)\n          (h : Step e₂ e₂') :\n          Step (Expr.binop op (Expr.const v₁) e₂)\n               (Expr.binop op (Expr.const v₁) e₂')\n      | ST_BinOpConst (op : BinOp) (v₁ v₂ : Nat) :\n          Step (Expr.binop op (Expr.const v₁) (Expr.const v₂))\n               (Expr.const (eval_op op v₁ v₂))\n    }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis provides us with the means to construct expressions like:\n    }\n    \\codeblock{lean}{\n      #check Expr.binop BinOp.add (Expr.const 10) (Expr.const 20)\n    }\n    \\p{\n      If we want to actually define the semantics of how to evaluate these expressions we'll need to define a set of rewrite rules that describe how we can take an expression and reduce it to a value i.e. evaluate it.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QReflTransGen Step\\E$"}
{"rule":"EN_COMPOUNDS","sentence":"^\\Q-- helper notation to express multi-step evaluation\n      notation:50 e \" ->ⁿ \" e' =>  MultiStep e e'\n    }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- helper notation to express multi-step evaluation\n      notation:50 e \" ->ⁿ \" e' =>  MultiStep e e'\n    }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- addition\n            | `(ex{ $e₁:arithTm + $e₂:arithTm }) =>\n                `(Expr.binop BinOp.add (ex{$e₁}) (ex{$e₂}))\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- subtraction\n            | `(ex{ $e₁:arithTm - $e₂:arithTm }) =>\n                `(Expr.binop BinOp.sub (ex{$e₁}) (ex{$e₂}))\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- multiplication\n            | `(ex{ $e₁:arithTm * $e₂:arithTm }) =>\n                `(Expr.binop BinOp.mul (ex{$e₁}) (ex{$e₂}))\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QSo a basic example being clearly:\n  }\n  ##{\n    x > 3 \\to x > 2\n  }\n  \\p{\n    So if we have that:\n  }\n  ##{\n    \\sigma \\vDash (x > 3) \\to (x > 2) \\\\ \\vdash \\{x > 2\\}\\ s\\ \\{Q\\}\n  }\n  \\p{\n    Which is to say that our hoare triple is derivable under the weaker precondition #{x > 2}, then clearly the same hoare triple is also derivable under the stronger pre-condition #{x > 3} as it implies our weaker condition, hence we can derive:\n  }\n  ##{\n    \\vdash \\{x > 3\\}\\ s\\ \\{Q\\}\n  }\n  \\p{\n    An example program we could take here would be something like:\n  }\n  ##{\n    \\{x > 2\\}\\ \\cif\\ (x > 2)\\ \\cthen\\ y := 2 \\celse\\ y := 3\\ \\{y := 2\\}\n  }\n  \\p{\n    Clearly here the condition just requires that #{x} is larger then 2, if our precondition asserts that its larger then 3, the #{\\cthen} branch executes just the same and our postcondition holds.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\Q}\n}\n\\p{\n  The axioms of the theory of arrays are:\n}\n\\tex{\n  \\usepackage{eulervm}\n  \\usepackage{amsmath}\n}{\n  \\startverb\n  \\begin{align*}\n    \\forall a, i, v.\\; [a \\langle i \\triangleleft v \\rangle][i] &= v \\quad \\tag{Read-Over-Write 1} \\\\\n    \\forall a, i, j, v.\\; i \\neq j \\implies [a \\langle i \\triangleleft v \\rangle][j] &= a[j] \\quad \\tag{Read-Over-Write 2} \\\\\n    \\forall a, b.\\; (\\forall i.\\; a[i] = b[i]) &\\implies a = b \\quad \\tag{Extensionality}\n  \\end{align*}\n  \\stopverb\n}\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\subtree{\n  \\title{Arrays}\n  \\transclude{003l}\n  \\transclude{003m}\n}\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\subtree{\n  \\title{Arrays}\n  \\transclude{003l}\n  \\transclude{004i}\n  \\transclude{003m}\n}\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\subtree{\n  \\title{Arrays & Invariants}\n  \\transclude{003l}\n  \\transclude{004i}\n  \\transclude{003m}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\title{Working backwards - weakest precondition}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\p{Say we want to verify a hoare triple #{\\{P\\}\\ s\\ \\{Q\\}}, the \\em{weakest precondition} approach is that we:}\n  \\ol{\n    \\li{Start with our postcondition #{Q} and, going backwards, we compute a formula #{\\texttt{wp(s, Q)}} called the \\em{weakest precondition} of #{Q} w.r.t the statement #{s}.}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q}\n  }\n  \\p{\n    The shorthand of the \\em{weakest precondition} is nothing more then an expression of the idea \n  }\n}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q}\n  }\n  \\p{\n    The shorthand of the \\em{weakest precondition} is nothing more than an expression of the idea \n  }\n}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q}\n  }\n  \\p{\n    The shorthand of the \\em{weakest precondition} is nothing more than an expression of precisely this idea in a more concise fashion.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\p{\n    Say we want to verify a hoare triple #{\\{P\\}\\ s\\ \\{Q\\}}, the \\em{weakest precondition} approach is that we:\n  }\n  \\ol{\n    \\li{\n      Start with our postcondition #{Q} and, going backwards, we compute a formula #{\\texttt{wp}(s, Q)} called the \\em{weakest precondition} of #{Q} w.r.t the statement #{s}.\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QTo show an example in lean using a some nice macros to create a simple syntax:}\n  \\codeblock{lean}{\n    example (n : Num) : {{ ⟦ \"x\" ↦ n ⟧ }} tm{ x := x + 1 } {{ ⟦ \"x\" ↦ n + 1 ⟧ }} := by\n    apply Hoare.assign'\n    intro σ m hpre heval\n    cases heval with\n    | sum he1 he2 =>\n      cases he1; cases he2\n      simp [hpre]\n  }\n}\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QTo show an example in lean using a some nice macros to create a simple syntax:}\n  \\codeblock{lean}{\n    example (n : Num) : {{ ⟦ \"x\" ↦ n ⟧ }} tm{ x := x + 1 } {{ ⟦ \"x\" ↦ n + 1 ⟧ }} := by\n    apply Hoare.assign'\n    intro σ m hpre heval\n    cases heval with\n    | sum he1 he2 =>\n      cases he1; cases he2\n      simp [hpre]\n  }\n  \\p{We can see here to \"prove\" this hoare triple was valid we started by doing our standard case split on the assign - thats the \\cf{apply Hoare.assign'} - statement, then we were inside the addition, here we did a case split which have us the lhs and rhs we were adding, after doing a case split on those two sides we could finally just simplify (and finalize) our proof using the fact that in #{\\sigma} #{x} evaluates to #{n}.}\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QTo show an example in lean using a some nice macros to create a simple syntax:}\n  \\codeblock{lean}{\n    example (n : Num) : {{ ⟦ \"x\" ↦ n ⟧ }} tm{ x := x + 1 } {{ ⟦ \"x\" ↦ n + 1 ⟧ }} := by\n    apply Hoare.assign'\n    intro σ m hpre heval\n    cases heval with\n    | sum he1 he2 =>\n      cases he1; cases he2\n      simp [hpre]\n  }\n  \\p{We can see here to \"prove\" this hoare triple was valid we started by doing our standard case split on the assign - that's the \\cf{apply Hoare.assign'} - statement, then we were inside the addition, here we did a case split which have us the lhs and rhs we were adding, after doing a case split on those two sides we could finally just simplify (and finalize) our proof using the fact that in #{\\sigma} #{x} evaluates to #{n}.}\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QTo show an example in lean using a some nice macros to create a simple syntax:\n  }\n  \\codeblock{lean}{\n    example (n : Num) : {{ ⟦ \"x\" ↦ n ⟧ }} tm{ x := x + 1 } {{ ⟦ \"x\" ↦ n + 1 ⟧ }} := by\n    apply Hoare.assign'\n    intro σ m hpre heval\n    cases heval with\n    | sum he1 he2 =>\n      cases he1; cases he2\n      simp [hpre]\n  }\n  \\p{\n    We can see here to \"prove\" this hoare triple was valid we started by doing our standard case split on the assign - that's the \\cf{apply Hoare.assign'} - statement, then we were inside the addition, here we did a case split which have us the lhs and rhs we were adding, after doing a case split on those two sides we could finally just simplify (and finalize) our proof using the fact that in #{\\sigma} #{x} evaluates to #{n}.\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QTo show an example in lean using a some nice macros to create a simple syntax:\n  }\n  \\codeblock{lean}{\n    example (n : Num) : \n    {{ ⟦ \"x\" ↦ n ⟧ }} \n      tm{ x := x + 1 } \n    {{ ⟦ \"x\" ↦ n + 1 ⟧ }} := by\n    apply Hoare.assign'\n    intro σ m hpre heval\n    cases heval with\n    | sum he1 he2 =>\n      cases he1; cases he2\n      simp [hpre]\n  }\n  \\p{The hoare triple we are proving here corresponds to this in the normal syntax:}\n  ##{\n    \\{x \\mapsto n \\}\\ x := x + 1\\ \\{x \\mapsto n + 1\\}\n  }\n  \\p{\n    We can see here to \"prove\" this hoare triple was valid we started by doing our standard case split on the assign - that's the \\cf{apply Hoare.assign'} - statement, then we were inside the addition, here we did a case split which have us the lhs and rhs we were adding, after doing a case split on those two sides we could finally just simplify (and finalize) our proof using the fact that in #{\\sigma} #{x} evaluates to #{n}.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\subtree{\n  \\title{Weakest precondition}\n  \\transclude{004k}\n}\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QTo show an example in lean using a some nice macros to create a simple syntax:\n  }\n  \\codeblock{lean}{\n    example (n : Num) : \n    {{ ⟦ \"x\" ↦ n ⟧ }} \n      tm{ x := x + 1 } \n    {{ ⟦ \"x\" ↦ n + 1 ⟧ }} := by\n    apply Hoare.assign'\n    intro σ m hpre heval\n    cases heval with\n    | sum he1 he2 =>\n      cases he1; cases he2\n      simp [hpre]\n  }\n  \\p{The hoare triple we are proving here corresponds to this in the normal syntax:}\n  ##{\n    \\{x \\mapsto n \\}\\ x := x + 1\\ \\{x \\mapsto n + 1\\}\n  }\n  \\p{\n    We can see here to \"prove\" this hoare triple was valid we started by doing our standard case split on the assign - that's the \\cf{apply Hoare.assign'} - statement, then we were inside the addition, here we did a case split which gave us the lhs and rhs we were adding, after doing a case split on those two sides we could finally just simplify (and finalize) our proof using the fact that in #{\\sigma} #{x} evaluates to #{n}.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\title{Computing weakest preconditions}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\title{Weakest precondition - while loop}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\title{[Weakest precondition](004k) - while loop}\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q\\import{erct-latex-preamble}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\subtree{\n  \\title{Weakest precondition}\n  \\transclude{004k}\n  \\transclude{004m}\n  \\transclude{004l}\n}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\subtree{\n  \\title{Weakest precondition}\n  \\transclude{004k}\n  \\transclude{004m}\n  \\transclude{004l}\n  \\transclude{004n}\n}\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\Q\\title{Weakest precondition for assert and assume}\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Q\\p{Fundamentally the assert and assume }\n}\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Q}\n  \\ol{\n    \\li{\n      Considering our wp formula we have \n      ##{\n        \\texttt{wp}(\\texttt{assert}(b), Q)(\\sigma) \\to (\\texttt{assert}(b), \\sigma) \\Downarrow \\texttt{.ok} \\sigma \\to Q(\\sigma)\n      }\n      reasoning backwards we can start with a case split on the evaluation of the assertion, this leads to two cases\n      \\ul{\n        \\li{\n          #{b} evaluates to \\em{true}, as this case trivially implies that the assert of\n        }\n        \\li{\n          item\n        }\n      }\n    }\n    \\li{\n      item\n    }\n  }\n}\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\Q}\n        \\li{\n          #{b} evaluates to \\em{false}, as this would imply a contradiction since the assertion evaluates to #{\\texttt{.ok} \\sigma}, more specifically we know have to prove the contradiction that #{\\texttt{.ok} \\sigma = \\texttt{.fail} \\sigma}, we know (i.e. have a hypothesis) by inversion that #{b \\Downarrow^f \\sigma} since we know #{b} has to be true to prove the contradiction we also must ensure the weakest precondition states that #{b \\Downarrow ^t \\sigma} \n        }\n      }\n      from these two cases we can conclude that two demonstrate the soundness of the weakest precondition for assert statements, it must be the case that the \\cf{wp} is the conjunction of the postcondition and the logical assertion that what is being asserted is indeed true, so we have that\n      ##{\n        \\texttt{wp}(\\texttt{assert}(b), Q)(\\sigma) \\equiv (b \\Downarrow^t \\sigma) \\land Q(\\sigma)\n      }\n      the more intuitive reasoning here is that #{Q} should hold before and after as an assert should, just by design, not do anything to the memory, it's only an assertion after all.\\E$"}
{"rule":"PREPOSITION_VERB","sentence":"^\\Q\\p{\n    The central idea with function definitions is that we \\em{assume} the preconditions #{P} and \\em{assert} the post-conditions #{Q}, what this means in a practical sense is that when verifying the function body what we \\em{actually} must verify is:\n  }\n  ##{\n    \\texttt{assume}(P);\\ s;\\ \\texttt{ret} := e;\\ \\texttt{assert}(Q) \n  }\n  \\p{\n    The idea being that by this convention a function contract - the requires, ensures, modifies specification - \\em{internally} assumes that the caller has met the necessary pre-conditions and provides as a guarantee the required post-conditions.\\E$"}

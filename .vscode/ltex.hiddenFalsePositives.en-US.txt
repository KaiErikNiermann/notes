{"rule":"LC_AFTER_PERIOD","sentence":"^\\QSo equivalently we can express our recursor for natural numbers as:\n  }\n  \\codeblock{lean}\n  {\n    def recNat {C : Type} (z : C) (s : C → C) : ℕ → C\n      | 0       => z\n      | n + 1   => s (recNat z s n)\n  }\n  \\p{\n    If we examine the actual type signature generated by \\code{#check Nat.rec} we have:\n    }\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Q\\codeblock{lean}{\n    def three : Nat := Nat.succ (Nat.succ (Nat.succ Nat.zero))\n  }\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Qdef natToNode : ℕ → Node\n      | 0       => Node.start\n      | n + 1   => succNode (natToNode n)\n  }\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Qdef natToNode : ℕ → Node :=\n        Nat.rec\n          Node.start            -- | 0     => Node.start\n          (fun n => succNode n) -- | n + 1 => succNode (natToNode n)\n    }\n  }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis provides us with the means to construct expressions like:\n    }\n    \\codeblock{lean}{\n      #check Expr.binop BinOp.add (Expr.const 10) (Expr.const 20)\n    }\n    \\p{\n      If we want to actually define the semantics of how to evaluate these expression we'll need to define a set of rewrite rules that describe how we can take an expression and reduce it to a value i.e. evaluate it.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Qinductive Step : Expr -> Expr -> Prop\n      | ST_BinOp1 (op : BinOp)\n          (e₁ e₁' e₂ : Expr)\n          (h : Step e₁ e₁') :\n          Step (Expr.binop op e₁ e₂)\n               (Expr.binop op e₁' e₂)\n      | ST_BinOp2 (op : BinOp)\n          (v₁ : Nat)\n          (e₂ e₂' : Expr)\n          (h : Step e₂ e₂') :\n          Step (Expr.binop op (Expr.const v₁) e₂)\n               (Expr.binop op (Expr.const v₁) e₂')\n      | ST_BinOpConst (op : BinOp) (v₁ v₂ : Nat) :\n          Step (Expr.binop op (Expr.const v₁) (Expr.const v₂))\n               (Expr.const (eval_op op v₁ v₂))\n    }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis provides us with the means to construct expressions like:\n    }\n    \\codeblock{lean}{\n      #check Expr.binop BinOp.add (Expr.const 10) (Expr.const 20)\n    }\n    \\p{\n      If we want to actually define the semantics of how to evaluate these expressions we'll need to define a set of rewrite rules that describe how we can take an expression and reduce it to a value i.e. evaluate it.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QReflTransGen Step\\E$"}
{"rule":"EN_COMPOUNDS","sentence":"^\\Q-- helper notation to express multi-step evaluation\n      notation:50 e \" ->ⁿ \" e' =>  MultiStep e e'\n    }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- helper notation to express multi-step evaluation\n      notation:50 e \" ->ⁿ \" e' =>  MultiStep e e'\n    }\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- addition\n            | `(ex{ $e₁:arithTm + $e₂:arithTm }) =>\n                `(Expr.binop BinOp.add (ex{$e₁}) (ex{$e₂}))\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- subtraction\n            | `(ex{ $e₁:arithTm - $e₂:arithTm }) =>\n                `(Expr.binop BinOp.sub (ex{$e₁}) (ex{$e₂}))\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q-- multiplication\n            | `(ex{ $e₁:arithTm * $e₂:arithTm }) =>\n                `(Expr.binop BinOp.mul (ex{$e₁}) (ex{$e₂}))\\E$"}

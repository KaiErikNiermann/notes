<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>11</fr:month>
      <fr:day>22</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/000b/</fr:uri>
    <fr:display-uri>000b</fr:display-uri>
    <fr:route>/notes/000b/</fr:route>
    <fr:title text="Lecture 2 - Normal Forms &amp; DPLL">Lecture 2 - Normal Forms &amp; DPLL</fr:title>
    <fr:taxon>VU-VFS-2025</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="Formula Equivalence">Formula Equivalence</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000c/</fr:uri>
            <fr:display-uri>000c</fr:display-uri>
            <fr:route>/notes/000c/</fr:route>
            <fr:title text="Equivalence of Formulae">Equivalence of Formulae</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  Two formulas <fr:tex display="inline"><![CDATA[F]]></fr:tex> and <fr:tex display="inline"><![CDATA[G]]></fr:tex> are said to be <html:strong>equivalent</html:strong>, written <fr:tex display="inline"><![CDATA[F \equiv  G]]></fr:tex>, if they have the same truth value under every interpretation. In other words, for every interpretation <fr:tex display="inline"><![CDATA[I]]></fr:tex>, <fr:tex display="inline"><![CDATA[I \models  F]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[I \models  G]]></fr:tex>.
</html:p>
            <fr:tex display="block"><![CDATA[
  F \equiv  G \iff  \forall  I (I \models  F \iff  I \models  G)
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000d/</fr:uri>
            <fr:display-uri>000d</fr:display-uri>
            <fr:route>/notes/000d/</fr:route>
            <fr:title text="Normal Forms &amp; DPLL - Equivalence">Normal Forms &amp; DPLL - Equivalence</fr:title>
            <fr:taxon>Quiz</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:strong>Which of the following equivalences hold?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[\bot  \equiv  \bot ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\top  \equiv  \top ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  \top  \equiv  \neg  \bot ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  (p \land  q) \equiv  \neg  p \lor  \neg  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \equiv  p \lor  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  \neg  p \equiv  p]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>True. Both sides are always false.</html:li>
    <html:li>True. Both sides are always true.</html:li>
    <html:li>False. Left side is always false, right side is always true.</html:li>
    <html:li>True. This is <fr:link href="/notes/000g/" title="De Morgan's Laws" uri="https://kaierikniermann.github.io/notes/000g/" display-uri="000g" type="local">De Morgan's law</fr:link>. Good to remember 
      <fr:tex display="block"><![CDATA[
        \neg  (p \land  q) \equiv  \neg  p \lor  \neg  q
      ]]></fr:tex></html:li>
    <html:li>False. Left side is true when p is true, right side is true when either p or q is true.</html:li>
    <html:li>True. Double negation elimination.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="Negation Normal Forms">Negation Normal Forms</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000e/</fr:uri>
            <fr:display-uri>000e</fr:display-uri>
            <fr:route>/notes/000e/</fr:route>
            <fr:title text="Negation Normal Form (NNF)">Negation Normal Form (NNF)</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is in Negation Normal Form (NNF) if the negation operator <fr:tex display="inline"><![CDATA[\neg ]]></fr:tex> is onyl applied to literlas (i.e., propositional variables or their negations), and the only other allowed operators are conjunction <fr:tex display="inline"><![CDATA[\land ]]></fr:tex> and disjunction <fr:tex display="inline"><![CDATA[\lor ]]></fr:tex>. A nice way to think about it is that we can never have the case where we need to apply <fr:link href="/notes/000g/" title="De Morgan's Laws" uri="https://kaierikniermann.github.io/notes/000g/" display-uri="000g" type="local">De Morgan's laws</fr:link> to push negations further down the formula tree. So all negations come pre-distributed to the literals.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000f/</fr:uri>
            <fr:display-uri>000f</fr:display-uri>
            <fr:route>/notes/000f/</fr:route>
            <fr:title text="Negation Normal Form (NNF)">Negation Normal Form (NNF)</fr:title>
            <fr:taxon>Quiz</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:strong>Which of the following formulas are in Negation Normal Form (NNF)?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[p \to  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q  \land  (r \lor  \neg  s))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q \land  \neg  (\neg  r \land  s))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q \land  (\neg  \neg  r \lor  \neg  s)) ]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>No. The implication operator <fr:tex display="inline"><![CDATA[\to ]]></fr:tex> is not allowed in NNF.</html:li>
    <html:li>Yes. Negations are only applied to literals, and only <fr:tex display="inline"><![CDATA[\land ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lor ]]></fr:tex> are used.</html:li>
    <html:li>No. The negation operator <fr:tex display="inline"><![CDATA[\neg ]]></fr:tex> is applied to a non-literal formula <fr:tex display="inline"><![CDATA[(\neg  r \land  s)]]></fr:tex>.</html:li>
    <html:li>No. The double negation <fr:tex display="inline"><![CDATA[\neg  \neg  r]]></fr:tex> is not allowed in NNF. Important to remember since that can trip you up.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="Disjunctive Normal Form">Disjunctive Normal Form</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000k/</fr:uri>
            <fr:display-uri>000k</fr:display-uri>
            <fr:route>/notes/000k/</fr:route>
            <fr:title text="Distributing Conjunction">Distributing Conjunction</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The distributive law of conjunction over disjunction states that for any formulas <fr:tex display="inline"><![CDATA[F]]></fr:tex>, <fr:tex display="inline"><![CDATA[G]]></fr:tex>, and <fr:tex display="inline"><![CDATA[H]]></fr:tex>, the following equivalence holds:</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {align*}
    F \land  (G \lor  H) &\equiv  (F \land  G) \lor  (F \land  H) \\
    (F \lor  G) \land  H &\equiv  (F \land  H) \lor  (G \land  H)
  \end {align*}
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000j/</fr:uri>
            <fr:display-uri>000j</fr:display-uri>
            <fr:route>/notes/000j/</fr:route>
            <fr:title text="Eliminating Implications and Biconditionals">Eliminating Implications and Biconditionals</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>To eliminate implications (<fr:tex display="inline"><![CDATA[\to ]]></fr:tex>) and biconditionals (<fr:tex display="inline"><![CDATA[\leftrightarrow ]]></fr:tex>) from a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex>, we can use the following equivalences:</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {align*}
    p \to  q &\equiv  \neg  p \lor  q \\
    p \leftrightarrow  q &\equiv  (p \land  q) \lor  (\neg  p \land  \neg  q)
  \end {align*}
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000h/</fr:uri>
            <fr:display-uri>000h</fr:display-uri>
            <fr:route>/notes/000h/</fr:route>
            <fr:title text="Disjunctive Normal Form (DNF)">Disjunctive Normal Form (DNF)</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is in Disjunctive Normal Form (DNF) if it is a disjunction of one or more conjunctions of one or more literals. In other words, <fr:tex display="inline"><![CDATA[F]]></fr:tex> can be expressed as a series of clauses connected by disjunctions (<fr:tex display="inline"><![CDATA[\lor ]]></fr:tex>), where each clause is a series of literals connected by conjunctions (<fr:tex display="inline"><![CDATA[\land ]]></fr:tex>). A literal is either a propositional variable or its negation.</html:p>
            <fr:tex display="block"><![CDATA[
  F = C_1 \lor  C_2 \lor  ... \lor  C_n
]]></fr:tex>
            <html:p>Where each clause <fr:tex display="inline"><![CDATA[C_i]]></fr:tex> is of the form:</html:p>
            <fr:tex display="block"><![CDATA[
  C_i = L_{i1} \land  L_{i2} \land  ... \land  L_{im}
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000l/</fr:uri>
            <fr:display-uri>000l</fr:display-uri>
            <fr:route>/notes/000l/</fr:route>
            <fr:title text="Converting to DNF">Converting to DNF</fr:title>
            <fr:taxon>Quiz</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Convert the following formula into Disjunctive Normal Form (DNF):</html:p><fr:tex display="block"><![CDATA[
  (q \lor  \neg  \neg  p) \land  (\neg  r \to  s)
]]></fr:tex>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <fr:resource hash="0ed774c5f98ccbf4fe2a8d866cb96b0e"><fr:resource-content><html:img src="/notes/0ed774c5f98ccbf4fe2a8d866cb96b0e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
    \usepackage {amsmath}
    \usepackage {eulervm}
    \usepackage [scaled=0.92]{inconsolata} 
  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        {\small
      \begin{align*}
        & (q \lor \neg \neg p) \land (\neg r \to s) \\
        & \equiv (q \lor p) \land (r \lor s) \tag{Eliminate Implication} \\
        & \equiv ((q \lor p) \land r) \lor ((q \lor p) \land s) \tag{Distribute Conjunction} \\
        & \equiv (q \land r) \lor (p \land r) \lor (q \land s) \lor (p \land s) \tag{Distribute Conjunction} \\
      \end{align*}
    }
  ]]></fr:resource-source></fr:resource>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000q/</fr:uri>
            <fr:display-uri>000q</fr:display-uri>
            <fr:route>/notes/000q/</fr:route>
            <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Two formulas are said to be <html:strong>equisatisfiable</html:strong> if either both formulas are satisfiable or both are unsatisfiable. In other words, there exists an assignment of truth values to the variables that makes one formula true if and only if there exists; not necessarily the same assignment; that makes the other formula true. Equisatisfiability is a weaker condition than logical equivalence, as equisatisfiable formulas may not have the same truth values under all assignments, but they share the same satisfiability status.</html:p>
            <fr:tex display="block"><![CDATA[
  \texttt {equisat}(F, G) \iff  (\exists  I.\ I \models  F) \iff  (\exists  J.\ J \models  G)
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000r/</fr:uri>
            <fr:display-uri>000r</fr:display-uri>
            <fr:route>/notes/000r/</fr:route>
            <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
            <fr:taxon>Quiz</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> and <fr:tex display="inline"><![CDATA[G]]></fr:tex> are equisatisfiable, then are they equivalent?</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  No. We can answer this in a few different ways. In the most direct sense they are just definitionally not the same thing, in that equivalence requires that both formulas have the same truth value under all interpretations, whereas equisatisfiability only requires that both formulas have <html:em>a</html:em> satisfying interpretation or both be unsatisfiable.

  Another way to see it is that in an abstract sense equivalence describes an object-level relationship between formulas, whereas equisatisfiability describes a meta-level relationship about the existence of satisfying interpretations. Thus they are fundamentally different kinds of relationships.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="Tseitin Transformation">Tseitin Transformation</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000n/</fr:uri>
            <fr:display-uri>000n</fr:display-uri>
            <fr:route>/notes/000n/</fr:route>
            <fr:title text="Conjunctive Normal Form (CNF)">Conjunctive Normal Form (CNF)</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  A formula is in <html:strong>Conjunctive Normal Form (CNF)</html:strong> if it is expressed as a conjunction of disjunctions of literals. In other words, a CNF formula is a series of clauses (disjunctions) connected by AND operators. Each clause contains literals (variables or their negations) connected by OR operators. For example, the formula <fr:tex display="inline"><![CDATA[(p \lor  \neg  q) \land  (r \lor  s \lor  \neg  t)]]></fr:tex> is in CNF.
</html:p>
            <fr:tex display="block"><![CDATA[
  F = C_1 \land  C_2 \land  ... \land  C_n
]]></fr:tex>
            <html:p>Where each clause <fr:tex display="inline"><![CDATA[C_i]]></fr:tex> is of the form:</html:p>
            <fr:tex display="block"><![CDATA[
  C_i = L_{i1} \lor  L_{i2} \lor  ... \lor  L_{im}
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000m/</fr:uri>
            <fr:display-uri>000m</fr:display-uri>
            <fr:route>/notes/000m/</fr:route>
            <fr:title text="Exponential Blow up problem">Exponential Blow up problem</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  When converting a formula to Disjunctive Normal Form (DNF) or Conjunctive Normal Form (CNF), the size of the resulting formula can grow exponentially in the worst case. This is known as the <html:strong>exponential blow up problem</html:strong>. For example, a formula with <fr:tex display="inline"><![CDATA[n]]></fr:tex> variables can result in a DNF or CNF with up to <fr:tex display="inline"><![CDATA[2^n]]></fr:tex> clauses.
</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000s/</fr:uri>
            <fr:display-uri>000s</fr:display-uri>
            <fr:route>/notes/000s/</fr:route>
            <fr:title text="Tseytin's Transformation">Tseytin's Transformation</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Tseytin's transformation is a method used in propositional logic to convert any given formula into an equisatisfiable formula in <fr:link href="/notes/000n/" title="Conjunctive Normal Form (CNF)" uri="https://kaierikniermann.github.io/notes/000n/" display-uri="000n" type="local">Conjunctive Normal Form (CNF)</fr:link>. The key idea behind Tseytin's transformation is to introduce new variables to represent subformulas of the original formula, thereby avoiding <fr:link href="/notes/000m/" title="Exponential Blow up problem" uri="https://kaierikniermann.github.io/notes/000m/" display-uri="000m" type="local">an exponential increase in size</fr:link> that can occur with naive CNF conversion methods. There are two key properties of Tseytin's for a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> and its Tseytin transformation <fr:tex display="inline"><![CDATA[F']]></fr:tex>:</html:p>
            <html:ol><html:li><html:strong>unsatisfiability:</html:strong> <fr:tex display="inline"><![CDATA[F]]></fr:tex> is unsatisfiable if and only if <fr:tex display="inline"><![CDATA[F']]></fr:tex> is unsatisfiable.</html:li>
  <html:li><html:strong>model correspondence:</html:strong> For every satisfying assignment (model) of <fr:tex display="inline"><![CDATA[F']]></fr:tex>, there exists a corresponding satisfying assignment of <fr:tex display="inline"><![CDATA[F]]></fr:tex>, and vice versa, when restricted to the original variables of <fr:tex display="inline"><![CDATA[F]]></fr:tex>.</html:li></html:ol>
            <html:p>To demonstrate how it works lets consider the following formula</html:p>
            <fr:tex display="block"><![CDATA[
  \phi  = ((p \lor  q ) \land  r) \to  (\neg  s)
]]></fr:tex>
            <html:ol><html:li><html:strong>Subformula identification:</html:strong> Identify the subformulas of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> and assign a new variable to each subformula. For our example, we can identify the following subformulas and assign new variables:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & \neg  s \\ 
      & p \lor  q \\
      & (p \lor  q) \land  r \\
      & ((p \lor  q) \land  r) \to  (\neg  s)
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Variable assignment:</html:strong> Assign new variables to each subformula:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & x_1 \text { for } \neg  s \\ 
      & x_2 \text { for } p \lor  q \\
      & x_3 \text { for } (p \lor  q) \land  r \\
      & x_4 \text { for } ((p \lor  q) \land  r) \to  (\neg  s)
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Equivalence clauses:</html:strong> For each subformula, create clauses that enforce the equivalence between the new variable and the subformula it represents. For our example, we would create the following clauses:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & (x_1 \leftrightarrow  \neg  s) \\
      & (x_2 \leftrightarrow  (p \lor  q)) \\
      & (x_3 \leftrightarrow  (x_2 \land  r)) \\
      & (x_4 \leftrightarrow  (x_3 \to  x_1))
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Conjunct of clauses:</html:strong> Combine all the equivalence clauses into a single formula in CNF. The final formula <fr:tex display="inline"><![CDATA[\phi ']]></fr:tex> will be the conjunction of all these clauses along with the clause that asserts the truth of the variable representing the entire formula (in this case, <fr:tex display="inline"><![CDATA[x_4]]></fr:tex>):
    <fr:tex display="block"><![CDATA[
      \phi ' = (x_1 \leftrightarrow  \neg  s) \land  (x_2 \leftrightarrow  (p \lor  q)) \land  (x_3 \leftrightarrow  (x_2 \land  r)) \land  (x_4 \leftrightarrow  (x_3 \to  x_1)) \land  x_4
    ]]></fr:tex></html:li>
  <html:li><html:strong>Conversion to CNF:</html:strong> Finally, convert the combined formula into CNF using standard techniques (like distributing disjunctions over conjunctions). The resulting formula will be in CNF and equisatisfiable to the original formula <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. For example if we consider the clause 
    <fr:tex display="block"><![CDATA[
      x_2 \leftrightarrow  (p \lor  q)
    ]]></fr:tex> this can be converted to CNF as
    <fr:tex display="block"><![CDATA[
      (x_2 \lor  \neg  p) \land  (x_2 \lor  \neg  q) \land  (\neg  x_2 \lor  p \lor  q)
    ]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/000t/</fr:uri>
            <fr:display-uri>000t</fr:display-uri>
            <fr:route>/notes/000t/</fr:route>
            <fr:title text="Tseytin's Transformation">Tseytin's Transformation</fr:title>
            <fr:taxon>Quiz</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Lets consider the following formula</html:p><fr:tex display="block"><![CDATA[
  F \triangleq  (p \land  q) \lor  (p \land  \neg  r \land  s)
]]></fr:tex><html:p>Using Tseytin's transformation, convert the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> into an equisatisfiable formula in CNF.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  For the sake of breavity, lets skip assume the subformula extraction is already done and we created the following equivalence clauses:
  <fr:tex display="block"><![CDATA[
    \begin {align*}
    F_1 &\triangleq  t_1 \leftrightarrow  (\neg  r \land  s) \\
    F_2 &\triangleq  t_2 \leftrightarrow  (p \land  t_1) \\
    F_3 &\triangleq  t_3 \leftrightarrow  (p \land  q) \\
    F_4 &\triangleq  t_4 \leftrightarrow  (t_2 \lor  t_3)
    \end {align*}
  ]]></fr:tex>
  This gives us the following conjunct for the transformed formula:
  <fr:tex display="block"><![CDATA[
    F' \triangleq  F_1 \land  F_2 \land  F_3 \land  F_4 \land  t_4
  ]]></fr:tex>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/0003/</fr:uri>
            <fr:display-uri>0003</fr:display-uri>
            <fr:route>/notes/0003/</fr:route>
            <fr:title text="All VFS Quiz Solutions">All VFS Quiz Solutions</fr:title>
            <fr:taxon>VU-VFS-2025</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  This is an explanation and solution to all quizzes in the VFS lectures. By default I have the solutions minimized, but you can expand them by clicking on the upper part of the solution box (i.e. just click the solution section).
</html:p>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/0004/</fr:uri>
                <fr:display-uri>0004</fr:display-uri>
                <fr:route>/notes/0004/</fr:route>
                <fr:title text="Lecture 1 - Propositional Logic">Lecture 1 - Propositional Logic</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Syntax">Syntax</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0005/</fr:uri>
                        <fr:display-uri>0005</fr:display-uri>
                        <fr:route>/notes/0005/</fr:route>
                        <fr:title text="Syntax">Syntax</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Using BNF notation, the syntax of propositional logic can be defined as follows:</html:p>
 
  
  <html:figure><fr:resource hash="e8fe66989c999aaf2a9551442e29166b"><fr:resource-content><html:img src="/notes/e8fe66989c999aaf2a9551442e29166b.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
   % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
  
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to AndrÃ©C.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {align*}
    \text {Atom} \quad  \alpha  &::= p \mid  q \mid  r \mid  \top  \mid  \bot  \\
    \text {Literal} \quad  l &::= \alpha  \mid  \neg  \alpha  \\
    \text {Formula} \quad  F &::= l \mid  \neg  F  \mid  (F \land  F) \mid  (F \lor  F) \mid  (F \to  F) \mid  (F \leftrightarrow  F)
  \end {align*}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0006/</fr:uri>
                        <fr:display-uri>0006</fr:display-uri>
                        <fr:route>/notes/0006/</fr:route>
                        <fr:title text="Evaluating Syntax">Evaluating Syntax</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:ol><html:li><html:strong>Is <fr:tex display="inline"><![CDATA[p]]></fr:tex> an atom?</html:strong></html:li>
  <html:li><html:strong>Is <fr:tex display="inline"><![CDATA[p]]></fr:tex> a literal?</html:strong></html:li>
  <html:li><html:strong>Is <fr:tex display="inline"><![CDATA[p]]></fr:tex> a formula?</html:strong></html:li>
  <html:li><html:strong>What about <fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex>?</html:strong></html:li>
  <html:li><html:strong>What about <fr:tex display="inline"><![CDATA[\neg  \neg  p]]></fr:tex>? </html:strong></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>
      Yes, <fr:tex display="inline"><![CDATA[p]]></fr:tex> is an atom.
    </html:li>
    <html:li>
      Yes, <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a literal. Literals are either atoms or negated atoms, and since <fr:tex display="inline"><![CDATA[p]]></fr:tex> is an atom, it is also a literal.
    </html:li>
    <html:li>
      Yes, <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a formula. Formulas can be literals, and since <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a literal, it is also a formula.
    </html:li>
    <html:li><fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex> is not an atom, but it is a literal (as it is a negated atom) and therefore also a formula.
    </html:li>
    <html:li><fr:tex display="inline"><![CDATA[\neg  \neg  p]]></fr:tex> is a formula, since the inner negation <fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex> is a literal and any additional negation applied promotes it to a formula. In other words only <html:em>negated atoms</html:em> are literals but <html:em>negated literals</html:em> are formulas. This is especially important when we later discuss Negation Normal Form (NNF). 
    </html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Semantics &amp; Intepretations">Semantics &amp; Intepretations</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0007/</fr:uri>
                        <fr:display-uri>0007</fr:display-uri>
                        <fr:route>/notes/0007/</fr:route>
                        <fr:title text="Semantics">Semantics</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  We can define the semantic inference rules for propositional logic formulas under interpretations as follows inductively, starting with the base cases:
</html:p>
  
    
    <fr:resource hash="028beb2256956745cbd6c6d092a67ec4"><fr:resource-content><html:img src="/notes/028beb2256956745cbd6c6d092a67ec4.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Atom-$\top $]{
    I(p) = \top 
  }{
    I \models  p
  }
  \and 
  \inferrule *[right=Atom-$\bot $]{
    I(p) = \bot 
  }{
    I \not \models  p
  }
  \and 
  \inferrule *[right=True]{
  }{
    I \models  \top 
  }
  \and 
  \inferrule *[right=False]{
  }{
    I \not \models  \bot 
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
  Moving on to the inductive case we have
</html:p>
  
    
    <fr:resource hash="6b58c468fd4a9e74c51788f18b2ea6bb"><fr:resource-content><html:img src="/notes/6b58c468fd4a9e74c51788f18b2ea6bb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Neg-$\top $]{
    I \models  \neg  F
  }{
    I \not \models  F
  }
  \and 
  \inferrule *[right=Conj-$\top $]{
    I \models  F_1 \quad  I \models  F_2
  }{
    I \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=Disj-$\top $]{
    I \models  F_1 \quad  \text {or} \quad  I \models  F_2
  }{
    I \models  F_1 \lor  F_2
  }
  \and 
  \inferrule *[right=Imp-$\top $]{
    I \not \models  F_1 \quad  \text {or} \quad  I \models  F_2
  }{
    I \models  F_1 \to  F_2
  }
  \and 
  \inferrule *[right=Contr-$\top $]{
    I \models  F \\ I \not \models  F
  }{
    I \models  \bot 
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
  Similarly, the rules for when an interpretation does not satisfy a formula are as follows:
</html:p>
  
    
    <fr:resource hash="6be5095cad00657a1d9244ee3cab2d11"><fr:resource-content><html:img src="/notes/6be5095cad00657a1d9244ee3cab2d11.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Neg-$\bot $]{
    I \not \models  \neg  F
  }{
    I \models  F
  }
  \and 
  \inferrule *[right=Conj-$\bot $]{
    I \not \models  F_1 \quad  \text {or} \quad  I \not \models  F_2
  }{
    I \not \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=Disj-$\bot $]{
    I \not \models  F_1 \\ I \not \models  F_2
  }{
    I \not \models  F_1 \lor  F_2
  }
  \and 
  \inferrule *[right=Imp-$\bot $]{
    I \models  F_1 \\ I \not \models  F_2
  }{
    I \not \models  F_1 \to  F_2
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0008/</fr:uri>
                        <fr:display-uri>0008</fr:display-uri>
                        <fr:route>/notes/0008/</fr:route>
                        <fr:title text="Interpretation">Interpretation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We define an interpretation as a function which maps propositional variables in a formula to truth values, so formally</html:p>
                        <fr:tex display="block"><![CDATA[
  I : \texttt {Var} \to  \{\top , \bot \}
]]></fr:tex>
                        <html:p>We can <html:em>evaluate</html:em> a formula <html:em>under</html:em> an interpretation <fr:tex display="inline"><![CDATA[I]]></fr:tex> by substituting each propositional variable with its corresponding truth value given by <fr:tex display="inline"><![CDATA[I]]></fr:tex>. Naturally under different kinds of interpretations formulas can evaluate to different truth values. We can create a classifcation of formulas based on how many interpretations evaluate them to true or false.</html:p>
                        <html:ol><html:li><html:strong>satisfiable</html:strong>: A formula is satisfiable if there exists at least one interpretation under which it evaluates to true.</html:li>
  <html:li><html:strong>unsatisfying</html:strong>: A formula is unsatisfying if there exists at least one interpretation under which it evaluates to false.</html:li>
  <html:li><html:strong>tautology</html:strong>: A formula is a tautology if it evaluates to true under every possible interpretation.</html:li>
  <html:li><html:strong>contradiction</html:strong>: A formula is a contradiction if it evaluates to false under every possible interpretation.</html:li>
  <html:li><html:strong>contingent</html:strong>: A formula is contingent if it is satisfiable and unsatisfying, i.e., there exists at least one interpretation under which it evaluates to true and at least one interpretation under which it evaluates to false.</html:li></html:ol>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0009/</fr:uri>
                        <fr:display-uri>0009</fr:display-uri>
                        <fr:route>/notes/0009/</fr:route>
                        <fr:title text="Evaluating PL Formulae">Evaluating PL Formulae</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>
  Consider the formula 
  <fr:tex display="inline"><![CDATA[
    F \triangleq  (\neg  p \land  q)
  ]]></fr:tex>
  and interpretation 
  <fr:tex display="inline"><![CDATA[
    I \triangleq  \{p \to  \top , q \to  \bot \}
  ]]></fr:tex>
  Which of the following is true
</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[I \models  F]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[I \nvDash  F]]></fr:tex></html:li></html:ol><html:strong>
  What about the formula
  <fr:tex display="block"><![CDATA[
    (p \land  q) \to  (\neg  p \lor  q)
  ]]></fr:tex>
  under the same interpretation?
</html:strong>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  Theres two main ways you can usually approach questions like this, the more drawn out operational way and then just going by observation more or less. Starting out with the more pedantic approach we can try to construct a proof tree for the formula under the given interpretation. So considering the first formula we have: 
  
  
    
    <fr:resource hash="4807516d6cf6f2fdc256701b3e189646"><fr:resource-content><html:img src="/notes/4807516d6cf6f2fdc256701b3e189646.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule {
      \inferrule {
        \inferrule {
          I(p) = \top 
        }{
          I \models  p
        }
      }{
        I \nvDash  \neg  p
      }
      \quad 
      \inferrule {
        \inferrule {
          I(q) = \bot 
        }{
          I \nvDash  q
        }
      }{
        I \nvDash  q
      }
    }{
      I \nvDash  (\neg  p \land  q)
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  


  <html:p>So we can see that the interpretation does not satisfy the formula. In other words for this assignment the formula does not hold true. Given that this is a somewhat simple formula we could also just see this by observation, i.e. </html:p>
  <fr:tex display="block"><![CDATA[
    \underbrace {\neg  p}_{\texttt {False}} \land  \underbrace {q}_{\texttt {False}} \equiv  \bot 
  ]]></fr:tex>
  <html:p>For the second formula lets just go with the simpler approach again, so we have</html:p>
  <fr:resource hash="f4ab80a835ec37191d2964edcfdc39a1"><fr:resource-content><html:img src="/notes/f4ab80a835ec37191d2964edcfdc39a1.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
    \usepackage {amsmath}
    \usepackage {eulervm}
    \usepackage [scaled=0.92]{inconsolata} 

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        {\small
      \begin{align*}
          (p \land q) \to (\neg p \lor q) &\equiv (\texttt{true} \land \texttt{false}) \to (\neg \texttt{true} \lor \texttt{false}) \tag{by $I$}\\
      &\equiv \texttt{false} \to (\texttt{false} \lor \texttt{false}) \\
      &\equiv \texttt{false} \to \texttt{false} \\
      &\equiv \texttt{true} \tag{vacuously true} 
      \end{align*}
    }
  ]]></fr:resource-source></fr:resource>

  <html:p>So in this case the formula is satisfied by the interpretation.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000a/</fr:uri>
                        <fr:display-uri>000a</fr:display-uri>
                        <fr:route>/notes/000a/</fr:route>
                        <fr:title text="Evaluating sat/unsat/valid">Evaluating sat/unsat/valid</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Are the following formulas sat., unsat., or valid?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[(p\land  q) \to  \neg  p]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[(p \land  q) \to  (p \lor  \neg  q)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[(p \to  (q \to  r)) \land  \neg ((p \land  q) \to  r)]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  As a reminder lets recap the definitions:
  <html:ul><html:li>A formula is <html:strong>satisfiable</html:strong> if there exists at least one combination of true/false assignments to its variables that makes the formula true.</html:li>
    <html:li>A formula is <html:strong>unsatisfiable</html:strong> if there is no combination of true/false assignments to its variables that makes the formula true (i.e., it is always false).</html:li>
    <html:li>A formula is <html:strong>valid</html:strong> (or a tautology) if it is true under all possible combinations of true/false assignments to its variables.</html:li></html:ul>
  <html:p>Now we can analyze each formula:</html:p>
  <html:ol><html:li>For the lhs to be true both p and q must be true. However if p is true then <fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex> is false, making the implication false. If p is false then the then the implication is vacuously true regardless of what we set q to. Thus this formula is satisfiable (e.g., when p is false) but not valid (e.g., when p and q are true).</html:li>
    <html:li>If both p and q are true then the lhs is true and so is the rhs by virtue of p being true. If p is false then the implication is vacuously true regardless of q. If q is false then the rhs is true regardless of p. Thus this formula is valid as it is true for all combinations of truth values for p and q.</html:li>
    <html:li>The first part <fr:tex display="inline"><![CDATA[(p \to  (q \to  r))]]></fr:tex> is true unless p is true and either q or r is false. The second part <fr:tex display="inline"><![CDATA[\neg ((p \land  q) \to  r)]]></fr:tex> is true when p and q are true but r is false. Thus we can satisfy the entire formula by setting p and q to true and r to false. However if we set p to false then the first part is vacuously true but the second part becomes false. Thus this formula is satisfiable (e.g., when p and q are true and r is false) but not valid (e.g., when p is false).</html:li></html:ol>

  If you want to be absolutely sure about these kinds of questions constructing truth tables is always a good idea, albeit a bit tedious for formulas with many variables so just doing a bit of analysis like above is usually sufficient
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/000b/</fr:uri>
                <fr:display-uri>000b</fr:display-uri>
                <fr:route>/notes/000b/</fr:route>
                <fr:title text="Lecture 2 - Normal Forms &amp; DPLL">Lecture 2 - Normal Forms &amp; DPLL</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Formula Equivalence">Formula Equivalence</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000c/</fr:uri>
                        <fr:display-uri>000c</fr:display-uri>
                        <fr:route>/notes/000c/</fr:route>
                        <fr:title text="Equivalence of Formulae">Equivalence of Formulae</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Two formulas <fr:tex display="inline"><![CDATA[F]]></fr:tex> and <fr:tex display="inline"><![CDATA[G]]></fr:tex> are said to be <html:strong>equivalent</html:strong>, written <fr:tex display="inline"><![CDATA[F \equiv  G]]></fr:tex>, if they have the same truth value under every interpretation. In other words, for every interpretation <fr:tex display="inline"><![CDATA[I]]></fr:tex>, <fr:tex display="inline"><![CDATA[I \models  F]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[I \models  G]]></fr:tex>.
</html:p>
                        <fr:tex display="block"><![CDATA[
  F \equiv  G \iff  \forall  I (I \models  F \iff  I \models  G)
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000d/</fr:uri>
                        <fr:display-uri>000d</fr:display-uri>
                        <fr:route>/notes/000d/</fr:route>
                        <fr:title text="Normal Forms &amp; DPLL - Equivalence">Normal Forms &amp; DPLL - Equivalence</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Which of the following equivalences hold?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[\bot  \equiv  \bot ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\top  \equiv  \top ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  \top  \equiv  \neg  \bot ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  (p \land  q) \equiv  \neg  p \lor  \neg  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \equiv  p \lor  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  \neg  p \equiv  p]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>True. Both sides are always false.</html:li>
    <html:li>True. Both sides are always true.</html:li>
    <html:li>False. Left side is always false, right side is always true.</html:li>
    <html:li>True. This is <fr:link href="/notes/000g/" title="De Morgan's Laws" uri="https://kaierikniermann.github.io/notes/000g/" display-uri="000g" type="local">De Morgan's law</fr:link>. Good to remember 
      <fr:tex display="block"><![CDATA[
        \neg  (p \land  q) \equiv  \neg  p \lor  \neg  q
      ]]></fr:tex></html:li>
    <html:li>False. Left side is true when p is true, right side is true when either p or q is true.</html:li>
    <html:li>True. Double negation elimination.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Negation Normal Forms">Negation Normal Forms</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000e/</fr:uri>
                        <fr:display-uri>000e</fr:display-uri>
                        <fr:route>/notes/000e/</fr:route>
                        <fr:title text="Negation Normal Form (NNF)">Negation Normal Form (NNF)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is in Negation Normal Form (NNF) if the negation operator <fr:tex display="inline"><![CDATA[\neg ]]></fr:tex> is onyl applied to literlas (i.e., propositional variables or their negations), and the only other allowed operators are conjunction <fr:tex display="inline"><![CDATA[\land ]]></fr:tex> and disjunction <fr:tex display="inline"><![CDATA[\lor ]]></fr:tex>. A nice way to think about it is that we can never have the case where we need to apply <fr:link href="/notes/000g/" title="De Morgan's Laws" uri="https://kaierikniermann.github.io/notes/000g/" display-uri="000g" type="local">De Morgan's laws</fr:link> to push negations further down the formula tree. So all negations come pre-distributed to the literals.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000f/</fr:uri>
                        <fr:display-uri>000f</fr:display-uri>
                        <fr:route>/notes/000f/</fr:route>
                        <fr:title text="Negation Normal Form (NNF)">Negation Normal Form (NNF)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Which of the following formulas are in Negation Normal Form (NNF)?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[p \to  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q  \land  (r \lor  \neg  s))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q \land  \neg  (\neg  r \land  s))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q \land  (\neg  \neg  r \lor  \neg  s)) ]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>No. The implication operator <fr:tex display="inline"><![CDATA[\to ]]></fr:tex> is not allowed in NNF.</html:li>
    <html:li>Yes. Negations are only applied to literals, and only <fr:tex display="inline"><![CDATA[\land ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lor ]]></fr:tex> are used.</html:li>
    <html:li>No. The negation operator <fr:tex display="inline"><![CDATA[\neg ]]></fr:tex> is applied to a non-literal formula <fr:tex display="inline"><![CDATA[(\neg  r \land  s)]]></fr:tex>.</html:li>
    <html:li>No. The double negation <fr:tex display="inline"><![CDATA[\neg  \neg  r]]></fr:tex> is not allowed in NNF. Important to remember since that can trip you up.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Disjunctive Normal Form">Disjunctive Normal Form</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000k/</fr:uri>
                        <fr:display-uri>000k</fr:display-uri>
                        <fr:route>/notes/000k/</fr:route>
                        <fr:title text="Distributing Conjunction">Distributing Conjunction</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The distributive law of conjunction over disjunction states that for any formulas <fr:tex display="inline"><![CDATA[F]]></fr:tex>, <fr:tex display="inline"><![CDATA[G]]></fr:tex>, and <fr:tex display="inline"><![CDATA[H]]></fr:tex>, the following equivalence holds:</html:p>
                        <fr:tex display="block"><![CDATA[
  \begin {align*}
    F \land  (G \lor  H) &\equiv  (F \land  G) \lor  (F \land  H) \\
    (F \lor  G) \land  H &\equiv  (F \land  H) \lor  (G \land  H)
  \end {align*}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000j/</fr:uri>
                        <fr:display-uri>000j</fr:display-uri>
                        <fr:route>/notes/000j/</fr:route>
                        <fr:title text="Eliminating Implications and Biconditionals">Eliminating Implications and Biconditionals</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>To eliminate implications (<fr:tex display="inline"><![CDATA[\to ]]></fr:tex>) and biconditionals (<fr:tex display="inline"><![CDATA[\leftrightarrow ]]></fr:tex>) from a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex>, we can use the following equivalences:</html:p>
                        <fr:tex display="block"><![CDATA[
  \begin {align*}
    p \to  q &\equiv  \neg  p \lor  q \\
    p \leftrightarrow  q &\equiv  (p \land  q) \lor  (\neg  p \land  \neg  q)
  \end {align*}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000h/</fr:uri>
                        <fr:display-uri>000h</fr:display-uri>
                        <fr:route>/notes/000h/</fr:route>
                        <fr:title text="Disjunctive Normal Form (DNF)">Disjunctive Normal Form (DNF)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is in Disjunctive Normal Form (DNF) if it is a disjunction of one or more conjunctions of one or more literals. In other words, <fr:tex display="inline"><![CDATA[F]]></fr:tex> can be expressed as a series of clauses connected by disjunctions (<fr:tex display="inline"><![CDATA[\lor ]]></fr:tex>), where each clause is a series of literals connected by conjunctions (<fr:tex display="inline"><![CDATA[\land ]]></fr:tex>). A literal is either a propositional variable or its negation.</html:p>
                        <fr:tex display="block"><![CDATA[
  F = C_1 \lor  C_2 \lor  ... \lor  C_n
]]></fr:tex>
                        <html:p>Where each clause <fr:tex display="inline"><![CDATA[C_i]]></fr:tex> is of the form:</html:p>
                        <fr:tex display="block"><![CDATA[
  C_i = L_{i1} \land  L_{i2} \land  ... \land  L_{im}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000l/</fr:uri>
                        <fr:display-uri>000l</fr:display-uri>
                        <fr:route>/notes/000l/</fr:route>
                        <fr:title text="Converting to DNF">Converting to DNF</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Convert the following formula into Disjunctive Normal Form (DNF):</html:p><fr:tex display="block"><![CDATA[
  (q \lor  \neg  \neg  p) \land  (\neg  r \to  s)
]]></fr:tex>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <fr:resource hash="0ed774c5f98ccbf4fe2a8d866cb96b0e"><fr:resource-content><html:img src="/notes/0ed774c5f98ccbf4fe2a8d866cb96b0e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
    \usepackage {amsmath}
    \usepackage {eulervm}
    \usepackage [scaled=0.92]{inconsolata} 
  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        {\small
      \begin{align*}
        & (q \lor \neg \neg p) \land (\neg r \to s) \\
        & \equiv (q \lor p) \land (r \lor s) \tag{Eliminate Implication} \\
        & \equiv ((q \lor p) \land r) \lor ((q \lor p) \land s) \tag{Distribute Conjunction} \\
        & \equiv (q \land r) \lor (p \land r) \lor (q \land s) \lor (p \land s) \tag{Distribute Conjunction} \\
      \end{align*}
    }
  ]]></fr:resource-source></fr:resource>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000q/</fr:uri>
                        <fr:display-uri>000q</fr:display-uri>
                        <fr:route>/notes/000q/</fr:route>
                        <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Two formulas are said to be <html:strong>equisatisfiable</html:strong> if either both formulas are satisfiable or both are unsatisfiable. In other words, there exists an assignment of truth values to the variables that makes one formula true if and only if there exists; not necessarily the same assignment; that makes the other formula true. Equisatisfiability is a weaker condition than logical equivalence, as equisatisfiable formulas may not have the same truth values under all assignments, but they share the same satisfiability status.</html:p>
                        <fr:tex display="block"><![CDATA[
  \texttt {equisat}(F, G) \iff  (\exists  I.\ I \models  F) \iff  (\exists  J.\ J \models  G)
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000r/</fr:uri>
                        <fr:display-uri>000r</fr:display-uri>
                        <fr:route>/notes/000r/</fr:route>
                        <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> and <fr:tex display="inline"><![CDATA[G]]></fr:tex> are equisatisfiable, then are they equivalent?</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  No. We can answer this in a few different ways. In the most direct sense they are just definitionally not the same thing, in that equivalence requires that both formulas have the same truth value under all interpretations, whereas equisatisfiability only requires that both formulas have <html:em>a</html:em> satisfying interpretation or both be unsatisfiable.

  Another way to see it is that in an abstract sense equivalence describes an object-level relationship between formulas, whereas equisatisfiability describes a meta-level relationship about the existence of satisfying interpretations. Thus they are fundamentally different kinds of relationships.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Tseitin Transformation">Tseitin Transformation</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000n/</fr:uri>
                        <fr:display-uri>000n</fr:display-uri>
                        <fr:route>/notes/000n/</fr:route>
                        <fr:title text="Conjunctive Normal Form (CNF)">Conjunctive Normal Form (CNF)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  A formula is in <html:strong>Conjunctive Normal Form (CNF)</html:strong> if it is expressed as a conjunction of disjunctions of literals. In other words, a CNF formula is a series of clauses (disjunctions) connected by AND operators. Each clause contains literals (variables or their negations) connected by OR operators. For example, the formula <fr:tex display="inline"><![CDATA[(p \lor  \neg  q) \land  (r \lor  s \lor  \neg  t)]]></fr:tex> is in CNF.
</html:p>
                        <fr:tex display="block"><![CDATA[
  F = C_1 \land  C_2 \land  ... \land  C_n
]]></fr:tex>
                        <html:p>Where each clause <fr:tex display="inline"><![CDATA[C_i]]></fr:tex> is of the form:</html:p>
                        <fr:tex display="block"><![CDATA[
  C_i = L_{i1} \lor  L_{i2} \lor  ... \lor  L_{im}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000m/</fr:uri>
                        <fr:display-uri>000m</fr:display-uri>
                        <fr:route>/notes/000m/</fr:route>
                        <fr:title text="Exponential Blow up problem">Exponential Blow up problem</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  When converting a formula to Disjunctive Normal Form (DNF) or Conjunctive Normal Form (CNF), the size of the resulting formula can grow exponentially in the worst case. This is known as the <html:strong>exponential blow up problem</html:strong>. For example, a formula with <fr:tex display="inline"><![CDATA[n]]></fr:tex> variables can result in a DNF or CNF with up to <fr:tex display="inline"><![CDATA[2^n]]></fr:tex> clauses.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000s/</fr:uri>
                        <fr:display-uri>000s</fr:display-uri>
                        <fr:route>/notes/000s/</fr:route>
                        <fr:title text="Tseytin's Transformation">Tseytin's Transformation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Tseytin's transformation is a method used in propositional logic to convert any given formula into an equisatisfiable formula in <fr:link href="/notes/000n/" title="Conjunctive Normal Form (CNF)" uri="https://kaierikniermann.github.io/notes/000n/" display-uri="000n" type="local">Conjunctive Normal Form (CNF)</fr:link>. The key idea behind Tseytin's transformation is to introduce new variables to represent subformulas of the original formula, thereby avoiding <fr:link href="/notes/000m/" title="Exponential Blow up problem" uri="https://kaierikniermann.github.io/notes/000m/" display-uri="000m" type="local">an exponential increase in size</fr:link> that can occur with naive CNF conversion methods. There are two key properties of Tseytin's for a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> and its Tseytin transformation <fr:tex display="inline"><![CDATA[F']]></fr:tex>:</html:p>
                        <html:ol><html:li><html:strong>unsatisfiability:</html:strong> <fr:tex display="inline"><![CDATA[F]]></fr:tex> is unsatisfiable if and only if <fr:tex display="inline"><![CDATA[F']]></fr:tex> is unsatisfiable.</html:li>
  <html:li><html:strong>model correspondence:</html:strong> For every satisfying assignment (model) of <fr:tex display="inline"><![CDATA[F']]></fr:tex>, there exists a corresponding satisfying assignment of <fr:tex display="inline"><![CDATA[F]]></fr:tex>, and vice versa, when restricted to the original variables of <fr:tex display="inline"><![CDATA[F]]></fr:tex>.</html:li></html:ol>
                        <html:p>To demonstrate how it works lets consider the following formula</html:p>
                        <fr:tex display="block"><![CDATA[
  \phi  = ((p \lor  q ) \land  r) \to  (\neg  s)
]]></fr:tex>
                        <html:ol><html:li><html:strong>Subformula identification:</html:strong> Identify the subformulas of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> and assign a new variable to each subformula. For our example, we can identify the following subformulas and assign new variables:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & \neg  s \\ 
      & p \lor  q \\
      & (p \lor  q) \land  r \\
      & ((p \lor  q) \land  r) \to  (\neg  s)
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Variable assignment:</html:strong> Assign new variables to each subformula:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & x_1 \text { for } \neg  s \\ 
      & x_2 \text { for } p \lor  q \\
      & x_3 \text { for } (p \lor  q) \land  r \\
      & x_4 \text { for } ((p \lor  q) \land  r) \to  (\neg  s)
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Equivalence clauses:</html:strong> For each subformula, create clauses that enforce the equivalence between the new variable and the subformula it represents. For our example, we would create the following clauses:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & (x_1 \leftrightarrow  \neg  s) \\
      & (x_2 \leftrightarrow  (p \lor  q)) \\
      & (x_3 \leftrightarrow  (x_2 \land  r)) \\
      & (x_4 \leftrightarrow  (x_3 \to  x_1))
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Conjunct of clauses:</html:strong> Combine all the equivalence clauses into a single formula in CNF. The final formula <fr:tex display="inline"><![CDATA[\phi ']]></fr:tex> will be the conjunction of all these clauses along with the clause that asserts the truth of the variable representing the entire formula (in this case, <fr:tex display="inline"><![CDATA[x_4]]></fr:tex>):
    <fr:tex display="block"><![CDATA[
      \phi ' = (x_1 \leftrightarrow  \neg  s) \land  (x_2 \leftrightarrow  (p \lor  q)) \land  (x_3 \leftrightarrow  (x_2 \land  r)) \land  (x_4 \leftrightarrow  (x_3 \to  x_1)) \land  x_4
    ]]></fr:tex></html:li>
  <html:li><html:strong>Conversion to CNF:</html:strong> Finally, convert the combined formula into CNF using standard techniques (like distributing disjunctions over conjunctions). The resulting formula will be in CNF and equisatisfiable to the original formula <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. For example if we consider the clause 
    <fr:tex display="block"><![CDATA[
      x_2 \leftrightarrow  (p \lor  q)
    ]]></fr:tex> this can be converted to CNF as
    <fr:tex display="block"><![CDATA[
      (x_2 \lor  \neg  p) \land  (x_2 \lor  \neg  q) \land  (\neg  x_2 \lor  p \lor  q)
    ]]></fr:tex></html:li></html:ol>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000t/</fr:uri>
                        <fr:display-uri>000t</fr:display-uri>
                        <fr:route>/notes/000t/</fr:route>
                        <fr:title text="Tseytin's Transformation">Tseytin's Transformation</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Lets consider the following formula</html:p><fr:tex display="block"><![CDATA[
  F \triangleq  (p \land  q) \lor  (p \land  \neg  r \land  s)
]]></fr:tex><html:p>Using Tseytin's transformation, convert the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> into an equisatisfiable formula in CNF.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  For the sake of breavity, lets skip assume the subformula extraction is already done and we created the following equivalence clauses:
  <fr:tex display="block"><![CDATA[
    \begin {align*}
    F_1 &\triangleq  t_1 \leftrightarrow  (\neg  r \land  s) \\
    F_2 &\triangleq  t_2 \leftrightarrow  (p \land  t_1) \\
    F_3 &\triangleq  t_3 \leftrightarrow  (p \land  q) \\
    F_4 &\triangleq  t_4 \leftrightarrow  (t_2 \lor  t_3)
    \end {align*}
  ]]></fr:tex>
  This gives us the following conjunct for the transformed formula:
  <fr:tex display="block"><![CDATA[
    F' \triangleq  F_1 \land  F_2 \land  F_3 \land  F_4 \land  t_4
  ]]></fr:tex>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/000u/</fr:uri>
                <fr:display-uri>000u</fr:display-uri>
                <fr:route>/notes/000u/</fr:route>
                <fr:title text="Lecture 3 - First Order Logic">Lecture 3 - First Order Logic</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Syntax">Syntax</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000v/</fr:uri>
                        <fr:display-uri>000v</fr:display-uri>
                        <fr:route>/notes/000v/</fr:route>
                        <fr:title text="FOL - Syntax">FOL - Syntax</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We can define a first order language as a tuple of 3 sets <fr:tex display="inline"><![CDATA[\langle  \mathcal  C, \mathcal  F, \mathcal  R\rangle ]]></fr:tex> where:</html:p>
                        <html:ul><html:li><html:strong>Constants</html:strong> (<fr:tex display="inline"><![CDATA[\mathcal  C]]></fr:tex>): the set of constants in the language. E.g., <fr:tex display="inline"><![CDATA[\{a, b, c\}]]></fr:tex></html:li>
  <html:li><html:strong>Function Symbols</html:strong> (<fr:tex display="inline"><![CDATA[\mathcal  F]]></fr:tex>): the set of function symbols in the language. E.g., <fr:tex display="inline"><![CDATA[\{f, g, h\}]]></fr:tex></html:li>
  <html:li><html:strong>Relation Symbols</html:strong> (<fr:tex display="inline"><![CDATA[\mathcal  R]]></fr:tex>): the set of relation symbols in the language. E.g., <fr:tex display="inline"><![CDATA[\{R, S, T\}]]></fr:tex></html:li></html:ul>
                        <html:p>Using BNF we can define the syntax as follows</html:p>
                        <fr:resource hash="18b8dd7c29a3cc72847fbb5fc08ba8f0">
                          <fr:resource-content>
                            <html:img src="/notes/18b8dd7c29a3cc72847fbb5fc08ba8f0.svg" />
                          </fr:resource-content>
                          <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {amsmath}
  \usepackage {eulervm}
]]></fr:resource-source>
                          <fr:resource-source type="latex" part="body"><![CDATA[
{\small  
  \begin {align*}
    \text {Atom} \quad  \alpha  &::= \top  \mid  \bot  \mid  p(t_1, \ldots , t_n) \\
    \text {Formula} \quad  F &::= \alpha  \mid  \neg  F  \mid  (F \land  F) \mid  (F \lor  F) \mid  (F \to  F) \mid  (F \leftrightarrow  F) \mid  \forall  x.\ F \mid  \exists  x.\ F \\
  \end {align*}
}
]]></fr:resource-source>
                        </fr:resource>
                        <html:p>Here the atom <fr:tex display="inline"><![CDATA[p]]></fr:tex> rerpesents an <html:em>atomic predicate</html:em> applied to terms <fr:tex display="inline"><![CDATA[t_1, \ldots , t_n]]></fr:tex>, where <fr:tex display="inline"><![CDATA[p \in  \mathcal  R]]></fr:tex> with an arity of <fr:tex display="inline"><![CDATA[n]]></fr:tex></html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000w/</fr:uri>
                        <fr:display-uri>000w</fr:display-uri>
                        <fr:route>/notes/000w/</fr:route>
                        <fr:title text="First Order Logic - Syntax">First Order Logic - Syntax</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Which of the following are syntactically valid formulas in first order logic?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[f(x)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(x)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(f(x))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(p(x))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(f(f(x)))]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li><fr:tex display="inline"><![CDATA[f(x)]]></fr:tex>: <html:em>Invalid</html:em>, as <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a function symbol and cannot stand alone as a formula.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(x)]]></fr:tex>: <html:em>Valid</html:em>, as <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a relation symbol applied to the term <fr:tex display="inline"><![CDATA[x]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(f(x))]]></fr:tex>: <html:em>Valid</html:em>, as <fr:tex display="inline"><![CDATA[f(x)]]></fr:tex> is a term and <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a relation symbol applied to that term.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(p(x))]]></fr:tex>: <html:em>Invalid</html:em>, as <fr:tex display="inline"><![CDATA[p(x)]]></fr:tex> is a formula, not a term, and cannot be an argument to <fr:tex display="inline"><![CDATA[p]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(f(f(x)))]]></fr:tex>: <html:em>Valid</html:em>, as <fr:tex display="inline"><![CDATA[f(x)]]></fr:tex> is a term, and applying <fr:tex display="inline"><![CDATA[f]]></fr:tex> again yields another term, which can be an argument to <fr:tex display="inline"><![CDATA[p]]></fr:tex>.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Quantifiers &amp; Scoping">Quantifiers &amp; Scoping</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000x/</fr:uri>
                        <fr:display-uri>000x</fr:display-uri>
                        <fr:route>/notes/000x/</fr:route>
                        <fr:title text="FOL - Quantifiers and Scoping">FOL - Quantifiers and Scoping</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>For quantifiers:</html:p>
                        <fr:tex display="block"><![CDATA[
  \forall  x.\ F \quad  \exists  x.\ F
]]></fr:tex>
                        <html:p>Each variable occuring within the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> known as the <html:em>scope</html:em> is either:</html:p>
                        <html:ul><html:li><html:strong>bound</html:strong>: if it is within the scope of a quantifier that binds it. E.g., in <fr:tex display="inline"><![CDATA[\forall  x.\ P(x, y)]]></fr:tex>, the variable <fr:tex display="inline"><![CDATA[x]]></fr:tex> is bound.</html:li>
  <html:li><html:strong>free</html:strong>: if it is not bound by any quantifier within the formula. E.g., in <fr:tex display="inline"><![CDATA[\forall  x.\ P(x, y)]]></fr:tex>, the variable <fr:tex display="inline"><![CDATA[y]]></fr:tex> is free.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000y/</fr:uri>
                        <fr:display-uri>000y</fr:display-uri>
                        <fr:route>/notes/000y/</fr:route>
                        <fr:title text="Quantifiers and Scoping in FOL">Quantifiers and Scoping in FOL</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the formula</html:p><fr:tex display="block"><![CDATA[
  \forall  y.\ ((\forall  x.\ p(x))) \to  q(x, y)
]]></fr:tex><html:ol><html:li>Is the <fr:tex display="inline"><![CDATA[y]]></fr:tex> bound or free?</html:li>
  <html:li>Is the first occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> bound or free?</html:li>
  <html:li>Is the second occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> bound or free?</html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li><fr:tex display="inline"><![CDATA[y]]></fr:tex> is <html:em>bound</html:em>, as it is within the scope of the quantifier <fr:tex display="inline"><![CDATA[\forall  y]]></fr:tex>.</html:li>
    <html:li>The first occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> is <html:em>bound</html:em>, as it is within the scope of the quantifier <fr:tex display="inline"><![CDATA[\forall  x]]></fr:tex>.</html:li>
    <html:li>The second occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> is <html:em>free</html:em>, as it is not within the scope of any quantifier that binds it.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Closed, Open &amp; Ground Formulas">Closed, Open &amp; Ground Formulas</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000z/</fr:uri>
                        <fr:display-uri>000z</fr:display-uri>
                        <fr:route>/notes/000z/</fr:route>
                        <fr:title text="Closed, Open, and Ground Formulas (FOL)">Closed, Open, and Ground Formulas (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We have 3 important classifications of formulas in First Order Logic (FOL) based on the nature of their variables:</html:p>
                        <html:ul><html:li><html:strong>Closed Formula</html:strong>: A formula with <html:em>no free variables</html:em>. All variables in the formula are bound by quantifiers. E.g., <fr:tex display="inline"><![CDATA[\forall  x.\ \exists  y.\ p(x, y)]]></fr:tex> is a closed formula.</html:li>
  <html:li><html:strong>Open Formula</html:strong>: A formula with <html:em>at least one free variable</html:em>. E.g., <fr:tex display="inline"><![CDATA[p(x, y)]]></fr:tex> is an open formula since both <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> are free.</html:li>
  <html:li><html:strong>Ground Formula</html:strong>: A formula with <html:em>no variables at all</html:em>. E.g., <fr:tex display="inline"><![CDATA[p(a, b)]]></fr:tex> is a ground formula if <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> are constants.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0010/</fr:uri>
                        <fr:display-uri>0010</fr:display-uri>
                        <fr:route>/notes/0010/</fr:route>
                        <fr:title text="FOL - Closed, Open, and Ground Formulas">FOL - Closed, Open, and Ground Formulas</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following formula</html:p><fr:tex display="block"><![CDATA[
  \forall  y.\ ((\forall  x.\ p(x))) \to  (\exists  x.\ q(x, y))
]]></fr:tex><html:p>Is this formula closed, open, or ground?</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  This formula is a <html:strong>closed formula</html:strong> because all variables within the formula are bound by quantifiers. The variable <fr:tex display="inline"><![CDATA[y]]></fr:tex> is bound by the quantifier <fr:tex display="inline"><![CDATA[\forall  y]]></fr:tex>, and both occurrences of <fr:tex display="inline"><![CDATA[x]]></fr:tex> are bound by their respective quantifiers <fr:tex display="inline"><![CDATA[\forall  x]]></fr:tex> and <fr:tex display="inline"><![CDATA[\exists  x]]></fr:tex>. There are no free variables in this formula. 

  A nice example of a ground formula is something like this 
  <fr:tex display="block"><![CDATA[
    p(a, f(b)) \to  q(c)
  ]]></fr:tex>
  We can see here that there are no variables at all; <fr:tex display="inline"><![CDATA[a]]></fr:tex>, <fr:tex display="inline"><![CDATA[b]]></fr:tex>, and <fr:tex display="inline"><![CDATA[c]]></fr:tex> are not bound by any quantifiers, hence the formula is ground since we arent substituting/quantifying over any variables.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Term Evaluation">Term Evaluation</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0012/</fr:uri>
                        <fr:display-uri>0012</fr:display-uri>
                        <fr:route>/notes/0012/</fr:route>
                        <fr:title text="Interpretation (FOL)">Interpretation (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In first order logic a <html:em>Interpretation</html:em>; similar to the case of propositional logic; is a mapping which assigns meaning to the syntax of the language. In this instance its a mapping from constants, function symbols and predicate symbols to specific objects, functions and relations in a given domain. We can define an interpretation as a sort of piecewise function as follows:</html:p>
                        <fr:tex display="block"><![CDATA[
  \begin {align*}
    I &: \mathcal  C \cup  \mathcal  F \cup  \mathcal  R \to  D \cup  (D^n \to  D) \cup  (D^n \to  \{\top , \bot \}) \\
    I(c) & = d \quad  \forall  c \in  \mathcal  C, d \in  D \\
    I(f) & = f_D: D^n \to  D \quad  \forall  f \in  \mathcal  F \\
    I(p) & = p_D: D^n \to  \{\top , \bot \} \quad  \forall  p \in  \mathcal  R \\
  \end {align*}
]]></fr:tex>
                        <html:p>Where <fr:tex display="inline"><![CDATA[D]]></fr:tex> (sometimes also denoted as <fr:tex display="inline"><![CDATA[U]]></fr:tex>) is the <html:em>domain of discourse</html:em> which is a non-empty set of objects over which the quantifiers range. Intuitively the domain of discourse represents what we wish to talk about in our interpretation. We can break this down into 3 parts:</html:p>
                        <html:ul><html:li><html:strong>constants</html:strong> (<fr:tex display="inline"><![CDATA[c \in  \mathcal  C]]></fr:tex>): are mapped to specific elements in the domain <fr:tex display="inline"><![CDATA[d \in  D]]></fr:tex>. For example if <fr:tex display="inline"><![CDATA[c]]></fr:tex> is the constant <fr:tex display="inline"><![CDATA["a"]]></fr:tex> and <fr:tex display="inline"><![CDATA[D = \{1, 2, 3\}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[I(a) = 1]]></fr:tex> could be a valid mapping.</html:li>
  <html:li><html:strong>function symbols</html:strong> (<fr:tex display="inline"><![CDATA[f \in  \mathcal  F]]></fr:tex>): are mapped to functions that take elements from the domain and return elements in the domain. For example if <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a unary function symbol <fr:tex display="inline"><![CDATA["f"]]></fr:tex> and <fr:tex display="inline"><![CDATA[D = \{1, 2, 3\}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[I(f) = f_D]]></fr:tex> where <fr:tex display="inline"><![CDATA[f_D(1) = 2]]></fr:tex>, <fr:tex display="inline"><![CDATA[f_D(2) = 3]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f_D(3) = 1]]></fr:tex> could be a valid mapping.</html:li>
  <html:li><html:strong>relation symbols</html:strong> (<fr:tex display="inline"><![CDATA[p \in  \mathcal  R]]></fr:tex>): are mapped to relations (or predicates) that take elements from the domain and return truth values <fr:tex display="inline"><![CDATA[\{\top , \bot \}]]></fr:tex>. For example if <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a binary relation symbol <fr:tex display="inline"><![CDATA["R"]]></fr:tex> and <fr:tex display="inline"><![CDATA[D = \{1, 2, 3\}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[I(R) = R_D]]></fr:tex> where <fr:tex display="inline"><![CDATA[R_D(1, 2) = \top ]]></fr:tex>, <fr:tex display="inline"><![CDATA[R_D(2, 3) = \bot ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[R_D(3, 1) = \top ]]></fr:tex> could be a valid mapping.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0013/</fr:uri>
                        <fr:display-uri>0013</fr:display-uri>
                        <fr:route>/notes/0013/</fr:route>
                        <fr:title text="Structures and Variable Assignments (FOL)">Structures and Variable Assignments (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A <html:strong>structure</html:strong> <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> for a first-order language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> consists of:</html:p>
                        <html:ul><html:li>A non-empty domain <fr:tex display="inline"><![CDATA[D]]></fr:tex>, which is the set of objects that the variables can refer to.</html:li>
  <html:li>An interpretation function <fr:tex display="inline"><![CDATA[I]]></fr:tex> that assigns meanings to the non-logical symbols in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>:</html:li>
  <html:ul><html:li>For each constant symbol <fr:tex display="inline"><![CDATA[c]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, <fr:tex display="inline"><![CDATA[I(c)]]></fr:tex> is an element of <fr:tex display="inline"><![CDATA[D]]></fr:tex>.</html:li>
    <html:li>For each n-ary function symbol <fr:tex display="inline"><![CDATA[f]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, <fr:tex display="inline"><![CDATA[I(f)]]></fr:tex> is a function from <fr:tex display="inline"><![CDATA[D^n]]></fr:tex> to <fr:tex display="inline"><![CDATA[D]]></fr:tex>.</html:li>
    <html:li>For each n-ary predicate symbol <fr:tex display="inline"><![CDATA[P]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, <fr:tex display="inline"><![CDATA[I(P)]]></fr:tex> is a subset of <fr:tex display="inline"><![CDATA[D^n]]></fr:tex>.</html:li></html:ul></html:ul>
                        <html:p>A <html:strong>variable assignment</html:strong> <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> for a structure <fr:tex display="inline"><![CDATA[S]]></fr:tex> is a function that assigns each variable to an element of the domain <fr:tex display="inline"><![CDATA[D]]></fr:tex> of the structure. That is, for each variable <fr:tex display="inline"><![CDATA[x]]></fr:tex>, <fr:tex display="inline"><![CDATA[\sigma (x) \in  D]]></fr:tex>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0011/</fr:uri>
                        <fr:display-uri>0011</fr:display-uri>
                        <fr:route>/notes/0011/</fr:route>
                        <fr:title text="Term evaluation (FOL)">Term evaluation (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In First Order Logic, terms are evaluated based on an <fr:link href="/notes/0012/" title="Interpretation (FOL)" uri="https://kaierikniermann.github.io/notes/0012/" display-uri="0012" type="local">interpretation</fr:link> <fr:tex display="inline"><![CDATA[I]]></fr:tex> and a <fr:link href="/notes/0013/" title="Structures and Variable Assignments (FOL)" uri="https://kaierikniermann.github.io/notes/0013/" display-uri="0013" type="local">variable assignment</fr:link> <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> within a structure <fr:tex display="inline"><![CDATA[S]]></fr:tex> denoted as <fr:tex display="inline"><![CDATA[\langle  I, \sigma \rangle (t)]]></fr:tex>. The evaluation rules are as follows:</html:p>
                        <html:ul><html:li>If <fr:tex display="inline"><![CDATA[t]]></fr:tex> is a constant symbol <fr:tex display="inline"><![CDATA[c]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\langle  I, \sigma \rangle (c) = I(c)]]></fr:tex>.</html:li>
  <html:li>If <fr:tex display="inline"><![CDATA[t]]></fr:tex> is a variable <fr:tex display="inline"><![CDATA[x]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\langle  I, \sigma \rangle (x) = \sigma (x)]]></fr:tex>.</html:li>
  <html:li>If <fr:tex display="inline"><![CDATA[t]]></fr:tex> is a function application <fr:tex display="inline"><![CDATA[f(t_1, t_2, \ldots , t_n)]]></fr:tex>, then 
    <fr:tex display="block"><![CDATA[
      \langle  I, \sigma \rangle (f(t_1, t_2, \ldots , t_n)) = I(f)(\langle  I, \sigma \rangle (t_1), \langle  I, \sigma \rangle (t_2), \ldots , \langle  I, \sigma \rangle (t_n))
    ]]></fr:tex></html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0014/</fr:uri>
                        <fr:display-uri>0014</fr:display-uri>
                        <fr:route>/notes/0014/</fr:route>
                        <fr:title text="Term evaluation (FOL)">Term evaluation (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following domain/universe of discourse, variable assignment, and interpretation:</html:p><html:ul><html:li>Universe 
  <fr:tex display="block"><![CDATA[
    U \triangleq  \{1, 2\}
  ]]></fr:tex></html:li>
  <html:li>Variable assignment
    <fr:tex display="block"><![CDATA[
      \sigma  \triangleq  \{x\mapsto  2, y\mapsto  1\}
    ]]></fr:tex></html:li>
  <html:li>
    Interpretation
    <fr:tex display="block"><![CDATA[
      \begin {align*}
        I & \triangleq  \{a \mapsto  1, b \mapsto  2\} \\ 
        I & \triangleq  \{f(1, 1) \mapsto  2, f(1, 2) \mapsto  2, f(2, 1) \mapsto  1, f(2, 2) \mapsto  1\} 
      \end {align*}
    ]]></fr:tex></html:li></html:ul><html:p>What is the evaluation of the following terms under the given interpretation and variable assignment?</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[f(a, y)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[f(x, b)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[f(f(x, b), f(a, y))]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:ol><html:li><fr:tex display="inline"><![CDATA[\langle  I, \sigma  \rangle  (f(a, y)) = I(f)(\langle  I, \sigma  \rangle  (a), \langle  I, \sigma  \rangle  (y)) = I(f)(I(a), \sigma (y)) = I(f)(1, 1) = 2]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\langle  I, \sigma  \rangle  (f(x, b)) = I(f)(\langle  I, \sigma  \rangle  (x), \langle  I, \sigma  \rangle  (b)) = I(f)(\sigma (x), I(b)) = I(f)(2, 2) = 1]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\langle  I, \sigma  \rangle  (f(f(x, b), f(a, y))) = I(f)(\langle  I, \sigma  \rangle  (f(x, b)), \langle  I, \sigma  \rangle  (f(a, y))) = I(f)(1, 2) = 2]]></fr:tex></html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Semantic Entailment">Semantic Entailment</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0015/</fr:uri>
                        <fr:display-uri>0015</fr:display-uri>
                        <fr:route>/notes/0015/</fr:route>
                        <fr:title text="Semantic Entailment \models  (FOL)">Semantic Entailment <fr:tex display="inline"><![CDATA[\models ]]></fr:tex> (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  We evaluate formulas in first order logic <html:em>under</html:em> a structure which consists of a domain and an interpretation function. In addition, we need a variable assignment to evaluate formulas with free variables. To denote truth under a structure <fr:tex display="inline"><![CDATA[S]]></fr:tex> and variable assignment <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> we write:
</html:p><html:ul><html:li><html:strong>True</html:strong>: If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> evaluates to true under <fr:tex display="inline"><![CDATA[U, I, \sigma ]]></fr:tex> we write <fr:tex display="block"><![CDATA[U, I, \sigma  \models  F]]></fr:tex></html:li>
  <html:li><html:strong>False</html:strong>: If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> evaluates to false under <fr:tex display="inline"><![CDATA[U, I, \sigma ]]></fr:tex> we write <fr:tex display="block"><![CDATA[U, I, \sigma  \nvDash  F]]></fr:tex></html:li></html:ul><html:p>
  We can define semantic entailment inductively as follows:
</html:p>
  
    
    <fr:resource hash="d7624c2c82ab393fab290297f3fd0420"><fr:resource-content><html:img src="/notes/d7624c2c82ab393fab290297f3fd0420.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=True]{}{
    U, I, \sigma  \models  \top 
  }
  \and 
  \inferrule *[right=False]{}{
    U, I, \sigma  \not \models  \bot 
  }
  \and 
  \inferrule *[right=Eval]{
    p(t_1, \ldots , t_n) \\ I = \{p \mapsto  \langle  I, \sigma \rangle (t_1), \ldots , \langle  I, \sigma  \rangle (t_n)\}
  }{
    U, I, \sigma  \models  p(t_1, \ldots , t_n)
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0016/</fr:uri>
                        <fr:display-uri>0016</fr:display-uri>
                        <fr:route>/notes/0016/</fr:route>
                        <fr:title text="Semantic Entailment (FOL)">Semantic Entailment (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider constants (free variables) <fr:tex display="inline"><![CDATA[a, b]]></fr:tex> and a unary function <fr:tex display="inline"><![CDATA[f]]></fr:tex>, and a binary predicate <fr:tex display="inline"><![CDATA[p]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[U = \{\alpha , \beta \}]]></fr:tex> and interpretation function <fr:tex display="inline"><![CDATA[I]]></fr:tex> be defined as follows:</html:p><fr:tex display="block"><![CDATA[
  \begin {align*}
    I &= \{a \mapsto  \alpha , b \mapsto  \beta \} \\ 
    I &= \{f(\alpha ) \mapsto  \beta , f(\beta ) \mapsto  \alpha \} \\
    I &= \{p(\beta , \alpha ) \mapsto  \top , p(\beta , \beta ) \mapsto  \top \}
  \end {align*}
]]></fr:tex><html:p>Under the structure <fr:tex display="inline"><![CDATA[S = (U, I)]]></fr:tex> and variable assignment <fr:tex display="inline"><![CDATA[\sigma  = \{x \mapsto  \alpha \}]]></fr:tex> what do the following formulas evaluate to?</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[p(f(b), f(x))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(f(x), f(b))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(a, f(x))]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li><fr:tex display="inline"><![CDATA[p(f(b), f(x))]]></fr:tex> evaluates to <fr:tex display="inline"><![CDATA[\top ]]></fr:tex> because <fr:tex display="inline"><![CDATA[f(b) = f(\beta ) = \alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(x) = f(\alpha ) = \beta ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[p(\alpha , \beta ) = \top ]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(f(x), f(b))]]></fr:tex> evaluates to <fr:tex display="inline"><![CDATA[\top ]]></fr:tex> because <fr:tex display="inline"><![CDATA[f(x) = f(\alpha ) = \beta ]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(b) = f(\beta ) = \alpha ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[p(\beta , \alpha ) = \top ]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(a, f(x))]]></fr:tex> evaluates to <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex> because <fr:tex display="inline"><![CDATA[a = \alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(x) = f(\alpha ) = \beta ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[p(\alpha , \beta ) = \bot ]]></fr:tex>.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Semantic argument method">Semantic argument method</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0017/</fr:uri>
                        <fr:display-uri>0017</fr:display-uri>
                        <fr:route>/notes/0017/</fr:route>
                        <fr:title text="Connectives and Quantifiers (FOL)">Connectives and Quantifiers (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>In addition to evaluating atomic formulas, we can define the evaluation of complex formulas using logical connectives and quantifiers as follows:</html:p>
  
    
    <fr:resource hash="2ed6f8116f00585c9a6a6031eb24b377"><fr:resource-content><html:img src="/notes/2ed6f8116f00585c9a6a6031eb24b377.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Not-True]{
    S, \sigma  \not \models  F
  }{
    S, \sigma  \models  \neg  F
  }
  \and 
  \inferrule *[right=Not-False]{
    S, \sigma  \models  F
  }{
    S, \sigma  \not \models  \neg  F
  }
  \and 
  \inferrule *[right=And-True]{
    S, \sigma  \models  F_1 \\ S, \sigma  \models  F_2
  }{
    S, \sigma  \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=And-False]{
    S, \sigma  \not \models  F_1 \lor  S, \sigma  \not \models  F_2
  }{
    S, \sigma  \not \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=Or-True]{
    S, \sigma  \models  F_1 \lor  S, \sigma  \models  F_2
  }{
    S, \sigma  \models  F_1 \lor  F_2 
  }
  \and 
  \inferrule *[right=Or-False]{
    S, \sigma  \not \models  F_1 \\ S, \sigma  \not \models  F_2
  }{
    S, \sigma  \not \models  F_1 \lor  F_2
  }
  \and 
  \inferrule *[right=Imp-True]{
    S, \sigma  \not \models  F_1 \lor  S, \sigma  \models  F_2
  }{
    S, \sigma  \models  F_1 \to  F_2
  }
  \and 
  \inferrule *[right=Imp-False]{
    S, \sigma  \models  F_1 \\ S, \sigma  \not \models  F_2
  }{
    S, \sigma  \not \models  F_1 \to  F_2
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>For the proof rules of quantifiers we have two variants depending on whether we are dealing with free or bound variables:</html:p>
  
    
    <fr:resource hash="e31d38f49dbceb637264aba1c17cc280"><fr:resource-content><html:img src="/notes/e31d38f49dbceb637264aba1c17cc280.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=$\forall $-$\top $]{
    S, \sigma  \models  x.\ F \\ \forall  d \in  D
  }{
    S, \sigma [x \mapsto  d] \models  \forall  F
  }
  \and 
  \inferrule *[right=$\forall $-$\bot $]{
    S, \sigma  \not \models  \exists  x.\ F \\ \exists  d \in  D
  }{
    S, \sigma [x \mapsto  d] \not \models  F
  }
  \and 
  \inferrule *[right=$\exists $-$\top $]{
    S, \sigma  \models  \exists  x.\ F \\ \exists  d \in  D
  }{
    S, \sigma [x \mapsto  d] \models  F
  }
  \and 
  \inferrule *[right=$\exists $-$\bot $]{
    S, \sigma  \not \models  \exists  x.\ F \\ \forall  d \in  D
  }{
    S, \sigma [x \mapsto  d] \not \models  F
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0018/</fr:uri>
                        <fr:display-uri>0018</fr:display-uri>
                        <fr:route>/notes/0018/</fr:route>
                        <fr:title text="Semantic Argument method (FOL)">Semantic Argument method (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  In first order logic, the <html:em>semantic argument method</html:em> represents a proof by contradiction. The basic idea is as follows:
</html:p><html:ol><html:li>
    We assume that our formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is not valid, i.e., <fr:tex display="inline"><![CDATA[\exists  S, \sigma  \nvDash  F]]></fr:tex></html:li>
  <html:li>
    Use the proof rules to derive a contradiction from this assumption.
  </html:li>
  <html:li>
    If we can indeed derive a contradiction, we conclude that our initial assumption was false, and therefore <fr:tex display="inline"><![CDATA[F]]></fr:tex> must be valid.
  </html:li></html:ol><html:p>
  We can express the semantic argument method via the following inference rule:
</html:p>
  
    
    <fr:resource hash="2454f17b7350a6508743934c93b962c3"><fr:resource-content><html:img src="/notes/2454f17b7350a6508743934c93b962c3.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Contradiction]{
    S, \sigma  \models  p(s_1, \ldots , s_n) \\
    S, \sigma  \models  \neg  p(t_1, \ldots , t_n) \\
    \langle  I, \sigma \rangle  (t_1) = \langle  I, \sigma \rangle  (s_1), \ldots , \langle  I, \sigma \rangle  (t_n) = \langle  I, \sigma \rangle  (s_n)
  }{
    S, \sigma  \models  \bot 
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
  So the idea here being that if we have a predicate and its negation both holding under the same interpretation and variable assignment, we can derive a contradiction. This allows us to conclude that our initial assumption (that the formula is not valid) must be false, thereby proving the validity of the formula.
</html:p></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0019/</fr:uri>
                        <fr:display-uri>0019</fr:display-uri>
                        <fr:route>/notes/0019/</fr:route>
                        <fr:title text="Semantic Argument method (FOL)">Semantic Argument method (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following formula:</html:p><fr:tex display="block"><![CDATA[
  F \triangleq  (\forall  x.\ p(x)) \to  (\forall  y.\ p(y))
]]></fr:tex><html:p>Using the semantic argument method, determine whether the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is valid.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  We begin by assuming that <fr:tex display="inline"><![CDATA[\exists  S, \sigma  \nvDash  F]]></fr:tex>
  <fr:tex display="block"><![CDATA[
    \begin {align*}
      & S, \sigma  \nvDash  (\forall  x.\ p(x)) \to  (\forall  y.\ p(y)) \\
      & \therefore  S, \sigma  \models  \forall  x.\ p(x) \land  S, \sigma  \nvDash  \forall  y.\ p(y) \\ 
      & \therefore  S, \sigma  \models  \forall  x.\ p(x) \land  S, \sigma  \models  \neg  \forall  y.\ p(y) \\ 
    \end {align*} 
  ]]></fr:tex>
  Since we have <fr:tex display="inline"><![CDATA[p]]></fr:tex> and its negation both holding under the same interpretation and variable assignment, we can derive a contradiction using the Contradiction rule from the semantic argument method. Therefore, our initial assumption that <fr:tex display="inline"><![CDATA[F]]></fr:tex> is not valid must be false. Hence, we conclude that the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is valid.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/0032/</fr:uri>
                <fr:display-uri>0032</fr:display-uri>
                <fr:route>/notes/0032/</fr:route>
                <fr:title text="Lecture 4 - First Order Theories">Lecture 4 - First Order Theories</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Signatures and Axioms">Signatures and Axioms</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0033/</fr:uri>
                        <fr:display-uri>0033</fr:display-uri>
                        <fr:route>/notes/0033/</fr:route>
                        <fr:title text="First Order Theory T">First Order Theory <fr:tex display="inline"><![CDATA[T]]></fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  A <html:em>first order theory</html:em> (FOT) <fr:tex display="inline"><![CDATA[T]]></fr:tex> is defined by two main components:
</html:p>
                        <html:ul><html:li>
    A <html:em>signature</html:em> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> of a set of constant, function, and predicate symbols
  </html:li>
  <html:li>
    A set of <html:em>axioms</html:em> <fr:tex display="inline"><![CDATA[\mathcal  A]]></fr:tex> consisting of closed (i.e. no free variables) formulas over the signature <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex></html:li></html:ul>
                        <html:p>
  We say that a formula constructed from only from the contents of the signature <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>-formula.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0034/</fr:uri>
                        <fr:display-uri>0034</fr:display-uri>
                        <fr:route>/notes/0034/</fr:route>
                        <fr:title text="Signatures and Axioms (FOL)">Signatures and Axioms (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider a theory withthe following signature:</html:p><fr:tex display="block"><![CDATA[
  \Sigma _H  : \{R = \{\texttt {taller}\}, C = F = \emptyset  \}
]]></fr:tex><html:p>And the axiom:</html:p><fr:tex display="block"><![CDATA[
  \forall  x.\ \forall  y.\ (\texttt {taller}(x, y) \to  \neg  \texttt {taller}(y, x))
]]></fr:tex><html:p>Are the following legal <fr:tex display="inline"><![CDATA[\Sigma _H]]></fr:tex>-formulas?</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[
      \exists  x.\ \forall  y.\ (\texttt {taller}(x, z) \land  \texttt {taller}(y, w))
    ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[
    \exists  x.\ \forall  z.\ \texttt {taller}(x, z) \land  \texttt {taller}(\text {joe}, \text {tom})
  ]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Yes</html:li>
    <html:li>No, there are no constants in the signature, so \text {joe} and \text {tom} are not valid terms.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Models of Theories">Models of Theories</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0035/</fr:uri>
                        <fr:display-uri>0035</fr:display-uri>
                        <fr:route>/notes/0035/</fr:route>
                        <fr:title text="Structure &amp; Model of T (FOT)">Structure &amp; Model of <fr:tex display="inline"><![CDATA[T]]></fr:tex> (FOT)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A structure which we denote as:</html:p>
                        <fr:tex display="block"><![CDATA[
  M \triangleq  \langle  U, I \rangle 
]]></fr:tex>
                        <html:p>Is a <html:strong>model of a theory</html:strong> <fr:tex display="inline"><![CDATA[T]]></fr:tex> (or <fr:tex display="inline"><![CDATA[T]]></fr:tex>-<html:strong>model</html:strong>) iff:</html:p>
                        <fr:tex display="block"><![CDATA[
  \forall  A \in  \mathcal  A_T.\ M \vDash  A
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0036/</fr:uri>
                        <fr:display-uri>0036</fr:display-uri>
                        <fr:route>/notes/0036/</fr:route>
                        <fr:title text="Models of T_H">Models of <fr:tex display="inline"><![CDATA[T_H]]></fr:tex></fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>consider a structure consisting of a universe <fr:tex display="inline"><![CDATA[U]]></fr:tex> and interpretation <fr:tex display="inline"><![CDATA[I]]></fr:tex> as follows:</html:p><fr:tex display="block"><![CDATA[
  U = \{A, B\} \quad  I = \{\texttt {taller} \mapsto  \{\langle  A, A\rangle , \langle  B, B\rangle \}\}
]]></fr:tex><html:p>Are the following models of the theory <fr:tex display="inline"><![CDATA[T]]></fr:tex> or not:</html:p><html:ol><html:li>Is <fr:tex display="inline"><![CDATA[\langle  U, I\rangle ]]></fr:tex> a model of <fr:tex display="inline"><![CDATA[T]]></fr:tex></html:li>
  <html:li>If we change the interpretation to
    <fr:tex display="block"><![CDATA[
      I = \{\texttt {taller} \mapsto  \{\langle  A, B\rangle \}\}
    ]]></fr:tex>
    is the structure now a model of <fr:tex display="inline"><![CDATA[T]]></fr:tex>?
  </html:li>
  <html:li>If we add the following axiom
    <fr:tex display="block"><![CDATA[
      \forall  x, y, z.\ (\texttt {taller}(x, y) \land  \texttt {taller}(y, z) \to  \texttt {taller}(x, z))
    ]]></fr:tex>
    and we change the interpretation to
    <fr:tex display="block"><![CDATA[
      I = \{\texttt {taller} \mapsto  \{\langle  A, B \rangle , \langle  B, C \rangle \}\}
    ]]></fr:tex>
    then is the structure a model of <fr:tex display="inline"><![CDATA[T]]></fr:tex>?
  </html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>As a reminder we are working with the axiom:</html:p>
  <fr:tex display="block"><![CDATA[
    \forall  x, y.\ (\texttt {taller}(x, y) \to  \neg  \texttt {taller}(y, x))
  ]]></fr:tex>
  <html:ol><html:li>Clearly no, as if we take <fr:tex display="inline"><![CDATA[x = A]]></fr:tex> and <fr:tex display="inline"><![CDATA[y = A]]></fr:tex> we have that both <fr:tex display="inline"><![CDATA[\texttt {taller}(A, A)]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {taller}(A, A)]]></fr:tex> hold, violating the axiom.</html:li>
    <html:li>Here we are chaning or interpretation to just the relation <fr:tex display="inline"><![CDATA[\texttt {taller}(A, B)]]></fr:tex> holding. In this case the axiom is satisfied as there are no values of <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> such that both <fr:tex display="inline"><![CDATA[\texttt {taller}(x, y)]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {taller}(y, x)]]></fr:tex> hold. So yes this is a model of <fr:tex display="inline"><![CDATA[T]]></fr:tex>.</html:li>
    <html:li>No, as if we take <fr:tex display="inline"><![CDATA[x = A]]></fr:tex>, <fr:tex display="inline"><![CDATA[y = B]]></fr:tex> and <fr:tex display="inline"><![CDATA[z = C]]></fr:tex> we have that both <fr:tex display="inline"><![CDATA[\texttt {taller}(A, B)]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {taller}(B, C)]]></fr:tex> hold, but <fr:tex display="inline"><![CDATA[\texttt {taller}(A, C)]]></fr:tex> does not hold (so not in our interpretation for the <fr:tex display="inline"><![CDATA[\texttt {taller}]]></fr:tex> relationship), violating the axiom.
    </html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Satisfiability Modulo T">Satisfiability Modulo <fr:tex display="inline"><![CDATA[T]]></fr:tex></fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0037/</fr:uri>
                        <fr:display-uri>0037</fr:display-uri>
                        <fr:route>/notes/0037/</fr:route>
                        <fr:title text="Satisfiable &amp; Valid modulo T">Satisfiable &amp; Valid modulo <fr:tex display="inline"><![CDATA[T]]></fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We say that a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is <html:strong>satisfiable modulo</html:strong> <fr:tex display="inline"><![CDATA[T]]></fr:tex> iff <html:em>there exists</html:em> a <fr:tex display="inline"><![CDATA[T]]></fr:tex>-model <fr:tex display="inline"><![CDATA[M]]></fr:tex> and a variable assignment <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> such that:</html:p>
                        <fr:tex display="block"><![CDATA[
  M, \sigma  \vDash  F
]]></fr:tex>
                        <html:p>We say that a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is <html:strong>valid modulo</html:strong> <fr:tex display="inline"><![CDATA[T]]></fr:tex> iff <html:em>forall</html:em> <fr:tex display="inline"><![CDATA[T]]></fr:tex>-models <fr:tex display="inline"><![CDATA[M]]></fr:tex> and all variable assignments <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> we have:</html:p>
                        <fr:tex display="block"><![CDATA[
  M, \sigma  \vDash  F
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0039/</fr:uri>
                        <fr:display-uri>0039</fr:display-uri>
                        <fr:route>/notes/0039/</fr:route>
                        <fr:title text="FOL Validity vs Valid modulo T">FOL Validity vs Valid modulo <fr:tex display="inline"><![CDATA[T]]></fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>We can compare the two notions by understanding <html:em>validity in modulo</html:em> <fr:tex display="inline"><![CDATA[T]]></fr:tex> as a restriction of <html:em>validity in FOL</html:em> to only those models that are <fr:tex display="inline"><![CDATA[T]]></fr:tex>-models. So the implication of that is that if a formula is valid (true in all models), then its clearly also valid in the subset/restriction to only <fr:tex display="inline"><![CDATA[T]]></fr:tex>-models. However, the other way around does not hold, since a formula can be true in all <fr:tex display="inline"><![CDATA[T]]></fr:tex>-models, but false in some non-<fr:tex display="inline"><![CDATA[T]]></fr:tex>-model. Hence we have the following:</html:p>
 
  
  <fr:resource hash="e17a21d7370f74a45bdb962c07a32b9d"><fr:resource-content><html:img src="/notes/e17a21d7370f74a45bdb962c07a32b9d.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\[
  \vDash  F \implies  T \vDash  F  
\]]]></fr:resource-source></fr:resource>
 
<html:p>But the other way around does not hold in general:</html:p>
 
  
  <fr:resource hash="8bedd6a874fded6390949fd57cbf0d41"><fr:resource-content><html:img src="/notes/8bedd6a874fded6390949fd57cbf0d41.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\[
  T \vDash  F \centernot \implies  \vDash  F
\]]]></fr:resource-source></fr:resource>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0038/</fr:uri>
                        <fr:display-uri>0038</fr:display-uri>
                        <fr:route>/notes/0038/</fr:route>
                        <fr:title text="Satisfiability in FOL vs FOT">Satisfiability in FOL vs FOT</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider some arbitrary first order theory <fr:tex display="inline"><![CDATA[T]]></fr:tex></html:p><html:ol><html:li>If a formula is valid in FOL, then is it also valid in modulo <fr:tex display="inline"><![CDATA[T]]></fr:tex>?</html:li>
  <html:li>If a formula is valid modulo <fr:tex display="inline"><![CDATA[T]]></fr:tex>, then is it also valid in FOL?</html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Yes, if its valid in FOL that means its valid in <html:em>all models</html:em> which includes those models that are <fr:tex display="inline"><![CDATA[T]]></fr:tex>-models. Hence its also valid modulo <fr:tex display="inline"><![CDATA[T]]></fr:tex>.</html:li>
    <html:li>No, a formula can be valid in all <fr:tex display="inline"><![CDATA[T]]></fr:tex>-models, but false in some non-<fr:tex display="inline"><![CDATA[T]]></fr:tex>-model. Hence its not necessarily valid in FOL.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Theory of Equality &amp; Congruence">Theory of Equality &amp; Congruence</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003a/</fr:uri>
                        <fr:display-uri>003a</fr:display-uri>
                        <fr:route>/notes/003a/</fr:route>
                        <fr:title text="Theory of Equality T">Theory of Equality <fr:tex display="inline"><![CDATA[T]]></fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The <html:strong>theory of equality</html:strong> <fr:tex display="inline"><![CDATA[T_=]]></fr:tex> is a first order theory over the signature <fr:tex display="inline"><![CDATA[\Sigma _=]]></fr:tex> which contains:</html:p>
                        <fr:tex display="block"><![CDATA[
  \sigma _= : \{=, s\}
]]></fr:tex>
                        <html:p>Where <fr:tex display="inline"><![CDATA[=]]></fr:tex> is a binary relation symbol and <fr:tex display="inline"><![CDATA[s]]></fr:tex> is any constant function or predicate symbol. The axioms of the theory of equality are:</html:p>
                        <fr:resource hash="91ec0848d003ec436b77f543939afd31">
                          <fr:resource-content>
                            <html:img src="/notes/91ec0848d003ec436b77f543939afd31.svg" />
                          </fr:resource-content>
                          <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {eulervm}
  \usepackage {amsmath}
]]></fr:resource-source>
                          <fr:resource-source type="latex" part="body"><![CDATA[
    \begin{align*}
    &\forall x.\ x = x \tag{reflexivity} \\
    &\forall x, y.\ x = y \to y = x \tag{symmetry} \\
    &\forall x, y, z.\ (x = y \land y = z) \to x = z \tag{transitivity} \\
  \end{align*}
]]></fr:resource-source>
                        </fr:resource>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003b/</fr:uri>
                        <fr:display-uri>003b</fr:display-uri>
                        <fr:route>/notes/003b/</fr:route>
                        <fr:title text="Theory of Equality">Theory of Equality</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the universe:</html:p><fr:tex display="block"><![CDATA[
  U = \{\alpha , \beta \}
]]></fr:tex><html:p>which of the following interpetations of <fr:tex display="inline"><![CDATA[=]]></fr:tex> are allowd by the axioms of <fr:tex display="inline"><![CDATA[T_=]]></fr:tex>:</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[I(=) \triangleq  \{\langle  \alpha , \beta  \rangle , \langle  \beta  \alpha  \rangle \}]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[I(=) \triangleq  \{\langle  \alpha , \alpha  \rangle , \langle  \beta , \beta  \rangle \}]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[I(=) \triangleq  \{\langle  \alpha , \alpha  \rangle , \langle  \alpha , \beta  \rangle , \langle  \beta , \alpha  \rangle , \langle  \beta , \beta  \rangle \}]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>No, violates reflexivity axiom since neither <fr:tex display="inline"><![CDATA[\alpha  = \alpha ]]></fr:tex> nor <fr:tex display="inline"><![CDATA[\beta  = \beta ]]></fr:tex> are in the interpretation</html:li>
    <html:li>Yes, satisfies all axioms of equality</html:li>
    <html:li>Yes, satisfies all axioms of equality</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003c/</fr:uri>
                        <fr:display-uri>003c</fr:display-uri>
                        <fr:route>/notes/003c/</fr:route>
                        <fr:title text="(Left &amp; Right) Congruence Relations (FOT)">(Left &amp; Right) Congruence Relations (FOT)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In the most general sense we say that a relation <fr:tex display="inline"><![CDATA[R]]></fr:tex> over a set <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a <html:strong>congruence</html:strong> with respect to a function <fr:tex display="inline"><![CDATA[f : A^n \to  A]]></fr:tex> if for all <fr:tex display="inline"><![CDATA[a_1, \ldots , a_n, b_1, \ldots , b_n \in  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a_i\ R\ b_i]]></fr:tex> for all <fr:tex display="inline"><![CDATA[1 \leq  i \leq  n]]></fr:tex> we have:</html:p>
                        <fr:tex display="block"><![CDATA[
  f(a_1, \ldots , a_n)\ R\ f(b_1, \ldots , b_n)
]]></fr:tex>
                        <html:p>if we denote <fr:tex display="inline"><![CDATA[\overline  x]]></fr:tex> as a vector of elements <fr:tex display="inline"><![CDATA[x_1, \ldots , x_n]]></fr:tex> we can rewrite this more succinctly as:</html:p>
                        <fr:tex display="block"><![CDATA[
  \forall  \overline  a, \overline  b \in  A^n.\ (\forall  i.\ a_i\ R\ b_i) \to  f(\overline  a)\ R\ f(\overline  b)
]]></fr:tex>
                        <html:p>In the case of first order theories we can then instantiate <fr:tex display="inline"><![CDATA[R]]></fr:tex> with things like equality or other relations defined in the theory. Additionally we can <fr:tex display="inline"><![CDATA[f]]></fr:tex> represent a function or predicate symbol from the signature of the theory. In the case of binary functions or predicates we can also define <html:strong>left</html:strong> and <html:strong>right congruence</html:strong> as follows:</html:p>
                        <html:ol><html:li>A relation <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a <html:strong>left congruence</html:strong> with respect to a binary function or predicate <fr:tex display="inline"><![CDATA[f : A \times  A \to  A]]></fr:tex> if for all <fr:tex display="inline"><![CDATA[a, b, c \in  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a\ R\ b]]></fr:tex> we have:</html:li>
  <fr:tex display="block"><![CDATA[
    f(a, c)\ R\ f(b, c)
  ]]></fr:tex>
  <html:li>A relation <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a <html:strong>right congruence</html:strong> with respect to a binary function or predicate <fr:tex display="inline"><![CDATA[f : A \times  A \to  A]]></fr:tex> if for all <fr:tex display="inline"><![CDATA[a, b, c \in  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a\ R\ b]]></fr:tex> we have:</html:li>
  <fr:tex display="block"><![CDATA[
    f(c, a)\ R\ f(c, b)
  ]]></fr:tex></html:ol>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003d/</fr:uri>
                        <fr:display-uri>003d</fr:display-uri>
                        <fr:route>/notes/003d/</fr:route>
                        <fr:title text="Function &amp; Predicate congruence">Function &amp; Predicate congruence</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  Consider the universe:
</html:p><fr:tex display="block"><![CDATA[
  U = \{a, b, c\}
]]></fr:tex><html:p>
  and the interpretation:
</html:p><fr:tex display="block"><![CDATA[
  I(=) \triangleq  \{\langle  a, a \rangle , \langle  a, b \rangle , \langle  b, a \rangle , \langle  b, b \rangle , \langle  c, c \rangle \}
]]></fr:tex><html:ol><html:li>
    Does the interpetation <fr:tex display="inline"><![CDATA[I(=)]]></fr:tex> satisfy the axioms of equality?
  </html:li>
  <html:li>
    Which interpretations for a function <fr:tex display="inline"><![CDATA[f]]></fr:tex> satisfy the axioms of congruence?
    <html:ol><html:li><fr:tex display="inline"><![CDATA[I(f) \triangleq  \{b \to  a, a \to  c, c \to  c\}]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[I(f) \triangleq  \{b \to  b, a \to  b, c \to  b\}]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[I(f) \triangleq  \{b \to  a, a \to  b, c \to  c\}]]></fr:tex></html:li></html:ol></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>
      Yes, the interpretation satisfies the axioms of equality
    </html:li>
    <html:li>
      Going through them one by one:
      <html:ol><html:li>
          No, because <fr:tex display="inline"><![CDATA[f(a) = c]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(b) = a]]></fr:tex> but <fr:tex display="inline"><![CDATA[a\ I(=)\ b]]></fr:tex> yet <fr:tex display="inline"><![CDATA[c\ not\ I(=)\ a]]></fr:tex></html:li>
        <html:li>
          Yes, because <fr:tex display="inline"><![CDATA[f(a) = b]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(b) = b]]></fr:tex> and <fr:tex display="inline"><![CDATA[a\ I(=)\ b]]></fr:tex> thus <fr:tex display="inline"><![CDATA[b\ I(=)\ b]]></fr:tex>, similarly for <fr:tex display="inline"><![CDATA[c]]></fr:tex></html:li>
        <html:li>
          Yes, because <fr:tex display="inline"><![CDATA[f(a) = b]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(b) = a]]></fr:tex> and <fr:tex display="inline"><![CDATA[a\ I(=)\ b]]></fr:tex> thus <fr:tex display="inline"><![CDATA[b\ I(=)\ a]]></fr:tex>, similarly for <fr:tex display="inline"><![CDATA[c]]></fr:tex></html:li></html:ol></html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Theory of Peano Arithmetic">Theory of Peano Arithmetic</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003e/</fr:uri>
                        <fr:display-uri>003e</fr:display-uri>
                        <fr:route>/notes/003e/</fr:route>
                        <fr:title text="Theory of Peano Arithmetic">Theory of Peano Arithmetic</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Peano Arithmetic (PA) is a first order theory over the signature <fr:tex display="inline"><![CDATA[\Sigma _{PA}]]></fr:tex> which contains:
</html:p>
                        <fr:tex display="block"><![CDATA[
  \Sigma _{PA} : \{0, S, +, \times , =\}
]]></fr:tex>
                        <html:p>
  Where <fr:tex display="inline"><![CDATA[0]]></fr:tex> is a constant symbol representing zero, <fr:tex display="inline"><![CDATA[S]]></fr:tex> is a unary function symbol representing the successor function, <fr:tex display="inline"><![CDATA[+]]></fr:tex> and <fr:tex display="inline"><![CDATA[\times ]]></fr:tex> are binary function symbols representing addition and multiplication respectively, and <fr:tex display="inline"><![CDATA[=]]></fr:tex> is a binary relation symbol representing equality. The axioms of Peano Arithmetic are:
</html:p>
                        <fr:resource hash="38b17d08c8a044cd82fc858e037bbf9f">
                          <fr:resource-content>
                            <html:img src="/notes/38b17d08c8a044cd82fc858e037bbf9f.svg" />
                          </fr:resource-content>
                          <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {eulervm}
  \usepackage {amsmath}
]]></fr:resource-source>
                          <fr:resource-source type="latex" part="body"><![CDATA[
    \begin{align*}
    &\forall x.\ S(x) \neq 0 \tag{zero} \\
    &\forall x, y.\ S(x) = S(y) \to x = y \tag{plus zero} \\
    &\forall x.\ x + 0 = x \tag{succ} \\
    &\forall x, y.\ x + S(y) = S(x + y) \tag{plus succ} \\
    &\forall x.\ x \times 0 = 0 \tag{times zero} \\
    &\forall x, y.\ x \times S(y) = (x \times y) + x \tag{times succ} \\
    &\forall P.\ (P(0) \land \forall x.\ (P(x) \to P(S(x)))) \to \forall x.\ P(x) \tag{induction}
  \end{align*}
]]></fr:resource-source>
                        </fr:resource>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003f/</fr:uri>
                        <fr:display-uri>003f</fr:display-uri>
                        <fr:route>/notes/003f/</fr:route>
                        <fr:title text="Theory of Peano Arithmetic">Theory of Peano Arithmetic</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Are the following well-formed <fr:tex display="inline"><![CDATA[T_{\text {PA}} formulae?]]></fr:tex></html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[x + y = 1 \land  f(x) = 1 + 1]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\forall  x.\ \exists  y.\ \exists  z.\ x + y = 1\land  z \times  x = 1 + 1]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[2x = y]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>No, the theory of Peano Arithmetic does not include function symbols like <fr:tex display="inline"><![CDATA[f]]></fr:tex>, nor does it include numerals like <fr:tex display="inline"><![CDATA[1]]></fr:tex> or <fr:tex display="inline"><![CDATA[2]]></fr:tex>. All terms must be constructed using the constant symbol <fr:tex display="inline"><![CDATA[0]]></fr:tex>, the successor function <fr:tex display="inline"><![CDATA[S]]></fr:tex>, and the function symbols <fr:tex display="inline"><![CDATA[+]]></fr:tex> and <fr:tex display="inline"><![CDATA[\times ]]></fr:tex>.</html:li>
    <html:li>Yes, this is a well-formed formula. It uses only the symbols and constructs allowed in the theory of Peano Arithmetic.</html:li>
    <html:li>No, this is not a well-formed formula. The expression <fr:tex display="inline"><![CDATA[2x]]></fr:tex> is not a valid term in Peano Arithmetic, as numerals like <fr:tex display="inline"><![CDATA[2]]></fr:tex> are not part of the language. Terms must be built using <fr:tex display="inline"><![CDATA[0]]></fr:tex>, <fr:tex display="inline"><![CDATA[S]]></fr:tex>, <fr:tex display="inline"><![CDATA[+]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\times ]]></fr:tex>. A valid way to express the same idea would be <fr:tex display="inline"><![CDATA[S(S(0)) \times  x = y]]></fr:tex>. Or if we replace <fr:tex display="inline"><![CDATA[S]]></fr:tex> with <fr:tex display="inline"><![CDATA[1]]></fr:tex> then we could do <fr:tex display="inline"><![CDATA[(1 + 1) \times  x = y]]></fr:tex></html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Theory of Rationals &amp; Integers">Theory of Rationals &amp; Integers</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003i/</fr:uri>
                        <fr:display-uri>003i</fr:display-uri>
                        <fr:route>/notes/003i/</fr:route>
                        <fr:title text="Theory of Rationals T_{\mathbb {Q}}">Theory of Rationals <fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The theory of rationals <fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex> is a first-order theory over the signature <fr:tex display="inline"><![CDATA[\Sigma _{\mathbb {Q}}]]></fr:tex> which contains:</html:p>
                        <fr:tex display="block"><![CDATA[
  \Sigma _{\mathbb {Q}} : \{0, 1, +, -, =, \geq \}
]]></fr:tex>
                        <html:p>(Axioms ommitted for brevity.)</html:p>
                        <html:p>Some important properties of <fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex> are:</html:p>
                        <html:ul><html:li>Full theory is <html:em>decidable</html:em> but doubly exponential.</html:li>
  <html:li>Conjunctive quantifier-free fragment is efficiently decidable (polynomial time).</html:li>
  <html:li><fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex> is the basis for arithemtic reasoning in SMT solvers such as Z3.</html:li>
  <html:li>In practice the <html:em>simplex</html:em> algorithm is used.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003h/</fr:uri>
                        <fr:display-uri>003h</fr:display-uri>
                        <fr:route>/notes/003h/</fr:route>
                        <fr:title text="Theory of Presburger Arithmetic">Theory of Presburger Arithmetic</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Presburger Arithmetic (PA) is a first order theory over the signature <fr:tex display="inline"><![CDATA[\Sigma _{\mathbb {N}}]]></fr:tex> which contains:
</html:p>
                        <fr:tex display="block"><![CDATA[
  \Sigma _{\mathbb {N}} : \{0, 1, +, =\}
]]></fr:tex>
                        <html:p>
  Where <fr:tex display="inline"><![CDATA[0]]></fr:tex> and <fr:tex display="inline"><![CDATA[1]]></fr:tex> are constant symbols representing zero and one respectively, <fr:tex display="inline"><![CDATA[+]]></fr:tex> is a binary function symbol representing addition, and <fr:tex display="inline"><![CDATA[=]]></fr:tex> is a binary relation symbol representing equality. The axioms of Presburger Arithmetic are:
</html:p>
                        <fr:resource hash="b2cd095d79c0e49ba09ee38205cc6cdc">
                          <fr:resource-content>
                            <html:img src="/notes/b2cd095d79c0e49ba09ee38205cc6cdc.svg" />
                          </fr:resource-content>
                          <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {eulervm}
  \usepackage {amsmath}
]]></fr:resource-source>
                          <fr:resource-source type="latex" part="body"><![CDATA[
    \begin{align*}
    &\forall x.\ \neg(x + 1 = 0) \tag{zero} \\
    &\forall x.\ x + 0 = x \tag{plus zero} \\
    &\forall x, y.\ x + 1 = y + 1 \to x = y \tag{plus one} \\
    &\forall x.\ P(0) \land \forall x.\ (P(x) \to P(x + 1)) \to \forall x.\ P(x) \tag{induction}
  \end{align*}
]]></fr:resource-source>
                        </fr:resource>
                        <html:p>
  Some important properties of <fr:tex display="inline"><![CDATA[T_{\mathbb {N}} are]]></fr:tex>:
</html:p>
                        <html:ul><html:li>
    Validity in <html:em>quantifer-free</html:em> Presburger Arithmetic is decidable.
  </html:li>
  <html:li>
    Validity in <html:em>full</html:em> Presburger Arithmetic is decidable.
  </html:li>
  <html:li>
    Validity in Presburger Arithmetic has a super exponential complexity <fr:tex display="inline"><![CDATA[O(2^{2^n})]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[T_{\mathbb {N}}]]></fr:tex> is <html:em>complete</html:em>, i.e.
    <fr:tex display="block"><![CDATA[
      \forall  F.\ T_{\mathbb {N}} \models  F \lor  T_{\mathbb {N}} \models  \neg  F
    ]]></fr:tex></html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003k/</fr:uri>
                        <fr:display-uri>003k</fr:display-uri>
                        <fr:route>/notes/003k/</fr:route>
                        <fr:title text="Theory of rationals T_{\mathbb {Q}}">Theory of rationals <fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex></fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following formula:</html:p><fr:tex display="block"><![CDATA[
  \exists  x.\ (1 + 1) x = 1 + 1 + 1
]]></fr:tex><html:ol><html:li>Is this formula valid in <fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex></html:li>
  <html:li>Is this formula valid in <fr:tex display="inline"><![CDATA[T_{\mathbb {Z}}]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Yes, this formula is valid in <fr:tex display="inline"><![CDATA[T_{\mathbb {Q}}]]></fr:tex>. In the theory of rationals, we can find a rational number <fr:tex display="inline"><![CDATA[x = \frac {3}{2}]]></fr:tex> that satisfies the equation <fr:tex display="inline"><![CDATA[(1 + 1) x = 1 + 1 + 1]]></fr:tex>. Therefore, there exists an <fr:tex display="inline"><![CDATA[x]]></fr:tex> in the rationals that makes the equation true.</html:li>
    <html:li>No, this formula is not valid in <fr:tex display="inline"><![CDATA[T_{\mathbb {Z}}]]></fr:tex>. In the theory of integers, there is no integer <fr:tex display="inline"><![CDATA[x]]></fr:tex> that satisfies the equation <fr:tex display="inline"><![CDATA[(1 + 1) x = 1 + 1 + 1]]></fr:tex>, since <fr:tex display="inline"><![CDATA[\frac {3}{2}]]></fr:tex> is not an integer. Thus, there does not exist an integer <fr:tex display="inline"><![CDATA[x]]></fr:tex> that makes the equation true.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Theory of Data structures">Theory of Data structures</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003l/</fr:uri>
                        <fr:display-uri>003l</fr:display-uri>
                        <fr:route>/notes/003l/</fr:route>
                        <fr:title text="Theory of Arrays T_{A}">Theory of Arrays <fr:tex display="inline"><![CDATA[T_{A}]]></fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  The theory of arrays is a first-order theory that models arrays as functions from indices to values. It's signature includes:
</html:p>
                        <fr:tex display="block"><![CDATA[
  \Sigma _A \triangleq  \{- [ - ], \langle  - \triangleleft  - \rangle , =\}
]]></fr:tex>
                        <html:p>
  where:
</html:p>
                        <html:ul><html:li><fr:tex display="inline"><![CDATA[-[ - ]]]></fr:tex>: read operation, which takes an array and an index and returns the value at that index.
  </html:li>
  <html:li><fr:tex display="inline"><![CDATA[\langle  - \triangleleft  - \rangle ]]></fr:tex>: write operation, which takes an array, an index, and a
    value, and returns a new array with the value at the specified index updated.
  </html:li>
  <html:li><fr:tex display="inline"><![CDATA[=]]></fr:tex>: equality relation, which checks if two arrays are identical.
  </html:li></html:ul>
                        <html:p>
  The axioms of the theory of arrays are:
</html:p>
                        <fr:resource hash="8ff9653ef4ba489edcda34b8856e7a7b">
                          <fr:resource-content>
                            <html:img src="/notes/8ff9653ef4ba489edcda34b8856e7a7b.svg" />
                          </fr:resource-content>
                          <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {eulervm}
  \usepackage {amsmath}
]]></fr:resource-source>
                          <fr:resource-source type="latex" part="body"><![CDATA[
    \begin{align*}
    \forall a, i, v.\; [a \langle i \triangleleft v \rangle][i] &= v \quad \tag{Read-Over-Write 1} \\
    \forall a, i, j, v.\; i \neq j \implies [a \langle i \triangleleft v \rangle][j] &= a[j] \quad \tag{Read-Over-Write 2} \\
    \forall a, b.\; (\forall i.\; a[i] = b[i]) &\implies a = b \quad \tag{Extensionality}
  \end{align*}
]]></fr:resource-source>
                        </fr:resource>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>2</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003m/</fr:uri>
                        <fr:display-uri>003m</fr:display-uri>
                        <fr:route>/notes/003m/</fr:route>
                        <fr:title text="Theory of arrays T_A">Theory of arrays <fr:tex display="inline"><![CDATA[T_A]]></fr:tex></fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  Which of the following formula is valid/satisfiable/unsatisfiable ?
</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[a[3] = 2]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[a \langle  3 \triangleleft  5 \rangle [3] = 5]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[a \langle  3 \triangleleft  5 \rangle [3] = 3]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[a[3] = 2\land  a \langle  3 \triangleleft  5 \rangle [3] = 5]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>This formula is <html:strong>satisfiable</html:strong>. For example, if we have an array <fr:tex display="inline"><![CDATA[a]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a[3] = 2]]></fr:tex>, then the formula holds true.</html:li>
    <html:li>This formula is <html:strong>valid</html:strong>. According to the Read-Over-Write axiom, when we write a value to an index in an array and then read from that same index, we get the value we just wrote. So regardless of the initial contents of array <fr:tex display="inline"><![CDATA[a]]></fr:tex>, after performing the write operation <fr:tex display="inline"><![CDATA[a \langle  3 \triangleleft  5 \rangle ]]></fr:tex>, reading from index <fr:tex display="inline"><![CDATA[3]]></fr:tex> will always yield <fr:tex display="inline"><![CDATA[5]]></fr:tex> hence making it always true (valid).</html:li>
    <html:li>This formula is <html:strong>unsatisfiable</html:strong>. According to the Read-Over-Write axiom, when we write a value to an index in an array and then read from that same index, we get the value we just wrote. Therefore, after performing the write operation <fr:tex display="inline"><![CDATA[a \langle  3 \triangleleft  5 \rangle ]]></fr:tex>, reading from index <fr:tex display="inline"><![CDATA[3]]></fr:tex> will always yield <fr:tex display="inline"><![CDATA[5]]></fr:tex>, making it impossible for it to equal <fr:tex display="inline"><![CDATA[3]]></fr:tex>.</html:li>
    <html:li>This formula is <html:strong>satisfiable</html:strong>. For example, if we have an array <fr:tex display="inline"><![CDATA[a]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a[3] = 2]]></fr:tex>, then after performing the write operation <fr:tex display="inline"><![CDATA[a \langle  3 \triangleleft  5 \rangle ]]></fr:tex>, reading from index <fr:tex display="inline"><![CDATA[3]]></fr:tex> will yield <fr:tex display="inline"><![CDATA[5]]></fr:tex>. Thus, both parts of the conjunction can be true simultaneously though are not valid in all interpretations.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/003n/</fr:uri>
                <fr:display-uri>003n</fr:display-uri>
                <fr:route>/notes/003n/</fr:route>
                <fr:title text="Lecture 5 - Nano and Hoare Logic">Lecture 5 - Nano and Hoare Logic</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Semantics and Evaluation">Semantics and Evaluation</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>4</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003t/</fr:uri>
                        <fr:display-uri>003t</fr:display-uri>
                        <fr:route>/notes/003t/</fr:route>
                        <fr:title text="Simple Imperative Language - Syntax">Simple Imperative Language - Syntax</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>
  We define the syntax of a simple imperative programming language, using the followng bnf grammar:
</html:p>
  
    
    <fr:resource hash="d9358af54b1514c3e8ea6264dd0ad402"><fr:resource-content><html:img src="/notes/d9358af54b1514c3e8ea6264dd0ad402.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
      
    \usepackage{xcolor}               % color support
  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \definecolor{brown}{rgb}{0.921, 0.325, 0.078}
  \definecolor{lightline}{rgb}{0.8,0.8,0.8}

  \usepackage{libertine}
  \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  % \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig
  \usepackage{simplebnf}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {center}
        \begin {bnf}(
          prod-delim = {--},
          or-sym = {},
          prod-sep = 5pt,
        )[
          colspec = {llcll},
          column{1} = {font=\sffamily },
          column{2} = {mode=dmath},
          column{4} = {font=\ttfamily },
          column{5} = {font=\itshape \color {gray}},
        ]
          
      e : Exp ::=
    | n : number
    | x : variable
    | $e_1 + e_2$ : addition
    | $e_1 - e_2$ : subtraction
    | $e_1 * e_2$ : multiplication
    --
    b : BExp ::=
    | $\top$ : true
    | $\bot$ : false
    | $\neg b$ : negation
    | $b_1 \land b_2$ : conjunction
    | $b_1 \lor b_2$ : disjunction
    | $e_1 = e_2$ : equality
    | $e_1 \leq e_2$ : less than or equal
    --
    s : Stmt ::=
    | skip : skip
    | $x \coloneqq e$ : assignment
    | $s_1 ; s_2$ : sequencing
    | if $b$ then $s_1$ else $s_2$ : conditional
    | while $b$ do $s$ : while loop

        \end {bnf}
      \end {center}
    ]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>4</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003u/</fr:uri>
                        <fr:display-uri>003u</fr:display-uri>
                        <fr:route>/notes/003u/</fr:route>
                        <fr:title text="Simple Imperative Language - Semantics">Simple Imperative Language - Semantics</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  We can divide the environmental big-step semantics of our simple language into three parts:
</html:p>
                        <html:ul><html:li><html:strong>Expression evaluation</html:strong>: Describes how arithmetic expressions are evaluated to numbers.
  </html:li>
  <html:li><html:strong>Boolean expression evaluation</html:strong>: Describes how boolean expressions are evaluated to boolean values (true/false).
  </html:li>
  <html:li><html:strong>Statement execution</html:strong>: Describes how statements are executed, transforming an initial state (environment) into a final state.
  </html:li></html:ul>
                        <html:p>
  The general big-step environmental evalutation rule is denoted as:
</html:p>
                        <fr:tex display="block"><![CDATA[
  \langle  t, \sigma  \rangle  \Downarrow  v
]]></fr:tex>
                        <html:p>
  Here:
</html:p>
                        <html:ol><html:li>
    We have some starting term <fr:tex display="inline"><![CDATA[\texttt {t}]]></fr:tex> (which can be an expression, boolean expression, or statement), along with some state <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>.
  </html:li>
  <html:li>
    The evaluation results in some value <fr:tex display="inline"><![CDATA[\texttt {v}]]></fr:tex> (which can be a number, boolean value, or new state).
  </html:li></html:ol>
                        <html:p>
  A quick aside here to deconstruct the term <html:strong>big-step environmental evaluation</html:strong>:
</html:p>
                        <html:ul><html:li>
    We say that this evaluation is <html:strong>big-step</html:strong> as it assumes some arbitrary state of intermediate steps, meaning that within big step semantics we do not care about intermediate computation only about some input expression and the final output value. A simple analogue to make here is that big-step semantics are akin to a teacher asking you to only show ur final answer to a math problem rather than all the steps you took to get there.
  </html:li>
  <html:li>
    We say that this evaluation is <html:strong>environmental</html:strong> (as opposed to being substitution based) as we explicitly keep track of a state <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> which maps variables to their values. This is in contrast to substitution based semantics where variable occurrences are replaced directly with their values in expressions.
  </html:li></html:ul>
                        <html:p>
  The state <fr:tex display="inline"><![CDATA[\sigma  : \texttt {String} \to  \mathbb {Z}]]></fr:tex> represents a mapping from variables (commonly strings) to their corresponding values (numbers). We denote the updated state after assigning a value to a variable <fr:tex display="inline"><![CDATA[\texttt {x}]]></fr:tex> as:
</html:p>
                        <fr:tex display="block"><![CDATA[
  \sigma [x \mapsto  n]
]]></fr:tex>
                        <html:p>
  This means that in the new state, the variable <fr:tex display="inline"><![CDATA[\texttt {x}]]></fr:tex> now maps to the number <fr:tex display="inline"><![CDATA[\texttt {n}]]></fr:tex>, while all other variable mappings remain unchanged from the original state <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>.
</html:p>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors />
                            <fr:date>
                              <fr:year>2025</fr:year>
                              <fr:month>12</fr:month>
                              <fr:day>4</fr:day>
                            </fr:date>
                            <fr:title text="Expression evaluation">Expression evaluation</fr:title>
                          </fr:frontmatter>
                          <fr:mainmatter>
  
    
    <fr:resource hash="6a4d239ebe747cfb08700219cfa18949"><fr:resource-content><html:img src="/notes/6a4d239ebe747cfb08700219cfa18949.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule *[right=E-Num]{
    }{
      \langle  n, \sigma  \rangle  \Downarrow  n
    }
    \and 
    \inferrule *[right=E-Var]{
    }{
      \langle  x, \sigma  \rangle  \Downarrow  \sigma (x)
    }
    \and 
    \inferrule *[right=E-Add]{
      \langle  e_1, \sigma  \rangle  \Downarrow  n_1 \\
      \langle  e_2, \sigma  \rangle  \Downarrow  n_2
    }{
      \langle  e_1 + e_2, \sigma  \rangle  \Downarrow  n_1 + n_2
    }
    \and 
    \inferrule *[right=E-Sub]{
      \langle  e_1, \sigma  \rangle  \Downarrow  n_1 \\
      \langle  e_2, \sigma  \rangle  \Downarrow  n_2
    }{
      \langle  e_1 - e_2, \sigma  \rangle  \Downarrow  n_1 - n_2
    }
    \and 
    \inferrule *[right=E-Mul]{
      \langle  e_1, \sigma  \rangle  \Downarrow  n_1 \\
      \langle  e_2, \sigma  \rangle  \Downarrow  n_2
    }{
      \langle  e_1 * e_2, \sigma  \rangle  \Downarrow  n_1 * n_2
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors />
                            <fr:date>
                              <fr:year>2025</fr:year>
                              <fr:month>12</fr:month>
                              <fr:day>4</fr:day>
                            </fr:date>
                            <fr:title text="Boolean expression evaluation">Boolean expression evaluation</fr:title>
                          </fr:frontmatter>
                          <fr:mainmatter>
  
    
    <fr:resource hash="a16aa0da1d83a5e40e560fb3943d67ea"><fr:resource-content><html:img src="/notes/a16aa0da1d83a5e40e560fb3943d67ea.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule *[right=B-True]{
    }{
      \langle  \top , \sigma  \rangle  \Downarrow  \texttt {true}
    }
    \and 
    \inferrule *[right=B-False]{
    }{
      \langle  \bot , \sigma  \rangle  \Downarrow  \texttt {false}
    }
    \and 
    \inferrule *[right=B-Not]{
      \langle  b, \sigma  \rangle  \Downarrow  v
    }{
      \langle  \neg  b, \sigma  \rangle  \Downarrow  \neg  v
    }
    \and 
    \inferrule *[right=B-And]{
      \langle  b_1, \sigma  \rangle  \Downarrow  v_1 \\
      \langle  b_2, \sigma  \rangle  \Downarrow  v_2
    }{
      \langle  b_1 \land  b_2, \sigma  \rangle  \Downarrow  v_1 \land  v_2
    }
    \and 
    \inferrule *[right=B-Or]{
      \langle  b_1, \sigma  \rangle  \Downarrow  v_1 \\
      \langle  b_2, \sigma  \rangle  \Downarrow  v_2
    }{
      \langle  b_1 \lor  b_2, \sigma  \rangle  \Downarrow  v_1 \lor  v_2
    }
    \and 
    \inferrule *[right=B-Eq]{
      \langle  e_1, \sigma  \rangle  \Downarrow  n_1 \\
      \langle  e_2, \sigma  \rangle  \Downarrow  n_2
    }{
      \langle  e_1 = e_2, \sigma  \rangle  \Downarrow  (n_1 = n_2)
    }
    \and 
    \inferrule *[right=B-Leq]{
      \langle  e_1, \sigma  \rangle  \Downarrow  n_1 \\
      \langle  e_2, \sigma  \rangle  \Downarrow  n_2
    }{
      \langle  e_1 \leq  e_2, \sigma  \rangle  \Downarrow  (n_1 \leq  n_2)
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors />
                            <fr:date>
                              <fr:year>2025</fr:year>
                              <fr:month>12</fr:month>
                              <fr:day>4</fr:day>
                            </fr:date>
                            <fr:title text="Statement evaluation">Statement evaluation</fr:title>
                          </fr:frontmatter>
                          <fr:mainmatter>
  
    
    <fr:resource hash="c80b26dde9779d9a29c9fa2cc9590978"><fr:resource-content><html:img src="/notes/c80b26dde9779d9a29c9fa2cc9590978.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule *[right=S-Skip]{
    }{
      \langle  \texttt {skip}, \sigma  \rangle  \Downarrow  \sigma 
    }
    \and 
    \inferrule *[right=S-Assign]{
      \langle  e, \sigma  \rangle  \Downarrow  n
    }{
      \langle  x \coloneqq  e, \sigma  \rangle  \Downarrow  \sigma [x \mapsto  n]
    }
    \and 
    \inferrule *[right=S-Seq]{
      \langle  s_1, \sigma  \rangle  \Downarrow  \sigma ' \\
      \langle  s_2, \sigma ' \rangle  \Downarrow  \sigma ''
    }{
      \langle  s_1 ; s_2, \sigma  \rangle  \Downarrow  \sigma ''
    }
    \and 
    \inferrule *[right=S-IfTrue]{
      \langle  b, \sigma  \rangle  \Downarrow  \texttt {true} \\
      \langle  s_1, \sigma  \rangle  \Downarrow  \sigma '
    }{
      \langle  \texttt {if } b \texttt { then } s_1 \texttt { else } s_2, \sigma  \rangle  \Downarrow  \sigma '
    }
    \and 
    \inferrule *[right=S-IfFalse]{
      \langle  b, \sigma  \rangle  \Downarrow  \texttt {false} \\
      \langle  s_2, \sigma  \rangle  \Downarrow  \sigma '
    }{
      \langle  \texttt {if } b \texttt { then } s_1 \texttt { else } s_2, \sigma  \rangle  \Downarrow  \sigma '
    }
    \and 
    \inferrule *[right=S-WhileFalse]{
      \langle  b, \sigma  \rangle  \Downarrow  \texttt {false}
    }{
      \langle  \texttt {while } b \texttt { do } s, \sigma  \rangle  \Downarrow  \sigma 
    }
    \and 
    \inferrule *[right=S-WhileTrue]{
      \langle  b, \sigma  \rangle  \Downarrow  \texttt {true} \\
      \langle  s, \sigma  \rangle  \Downarrow  \sigma ' \\
      \langle  \texttt {while } b \texttt { do } s, \sigma ' \rangle  \Downarrow  \sigma ''
    }{
      \langle  \texttt {while } b \texttt { do } s, \sigma  \rangle  \Downarrow  \sigma ''
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                        </fr:tree>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>4</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/003v/</fr:uri>
                        <fr:display-uri>003v</fr:display-uri>
                        <fr:route>/notes/003v/</fr:route>
                        <fr:title text="Simple Imperative Language - Evaluation">Simple Imperative Language - Evaluation</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:ol><html:li>
    What does the following evaluate to?
    <fr:tex display="block"><![CDATA[
      \langle  (x := x - 1), \sigma [x \mapsto  2] \rangle 
    ]]></fr:tex></html:li>
  <html:li>
    What does the following evaluate to?
    <fr:tex display="block"><![CDATA[
      \langle  \texttt {if } x + 1 \leq  3 \texttt { then } x := x - 1, \sigma [x \mapsto  1] \rangle 
    ]]></fr:tex></html:li>
  <html:li>
    What does the following evaluate to?
    <fr:tex display="block"><![CDATA[
      \langle  \texttt {while } (x + 1 \leq  3) \texttt { then } x := x - 1, \sigma [x \mapsto  1] \rangle 
    ]]></fr:tex></html:li>
  <html:li>
    Is the following a <fr:link href="/notes/003w/" title="Total &amp; Partial function" uri="https://kaierikniermann.github.io/notes/003w/" display-uri="003w" type="local">total function</fr:link>?
    <fr:tex display="block"><![CDATA[
      \langle  e, \sigma  \rangle  \Downarrow  n
    ]]></fr:tex></html:li>
  <html:li>
    Is the following a <fr:link href="/notes/003w/" title="Total &amp; Partial function" uri="https://kaierikniermann.github.io/notes/003w/" display-uri="003w" type="local">total function</fr:link>?
    <fr:tex display="block"><![CDATA[
      \langle  s, \sigma  \rangle  \Downarrow  \sigma '
    ]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>4</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Starting in the state <fr:tex display="inline"><![CDATA[x \mapsto  2]]></fr:tex> we evaluate <fr:tex display="inline"><![CDATA[x := x - 1]]></fr:tex> to the state <fr:tex display="inline"><![CDATA[x \mapsto  1]]></fr:tex></html:li>
    <html:li>Starting in the state <fr:tex display="inline"><![CDATA[x \mapsto  1]]></fr:tex>, we first evaluate the condition <fr:tex display="inline"><![CDATA[x + 1 \leq  3]]></fr:tex>:
      <fr:tex display="block"><![CDATA[
        \begin {align*}
        \langle  x + 1, \sigma [x \mapsto  1] \rangle  &\Downarrow  2 \\
        \langle  3, \sigma [x \mapsto  1] \rangle  &\Downarrow  3 \\
        \langle  2 \leq  3, \sigma [x \mapsto  1] \rangle  &\Downarrow  \texttt {true}
        \end {align*}
      ]]></fr:tex>
      Since the condition evaluates to true, we then evaluate the then-branch <fr:tex display="inline"><![CDATA[x := x - 1]]></fr:tex>:
      <fr:tex display="block"><![CDATA[
        \begin {align*}
        \langle  x - 1, \sigma [x \mapsto  1] \rangle  &\Downarrow  0 \\
        \langle  x := 0, \sigma [x \mapsto  1] \rangle  &\Downarrow  \sigma [x \mapsto  0]
        \end {align*}
      ]]></fr:tex></html:li>
    <html:li>We again start by evaluating the condition
      <fr:tex display="block"><![CDATA[
        \begin {align*}
        \langle  x + 1, \sigma [x \mapsto  1] \rangle  &\Downarrow  2 \\
        \langle  3, \sigma [x \mapsto  1] \rangle  &\Downarrow  3 \\
        \langle  2 \leq  3, \sigma [x \mapsto  1] \rangle  &\Downarrow  \texttt {true}
        \end {align*}
      ]]></fr:tex>
      Since we can see that the body of the loop only decreases <fr:tex display="inline"><![CDATA[x]]></fr:tex>, we are stuck in an infinite loop:
      <fr:tex display="block"><![CDATA[
        \begin {align*}
        \langle  x := x - 1, \sigma [x \mapsto  1] \rangle  &\Downarrow  \sigma [x \mapsto  0] \\
        \langle  \texttt {while } (x + 1 \leq  3) \texttt { do } x := x - 1, \sigma [x \mapsto  0] \rangle  &\Downarrow  \sigma [x \mapsto  -1] \\
        \langle  \texttt {while } (x + 1 \leq  3) \texttt { do } x := x - 1, \sigma [x \mapsto  -1] \rangle  &\Downarrow  \sigma [x \mapsto  -2] \\
        &\vdots 
        \end {align*}
      ]]></fr:tex></html:li>
    <html:li>Yes, for every expression <fr:tex display="inline"><![CDATA[e]]></fr:tex> and state <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>, there exists a number <fr:tex display="inline"><![CDATA[n]]></fr:tex> such that
      <fr:tex display="block"><![CDATA[
        \langle  e, \sigma  \rangle  \Downarrow  n
      ]]></fr:tex>
      This follows from the fact that expressions are finite syntax trees built from a finite set of rules, and each rule can be evaluated in a finite number of steps.
    </html:li>
    <html:li>No, there exist statements <fr:tex display="inline"><![CDATA[s]]></fr:tex> and states <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> for which there is no resulting state <fr:tex display="inline"><![CDATA[\sigma ']]></fr:tex> such that
      <fr:tex display="block"><![CDATA[
        \langle  s, \sigma  \rangle  \Downarrow  \sigma '
      ]]></fr:tex>
      For example, consider the while-loop
      <fr:tex display="block"><![CDATA[
        \texttt {while } (x + 1 \leq  3) \texttt { do } x := x - 1
      ]]></fr:tex>
      starting from the state <fr:tex display="inline"><![CDATA[\sigma [x \mapsto  1]]]></fr:tex>. As shown in the previous question, this loop does not terminate, and thus there is no resulting state <fr:tex display="inline"><![CDATA[\sigma ']]></fr:tex>.
    </html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:title text="Hoare Logic">Hoare Logic</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>11</fr:month>
      <fr:day>23</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/001e/</fr:uri>
    <fr:display-uri>001e</fr:display-uri>
    <fr:route>/notes/001e/</fr:route>
    <fr:title text="Natural Number Object (NNO) in Set">Natural Number Object (NNO) in Set</fr:title>
    <fr:taxon>Example</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>In the category <html:strong>Set</html:strong>, the natural number object (NNO) can be represented by the set of natural numbers <fr:tex display="inline"><![CDATA[\mathbb {N} = \{0, 1, 2, 3, \ldots \}]]></fr:tex>. If we take some arbitrary other set <fr:tex display="inline"><![CDATA[X]]></fr:tex> with some point <fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> (which can be identified with an element of <fr:tex display="inline"><![CDATA[X]]></fr:tex>) and some function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, we can define a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> as follows:</html:p>
    <fr:tex display="block"><![CDATA[
  u(n) = \begin {cases}
    x & \text {if } n = 0 \\
    f^n(x) & \text {if } n \geq  0
  \end {cases}
]]></fr:tex>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/001b/</fr:uri>
            <fr:display-uri>001b</fr:display-uri>
            <fr:route>/notes/001b/</fr:route>
            <fr:title text="Understanding recursors with Lean4">Understanding recursors with Lean4</fr:title>
            <fr:taxon>Blog</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Before we define recursors, let's first introduce the idea of an inductive type. We'll do this by examining how lean defines natural numbers.</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
</html:code></html:pre><html:p>The idea here being that we can construct natural numbers by either using the constructor <html:code>zero</html:code> to get <html:code>0</html:code>, or by applying the constructor <html:code>succ</html:code> to an existing natural number to get its successor. For example, we can construct <html:code>3</html:code> as follows:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def three : Nat := Nat.succ (Nat.succ (Nat.succ Nat.zero))
</html:code></html:pre><html:p>We can equivalently express this definition using the type formation and term intruduction rules:</html:p>
  
    
    <fr:resource hash="bcb67e2e9cc0f3c7e267cde01c7827d1"><fr:resource-content><html:img src="/notes/bcb67e2e9cc0f3c7e267cde01c7827d1.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
     \usepackage{syntax}
   \usepackage{eulervm}
   \usepackage{mathpartir, amsmath, amsthm, amsfonts, amssymb}
   \usepackage[scaled=0.92]{inconsolata}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      {\small 
        \begin {mathpar}
        
  \inferrule *[right=Form-Nat]{
  }{
    \mathbb {N} : \texttt {type}
  }
  \and  
  \inferrule *[right=Intro-Zero]{}{
    0 : \mathbb {N}
  }
  \and 
  \inferrule *[right=Intro-Succ]{
    n : \mathbb {N}
  }{
    \texttt {succ}\ n : \mathbb {N}
  }

        \end {mathpar}
      }
    ]]></fr:resource-source></fr:resource>
  
<html:p>While this explanation for inductive types usually gives most people I think enough intuition to understand the basic notions of how to use them to construct something like natural numbers, I think it kind of misses the deeper idea of what an inductive type and by extension a recursor really is. To attempt to explain this we'll take a look into some of the categorical semantics behind inductive types.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001c/</fr:uri><fr:display-uri>001c</fr:display-uri><fr:route>/notes/001c/</fr:route><fr:title text="Natural Number Object (NNO)">Natural Number Object (NNO)</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We assume that <fr:tex display="inline"><![CDATA[\mathcal  L]]></fr:tex> is a category with a <fr:link href="/notes/001d/" title="Terminal Object (Category Theory)" uri="https://kaierikniermann.github.io/notes/001d/" display-uri="001d" type="local">terminal object</fr:link> <fr:tex display="inline"><![CDATA[1]]></fr:tex>. This category has a <html:em>natural number object</html:em> (NNO) if there exists an object <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> together with two morphisms:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[0 : 1 \to  \mathbb {N}]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[s : \mathbb {N} \to  \mathbb {N}]]></fr:tex></html:li></html:ul><html:p>such that, given any global element <fr:tex display="inline"><![CDATA[z : 1 \to  X]]></fr:tex> and any morphism <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, there exists a unique morphism <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> such that the following diagram commutes:</html:p>
 
  
  <html:figure><fr:resource hash="7c76fba05ad4c8a281d04182bd1e3d42"><fr:resource-content><html:img src="/notes/7c76fba05ad4c8a281d04182bd1e3d42.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
 
  \usepackage{syntax}
 \usepackage{mathpartir, amsmath, amsthm, amsfonts}
 \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzcd}
    1 \arrow [r, "0"] \arrow [dr, "z"'] & \mathbb {N} \arrow [d, "u"] \arrow [r, "s"] & \mathbb {N} \arrow [d, "u"] \\
    & X \arrow [r, "f"'] & X
  \end {tikzcd}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter></fr:tree><html:p>While at first this definition seems a bit needlessly abstract, it actually captures what the inductive type of natural numbers really is. The basic thing to recognize is that the two morphisms (just think of them as functions for now) in reality don't have anything to do with natural numbers directly. Instead they act as a kind of blueprint for how we can use the properties or constraints of natural numbers to make anything. Here on a high level we can describe the two functions / constructors as follows:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[0 : 1 \to  \mathbb {N}]]></fr:tex> - The represents the abstract idea of having some starting point or base case. Within natural numbers this is represented by <html:code>0</html:code>, but in reality it denote an abstract concept of having a starting point.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[s : \mathbb {N} \to  \mathbb {N}]]></fr:tex> - This represents the abstract idea of being able to build upon existing things to create new things. Within natural numbers this is represented by the successor function.</html:li></html:ul><html:p>Now this might quite fairly still seem a bit confusing and abstract. How can we <html:em>use properties</html:em> to <html:em>make anything?</html:em>. To describe this more formally lets constrain ourselves to the category of sets, <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex>. If you are unfamiliar with category theory its sufficient to think of this as just a collection of all kinds of sets and functions between them.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001e/</fr:uri><fr:display-uri>001e</fr:display-uri><fr:route>/notes/001e/</fr:route><fr:title text="Natural Number Object (NNO) in Set">Natural Number Object (NNO) in Set</fr:title><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In the category <html:strong>Set</html:strong>, the natural number object (NNO) can be represented by the set of natural numbers <fr:tex display="inline"><![CDATA[\mathbb {N} = \{0, 1, 2, 3, \ldots \}]]></fr:tex>. If we take some arbitrary other set <fr:tex display="inline"><![CDATA[X]]></fr:tex> with some point <fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> (which can be identified with an element of <fr:tex display="inline"><![CDATA[X]]></fr:tex>) and some function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, we can define a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> as follows:</html:p><fr:tex display="block"><![CDATA[
  u(n) = \begin {cases}
    x & \text {if } n = 0 \\
    f^n(x) & \text {if } n \geq  0
  \end {cases}
]]></fr:tex></fr:mainmatter></fr:tree><html:p>So in plain english what this is saying is that given any set <fr:tex display="inline"><![CDATA[X]]></fr:tex> where we have some starting point <fr:tex display="inline"><![CDATA[x \in  X]]></fr:tex> and some way of building upon existing elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> (the function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>), we can use the properties of natural numbers to create a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> that maps natural numbers to elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> in a way that respects our starting point and building function. A natural next question to have might be </html:p><html:blockquote>
  But what does it mean to <html:em>respect</html:em> the starting point and building function?
</html:blockquote><html:p>Here I'd fast say intuitively you can just imagine construct which has some notion of a start and some way of building upon existing things. For example let's imagine the following graph:</html:p><fr:tex display="block"><![CDATA[
  a \to  b \to  c \to  d \to  e \to  \ldots 
]]></fr:tex><html:p>Clearly here with have:</html:p><html:ul><html:li><html:strong>Starting point</html:strong>: Our start here is the node <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li>
  <html:li><html:strong>Building function</html:strong>: Our building function i.e. successor mechanism here is just following the arrows to the next node.</html:li></html:ul><html:p>So our two morphisms then are:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> where <fr:tex display="inline"><![CDATA[x]]></fr:tex> maps to <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex> where <fr:tex display="inline"><![CDATA[f]]></fr:tex> maps each node to the next node along the arrow. That is
    <html:pre class="code-block language-lean"><html:code class="language-lean">
      f(a) = b
      f(b) = c
      f(c) = d
      f(d) = e
      ...
    </html:code></html:pre></html:li></html:ul><html:p>Creating a minimal replica of this in Lean we could do something like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive Node where
  | start : Node           -- this will play the role of “a”
  | next  : Node → Node   

  def succNode (v : Node) : Node :=
    Node.next v

  def natToNode : ℕ → Node
    | 0       =&gt; Node.start
    | n + 1   =&gt; succNode (natToNode n)
</html:code></html:pre><html:p>So we can see our function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> here is represented by <html:code>natToNode</html:code>. Where the function maps <html:code>0</html:code> to <html:code>a</html:code> and each successor natural number to the next node along the arrow.</html:p><html:p>Something you might notice here is that if our <html:code>natToNode</html:code> function is replaced by just an identity, i.e.:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToNat : ℕ → ℕ
    | 0       =&gt; 0
    | n + 1   =&gt; n + 1
</html:code></html:pre><html:p>Then we get just the natural numbers themselves as defined by their properties. This is precisely what's expressed by the earlier commuative diagram we say. The two arrows:</html:p><fr:tex display="block"><![CDATA[
  1 \xrightarrow {0} \mathbb {N}
  \quad  \text { and } \quad  \mathbb {N} \xrightarrow {s} \mathbb {N}
]]></fr:tex><html:p>Are just the natural numbers defined by their properties. So in a sense the natural numbers are the most basic instantiation of their own properties. So now a fair thing to wonder is:</html:p><html:blockquote>
  So what does this have to do with recursers?
</html:blockquote><html:p>Well the key insight here is that our functions <html:code>natToNat</html:code> and <html:code>natToNode</html:code> both <html:em>are our recursers</html:em> for the natural numbers. A recursor is just a function that allows us to define functions <html:em>out of</html:em> an inductive type by specifying how to handle each constructor of the inductive type. So equivalently we can express our recursor for natural numbers as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def recNat {C : Type} (z : C) (s : C → C) : ℕ → C
    | 0       =&gt; z
    | n + 1   =&gt; s (recNat z s n)
</html:code></html:pre><html:p>If we examine the actual type signature generated by <html:code>#check Nat.rec</html:code> we have:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  «Nat».rec.{u} 
  {motive : ℕ → Sort u} 
  (zero : motive «Nat».zero)
  (succ : (n : ℕ) 
    → motive n 
    → motive n.succ) 
  (t : ℕ) : motive t
</html:code></html:pre><html:p>In our examples above we can see that the <html:code>motive</html:code> is just the type we are mapping to (either <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> or <fr:tex display="inline"><![CDATA[X]]></fr:tex>), the <html:code>zero</html:code> is our starting point (either <html:code>0</html:code> or <html:code>a</html:code>) and the <html:code>succ</html:code> is our building function (either the successor function or following the arrows). So using the recursor we can rewrite our earlier <html:code>natToNat</html:code> and <html:code>natToNode</html:code> functions as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToNat : ℕ → ℕ :=
    Nat.rec 
      0                 -- | 0     =&gt; 0
      (fun n =&gt; n + 1)  -- | n + 1 =&gt; n + 1

  def natToNode : ℕ → Node :=
    Nat.rec 
      Node.start            -- | 0     =&gt; Node.start
      (fun n =&gt; succNode n) -- | n + 1 =&gt; succNode (natToNode n)
</html:code></html:pre><html:p>This for the most part covers the basic idea of recursors for the sake of breviety I won't go into more instances of recursors for other inductive types though conceptually they work the same way. You specify how to handle each constructor of the inductive type and the recursor gives you a function that maps from the inductive type to whatever type you specified. A very important property of recursors emerges when we make the motive dependent. To elabroate on what that means let's first consider the situation of simple stepwise induction.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001f/</fr:uri><fr:display-uri>001f</fr:display-uri><fr:route>/notes/001f/</fr:route><fr:title text="Stepwise (Mathematical) Induction">Stepwise (Mathematical) Induction</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Stepwise (mathematical/natural/ordinary) induction is a proof technique used to establish the truth of a statement <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> for all natural numbers <fr:tex display="inline"><![CDATA[n \in  \mathbb {N}]]></fr:tex>. The process involves two main steps:</html:p><html:ol><html:li><html:strong>Base Case:</html:strong> Prove that the statement <fr:tex display="inline"><![CDATA[P(0)]]></fr:tex> is true.</html:li>
  <html:li><html:strong>Inductive Step:</html:strong> Assume that the statement <fr:tex display="inline"><![CDATA[P(k)]]></fr:tex> is true for some arbitrary natural number <fr:tex display="inline"><![CDATA[k \in  \mathbb {N}]]></fr:tex> (this assumption is called the <html:em>inductive hypothesis</html:em>). Then, using this assumption, prove that the statement <fr:tex display="inline"><![CDATA[P(k + 1)]]></fr:tex> is also true.</html:li></html:ol><html:p>If both the base case and the inductive step are successfully proven, we can conclude that the statement <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds for all natural numbers <fr:tex display="inline"><![CDATA[n \in  \mathbb {N}]]></fr:tex>. The concise formulation of this can be given by the induction principle.</html:p><fr:tex display="block"><![CDATA[
  (P(0) \land  \forall  k \in  \mathbb {N}.\ (P(k) \to  P(k + 1))) \to  \forall  n \in  \mathbb {N}.\ P(n)
]]></fr:tex></fr:mainmatter></fr:tree><html:p>Something we can notice here just by superficial observation alone is that this seems to look an awful lot like the recursor for natural numbers we defined earlier. In fact it <html:em>is</html:em> an application of the recursor for natural numbers for the <html:em>dependent</html:em> motive <fr:tex display="inline"><![CDATA[P : \mathbb {N} \to  \texttt {Prop}.]]></fr:tex>. To make this a little more concrete let's define a simple property over natural numbers:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def P (n : ℕ) : Prop := n + 0 = n
</html:code></html:pre><html:p>Now its important to note that in an abstract sense this is no different then any other function from natural numbers to some type. The dependency comes into play when we try to use the recursor i.e. the properties of naturals with this motive.</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToProp (n : ℕ) : (P n) :=
    Nat.rec
      (motive := P)
      (by simp [P])                    -- base case: P 0
      (fun n ih =&gt; by simp [P])        -- inductive step: P n → P (n+1)
      n
</html:code></html:pre><html:p>A few things we can observe here:</html:p><html:ul><html:li>The recursor here represents a <html:em>dependent</html:em> function, which is to say that the return type of the function depends on the input value. Contrasing this to the earlier case where the return type was always just <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> or <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:li>
  <html:li><html:strong>Base case</html:strong> - Importantly here as opposed to providing a function that returns some value of type <fr:tex display="inline"><![CDATA[C]]></fr:tex> for the base case, we instead provide a proof that the property <fr:tex display="inline"><![CDATA[P(0)]]></fr:tex> holds.</html:li>
  <html:li><html:strong>Inductive step</html:strong> - Similarly for the inductive step we provide a function that takes an arbitrary natural number <fr:tex display="inline"><![CDATA[n]]></fr:tex> and a proof that <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds (the inductive hypothesis) and returns a proof that <fr:tex display="inline"><![CDATA[P(n + 1)]]></fr:tex> holds.</html:li></html:ul><html:p>If we view this through the lens of the Curry-Howard correspondence it quite nicely illustrates how our proof here is just a program which constructs witnesses (valid proofs) for each natural number that the property <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds. In the same way that our earlier recursor provided elements on the correct type, this dependent recursor provides proofs on the correct property. As this application of a recursor to a proposition represents said proposition being true for all natural numbers, we can equivalently use this within a theorem.</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  theorem add_zero (n : ℕ) : n + 0 = n := 
    natToProp n
</html:code></html:pre></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

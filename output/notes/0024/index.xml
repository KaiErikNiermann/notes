<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>11</fr:month>
      <fr:day>25</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/0024/</fr:uri>
    <fr:display-uri>0024</fr:display-uri>
    <fr:route>/notes/0024/</fr:route>
    <fr:title text="Strict subformula relation">Strict subformula relation</fr:title>
    <fr:taxon>Definition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>
  Given a formula <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, <html:em>strict subformula</html:em> of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> is any formula that is a proper part of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, meaning it is contained within <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> but is not equal to <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> itself. We can denote the strict subformula relation using the symbol <fr:tex display="inline"><![CDATA[\prec _{\text {sf}}]]></fr:tex>. Formally, we say that a formula <fr:tex display="inline"><![CDATA[\psi ]]></fr:tex> is a strict subformula of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> (written as <fr:tex display="inline"><![CDATA[\psi  \prec _{\text {sf}} \phi ]]></fr:tex>) if and only if <fr:tex display="inline"><![CDATA[\psi ]]></fr:tex> is a subformula of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\psi  \ \mathrlap {\,/}{=}\ \phi ]]></fr:tex>.
</html:p>
    <fr:tex display="block"><![CDATA[
  \psi  \prec _{\text {sf}} \phi  \iff  \psi \ \text {is a subformula of}\ \phi  \land  \psi  \ \mathrlap {\,/}{=}\ \phi 
]]></fr:tex>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>25</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/0025/</fr:uri>
            <fr:display-uri>0025</fr:display-uri>
            <fr:route>/notes/0025/</fr:route>
            <fr:title text="Structural induction">Structural induction</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>
  Structural induction represents <fr:link href="/notes/0026/" title="Well-founded induction" uri="https://kaierikniermann.github.io/notes/0026/" display-uri="0026" type="local">well-founded induction</fr:link> applied to the <fr:link href="/notes/0024/" title="Strict subformula relation" uri="https://kaierikniermann.github.io/notes/0024/" display-uri="0024" type="local">strict subformula relation</fr:link>. To prove that a property <fr:tex display="inline"><![CDATA[P(\phi )]]></fr:tex> holds for all formulas <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, it suffices to show that for every formula <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, if <fr:tex display="inline"><![CDATA[P(\psi )]]></fr:tex> holds for all strict subformulas <fr:tex display="inline"><![CDATA[\psi ]]></fr:tex> of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[P(\phi )]]></fr:tex> also holds. Formally, this can be expressed as <fr:link href="/notes/bradley2007calculus/" title="The Calculus of Computation: Decision Procedures with Applications to Verification" uri="https://kaierikniermann.github.io/notes/bradley2007calculus/" display-uri="bradley2007calculus" type="local">(1)</fr:link>:
</html:p><fr:tex display="block"><![CDATA[
  (\forall  \phi .\ (\forall  \psi .\ \psi  \prec _{\text {sf}} \phi  \to  P(\psi )) \to  P(\phi )) \to  (\forall  \phi .\ P(\phi ))
]]></fr:tex><html:p>
  Often times the discussion of structural induction specifically refers to (abstract) syntax where we define a finite tree with ordered branches as the structure of expressions. In practical terms this means we define an inductive type for the syntax of expressions, and then we can perform structural induction over this inductive type. When discussing SI through the lens of constructors we can rephrase the above principle as follows.
</html:p><html:p>
  For any property <fr:tex display="inline"><![CDATA[P(e)]]></fr:tex> of some expression <fr:tex display="inline"><![CDATA[e]]></fr:tex>, to prove that:
</html:p><fr:tex display="block"><![CDATA[
  \forall  e \in  \texttt {E}.\ P(e)
]]></fr:tex><html:p>
  it's sufficient to prove that for each tree constructor <fr:tex display="inline"><![CDATA[c]]></fr:tex> if some arity <fr:tex display="inline"><![CDATA[k \geq  0]]></fr:tex> (takes 0 or more args) that if <fr:tex display="inline"><![CDATA[P]]></fr:tex> holds for all subtrees <fr:tex display="inline"><![CDATA[e_1, e_2, \ldots , e_k]]></fr:tex> then it also holds for the tree constructed by applying <fr:tex display="inline"><![CDATA[c]]></fr:tex> to these subtrees <fr:link href="/notes/sewell-semantics-notes/" title="Semantics of Programming Languages" uri="https://kaierikniermann.github.io/notes/sewell-semantics-notes/" display-uri="sewell-semantics-notes" type="local">(2)</fr:link>:
</html:p><fr:tex display="block"><![CDATA[
  \forall  c.\ \forall  e_1,\ldots ,e_k.\ (P(e_1) \land  P(e_2) \land  \ldots  \land  P(e_k)) \to  P(c(e_1, e_2, \ldots , e_k)) \to  (\forall  e \in  \texttt {E}.\ P(e))
]]></fr:tex><html:p>
  We can equivalently express this through a inference rule as follows:
</html:p>
  
    
    <fr:resource hash="6ecc37a803475062fa37ccc1a7284261"><fr:resource-content><html:img src="/notes/6ecc37a803475062fa37ccc1a7284261.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *{
    \forall  c.\ \forall  e_1,\ldots ,e_k.\ (P(e_1) \land  P(e_2) \land  \ldots  \land  P(e_k))
  }{
    P(c(e_1, e_2, \ldots , e_k)) \to  \forall  e \in  \texttt {E}.\ P(e)
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
  The idea in principle just being that we enumerate through the constructor of the syntax tree and show that if the property holds for all subtrees then it also holds for the tree constructed from them.
</html:p></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

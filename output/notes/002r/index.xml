<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>11</fr:month>
      <fr:day>28</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/002r/</fr:uri>
    <fr:display-uri>002r</fr:display-uri>
    <fr:route>/notes/002r/</fr:route>
    <fr:title text="Type universes in Lean4">Type universes in Lean4</fr:title>
    <fr:taxon>Blog</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>28</fr:day>
        </fr:date>
        <fr:title text="A brief overview">A brief overview</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Universe hierarchy">Universe hierarchy</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>In Lean4, types are organized into a hierarchy of <html:em>universes</html:em> (also referred to as <html:em>sorts</html:em>). Each universe is assoicated with a <html:em>level</html:em>, which is a natural number. The <fr:tex display="inline"><![CDATA[\texttt {Sort}]]></fr:tex> operator constructs a universe from a given level. To avoid things like Girard's paradox, Lean4 employs a stratified type system where each universe can only contain types from lower universes, we have the following hierarchy <fr:link href="/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" title="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)" uri="https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" display-uri="baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024" type="local">(1)</fr:link>:</html:p><fr:tex display="block"><![CDATA[
    \begin {align*}
    \texttt {Prop} : \texttt {Type 0} : \texttt {Type 1} : \texttt {Type 2} : \cdots  \\
    \texttt {Sort 0} : \texttt {Sort 1} : \texttt {Sort 2} : \texttt {Sort 3} : \cdots 
    \end {align*}
  ]]></fr:tex><html:p><fr:tex display="inline"><![CDATA[\texttt {Sort}]]></fr:tex> has two main aliases used in Lean4: <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex>. Here, <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> (which is equivalent to <fr:tex display="inline"><![CDATA[\texttt {Sort 0}]]></fr:tex>) is the universe of logical propositions, while <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex> (which is equivalent to <fr:tex display="inline"><![CDATA[\texttt {Sort (u + 1)}]]></fr:tex>) represents a universe of types at level <fr:tex display="inline"><![CDATA[u]]></fr:tex>. So we can say:</html:p><fr:tex display="block"><![CDATA[
    \texttt {Type u} \equiv  \texttt {Sort (u + 1)}
  ]]></fr:tex><fr:tex display="block"><![CDATA[
    \texttt {Prop} \equiv  \texttt {Sort 0}
  ]]></fr:tex><html:p>In general we can express the hierarchy for any universe level <fr:tex display="inline"><![CDATA[u]]></fr:tex> as follows:</html:p>
  
    
    <fr:resource hash="d22c345c7afa48bf314e21f040d4332e"><fr:resource-content><html:img src="/notes/d22c345c7afa48bf314e21f040d4332e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule *[right=Sort]{
    }{
      \Gamma  \vdash  \texttt {Sort u} : \texttt {Sort (u + 1)}
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Predicative universes">Predicative universes</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>With the exception of propositions, a type in a universe at level <fr:tex display="inline"><![CDATA[u]]></fr:tex> cannot quantify over types from strictly larger universes unless the whole result is lifted to a larger universe. In the case of types we have:</html:p>
  
    
    <fr:resource hash="d764c9e89e1a835ed3d018e580fe27b4"><fr:resource-content><html:img src="/notes/d764c9e89e1a835ed3d018e580fe27b4.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=ArrowType]{
        \Gamma  \vdash  \sigma  : \texttt {Type u} \\
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Type v}
      }{
        \Gamma  \vdash  (x : \sigma ) \to  \tau [x] : \texttt {Type (max u v)}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>To demonstrate some valid instance of this inference rule lets consider the following lean examples:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
      example (α : Type 1) (β : Type 2) : Type 2 := α → β
      example (α : Type 2) (β : Type 1) : Type 2 := α → β
    </html:code></html:pre><html:p>Both of the above examples are valid because the resulting type is lifted to the maximum universe level of the input types. In general we say that the behavior of the <fr:tex display="inline"><![CDATA[\texttt {Type}]]></fr:tex> universes is called <html:strong>predicative</html:strong> meaning that objects <html:em>may not</html:em> be defined in terms of quantifiers ranging over that same object.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Impredicative universes">Impredicative universes</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>We can observe that a function type's universe is determined by the universes of its argument and return types. However, in the case of propositions we have a different behavior:</html:p>
  
    
    <fr:resource hash="120b65d6f240b5db99f27acc7a668d16"><fr:resource-content><html:img src="/notes/120b65d6f240b5db99f27acc7a668d16.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=ArrowProp]{
        \Gamma  \vdash  \sigma  : \texttt {Sort u} \\ 
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Prop}
      }{
        \Gamma  \vdash  (\forall  x : \sigma , \tau [x]) : \texttt {Prop}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Predicates, which are functions that return propositions, may have argument types in any universe, but the function itself remains in the <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> universe. This behavior is called <html:strong>impredicative</html:strong> meaning that objects <html:em>may</html:em> be defined in terms of quantifiers ranging over that same object. The rule <fr:tex display="inline"><![CDATA[\textsc {ArrowProp}]]></fr:tex> means that expressions such <fr:tex display="inline"><![CDATA[\forall  a : \texttt {Prop}, a \to  a]]></fr:tex>, which quantify over all propositions (including themselves), yield a proposition, that is:</html:p><fr:tex display="block"><![CDATA[
      (\forall  a : \texttt {Prop},\ a \to  a) : \texttt {Prop}
    ]]></fr:tex><html:p>We can see some more examples of quantifying both over propositions and types as follows:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
      /-- Quantifying over propositions yields a proposition -/
      example : Prop := ∀ (P : Prop) (p1 p2 : P), p1 = p2

      /-- Proposition quantifying over all type stays in Prop -/
      example : Prop := ∀ (α : Type), ∀ (x : α), x = x
      example : Prop := ∀ (α : Type 5), ∀ (x : α), x = x
    </html:code></html:pre></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="The general rule">The general rule</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>We can combine these two rules to get a more general rule for function types that return types in any universe:</html:p>
  
    
    <fr:resource hash="bc08812524e6a16f5f31653540c8a6e2"><fr:resource-content><html:img src="/notes/bc08812524e6a16f5f31653540c8a6e2.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=Arrow]{
        \Gamma  \vdash  \sigma  : \texttt {Sort u} \\ 
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Sort v}
      }{
        \Gamma  \vdash  (x : \sigma ) \to  \tau [x] : \texttt {Sort (imax u v)}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Here the function type's universe is determined by the (impredicative max) <html:strong>imax</html:strong> of the universes of its argument and return types, where <fr:tex display="inline"><![CDATA[\texttt {imax}]]></fr:tex> is defined as follows:</html:p><fr:tex display="block"><![CDATA[
      \texttt {imax}(u, v) = \begin {cases}
        0 & \text {if } v = 0 \\
        \texttt {max}(u, v) & \text {otherwise}
      \end {cases}
    ]]></fr:tex></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="The level grammar">The level grammar</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We can describe the level grammar via the following inductive type:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      inductive Level
      | zero : Level
      | succ : Level → Level
      | max  : Level → Level → Level
      | imax : Level → Level → Level
    </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>28</fr:day>
        </fr:date>
        <fr:title text="Universe Binding">Universe Binding</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Explicit">Explicit</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We can define functions and types that are <html:strong>universe polymorphic</html:strong> by introducing universe levels either <html:em>explicitly</html:em> or <html:em>implicitly</html:em>. An explicit universe level is specified directly in the definition, while an implicit universe level is inferred by Lean4. For example:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
        /-- Explicit universe level -/
        def map.{u v} {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β :=
          | []       =&gt; []
          | x :: xs  =&gt; f x :: map f xs
      </html:code>
            </html:pre>
            <html:p>Here the map is declared with explicit universe levels <fr:tex display="inline"><![CDATA[u]]></fr:tex> and <fr:tex display="inline"><![CDATA[v]]></fr:tex> and instantiates the polymorphic <fr:tex display="inline"><![CDATA[\texttt {List}]]></fr:tex>. We can also define the same function with implicit universe levels as follows:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
        universe u v
        def map {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β := ...
      </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Implicit">Implicit</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>By default in Lean4 the option <fr:tex display="inline"><![CDATA[\texttt {autoImplicit}]]></fr:tex> is set to true, meaning that our universe levels will be inferred automatically meaning that we can simply write:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
        def map {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β := ...
      </html:code>
            </html:pre>
            <html:p>Importantly automatic implicit paramter inference <html:em>only works</html:em> if the universe is mentioned in the header preceding the assignment, i.e:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
        /-- Bad: unknown universe u -/
        def L := List (Type u)
        /-- Good: universe u mentioned in header -/
        def L.{u} := List (Type u)
      </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Implicit + fresh">Implicit + fresh</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We can also go even further with implicit universes by allowing Lean4 to generate fresh universe levels for us. This is done by omitting the universe annotation and replacing it with a * suffix:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      /-- Fresh implicit universe levels -/
      def map {α : Type*} {β : Type*} 
          (f : α → β) : List α → List β := ...
    </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>28</fr:day>
        </fr:date>
        <fr:title text="Universe Lifting">Universe Lifting</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>Sometimes we may want to explicitly  lift a type from one universe to a higher universe. Lean4 provides lifting operators which are wrappers around terms of a type that reside in a higher universe. There are two main lifting operators:</html:p>
        <html:ul><html:li><fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex>: Lifts a proposition from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> (i.e. <fr:tex display="inline"><![CDATA[\texttt {Sort 1}]]></fr:tex>).</html:li>
    <html:li><fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex>: Lifts a type from <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex> to any number of levels.</html:li></html:ul>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="PLift">PLift</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> operator is used to lift propositions into the first type universe. It is defined as follows:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      structure PLift (α : Sort u) : Type u where
        /-- Wraps a proof/value to increase its type's universe lvl -/
        up ::
        /-- Extracts a wrapped proof/value from a lifted prop/type. -/
        down : α
    </html:code>
            </html:pre>
            <html:p>Some simple examples:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      #check False       -- False : Prop
      #check PLift False -- PLift False : Type
      #check Nat         -- Nat : Type
      #check PLift Nat   -- PLift Nat : Type 1

      example : PLift Prop        := PLift.up True
      example : Prop              := (PLift.down (PLift.up False))
      example : List (PLift True) := [.up (by trivial), .up (by decide)]
    </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="ULift">ULift</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The <fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex> operator is used to lift types to higher universes. It is defined as follows:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      structure ULift.{r, s} (α : Type s) : Type (max s r) where
        /-- Wraps a value to increase its type's universe level. -/
        up ::
        /-- Extracts a wrapped value from a universe-lifted type. -/
        down : α
    </html:code>
            </html:pre>
            <html:p>Some simple examples:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      #check Nat               -- Nat : Type
      #check ULift Nat         -- ULift Nat : Type 1
      #check ULift (ULift Nat) -- ULift (ULift Nat) : Type 2

      example : ULift Nat        := ULift.up 42
      example : List (ULift Nat) := [.up 1, .up 2, .up 3]
    </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>28</fr:day>
        </fr:date>
        <fr:title text="Example: Preorder Category">Example: Preorder Category</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>A <html:em>preorder relation</html:em> is a binary relation that is <html:strong>reflexive</html:strong> and <html:strong>transitive</html:strong>. In Lean this is expressed as follows:</html:p>
        <html:pre class="code-block language-lean">
          <html:code class="language-lean">
    class Preorder (α : Type*) extends LE α, LT α where
      le_refl   : ∀ a : α, a ≤ a
      le_trans  : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c
      lt := fun a b =&gt; a ≤ b ∧ ¬b ≤ a
      lt_iff_le_not_ge : ∀ a b : α, a &lt; b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl
  </html:code>
        </html:pre>
        <html:p>We can already see here that the preorder relation uses implicit universe polymorphism via the <fr:tex display="inline"><![CDATA[\texttt {Type*}]]></fr:tex> annotation. We can now construct a small category from a preorder relation as follows:</html:p>
        <html:pre class="code-block language-lean">
          <html:code class="language-lean">
    open CategoryTheory

    instance {α : Type u} [Preorder α] : SmallCategory α where
      Hom a b          := ULift &lt;| PLift (a ≤ b)
      id a             := .up &lt;| .up &lt;| le_refl a
      comp {a b c} f g := .up &lt;| .up &lt;| (le_trans f.down.down g.down.down)
  </html:code>
        </html:pre>
        <html:p>Let's break this down part by part starting with the homomorphisms:</html:p>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Arrows">Arrows</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>For the case of the category definition, Lean fundamentally uses quivers to represent the homs between objects. Now before showing how lean defines them let's I think try and do it ourselves. So in this instance in an abstract sense we want the relationship <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> to represent our morphism or arrow between two objects, so in a sense the following two are equivalent:</html:p>
            <fr:tex display="block"><![CDATA[
      a \leq  b \equiv  a \xrightarrow {\leq } b
    ]]></fr:tex>
            <html:p>So in the most straightforward sense what we can do is define any kind of "container" to repreesnt our source and target objects under some label, we can define this naively as follows:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      class Graph (Obj : Type) where
        arrow (source : Obj) (target : Obj) : Type
    </html:code>
            </html:pre>
            <html:p>Now let's try to define an instance of such a graph on a preorder relation in which our objects simply live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      instance {α : Type} [Preorder α] : Graph α where
        arrow a b := a ≤ b -- arrow from a to b is the relation a ≤ b
    </html:code>
            </html:pre>
            <html:p>Here we are declaring an instance, this instance takes
      <html:ul><html:li>An <html:strong>implicit type parameter</html:strong> <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> which is the type of our objects at the universe level 0.</html:li>
          <html:li>A <html:strong>type class constraint</html:strong> <fr:tex display="inline"><![CDATA[\texttt {[Preorder α]}]]></fr:tex> which ensures that the type <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> has a preorder relation defined on it. In other words it guarantees that the relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> is reflexive and transitive for all elements of type <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex>.</html:li></html:ul>
      And we provide the necessary implementation for the <fr:tex display="inline"><![CDATA[\texttt {arrow}]]></fr:tex> function by setting it to be the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>. But what you will notice is that we have a problem here, namely that our preorder relation lives in the universe <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> as its obviously a logical relation, but our graph arrows need to live in <fr:tex display="inline"><![CDATA[\texttt {Type}]]></fr:tex> (i.e. <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>).  
    </html:p>
            <html:p>A first thought might be to just set the arrow type to be <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> directly, in our definition of the class <fr:tex display="inline"><![CDATA[\texttt {Graph}]]></fr:tex> though this is rather restrictive as it means that any graph we wish to define can only ever have arrows representing propositions, what if we want to have arrows represent other types such as functions or numbers?</html:p>
            <html:p>One way to approach this is to use the <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> operator to lift our preorder relation from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> as follows:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      instance {α : Type} [Preorder α] : Graph α where
        arrow a b := PLift (a ≤ b) -- lift relation to Type 0
    </html:code>
            </html:pre>
            <html:p>While this does work, and often is probably a reasonable way to go about things, much of Lean's mathlib employs universe polymorphic types to define various kinds of structures. Thus parameterising over some universe level <fr:tex display="inline"><![CDATA[u]]></fr:tex> we define our polymorphic instance as:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      instance {α : Type u} [Preorder α] : Graph α where
        arrow a b := PLift (a ≤ b) 
    </html:code>
            </html:pre>
            <html:p>But now we naturally run into another issue, namely that the class for our graph is now no longer universe polymorphic which leads to a universe level mismatch. The most straightforward fix here is to simply make the objects in the graph universe polymorphic as well:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      class Graph (Obj : Type u) where -- now polymorphic over u
        arrow (source : Obj) (target : Obj) : Type
    </html:code>
            </html:pre>
            <html:p>But this leads to another question, what level should the arrows live in? We've already seen that arrows can represent various different kinds of things different from the types of objects themselves, (e.g. <fr:tex display="inline"><![CDATA[2 \leq  3]]></fr:tex> is a proposition but clearly 2 and 3 are numbers). Now one approach is to simply leave the arrows in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> but this already is mildly annoying as it forces us to lift any arrows that don't naturally live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>. Furthermore we've already seen that having the type stuck at Prop is also not nice, so what we can do is make the arrows universe polymorphic as well, though over a different universe level <fr:tex display="inline"><![CDATA[v]]></fr:tex> motivated by the aforementioned situation of different levels of arrows and objects:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      class Graph (Obj : Type u) where
        arrow (source : Obj) (target : Obj) : Sort v

      instance {α : Type u} [Preorder α] : Graph α where
        arrow a b := a ≤ b -- now lives in Sort 0 (i.e. Prop)
    </html:code>
            </html:pre>
            <html:p>But hold up, why are we lifting in the definition of the instance for the SmallCategory? Let's take a look at all the relevant type signatures:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      -- Quiver 
      -- (V : Type u) where

      -- CategoryStruct
      -- (obj : Type u) : Type max u (v + 1) extends Quiver.{v + 1} obj

      -- Category 
      -- (obj : Type u) : Type max u (v + 1) extends CategoryStruct.{v} obj 

      -- SmallCategory
      -- (obj : Type u) : Type (u + 1) extends Category.{u} obj 
    </html:code>
            </html:pre>
            <html:p>Let's break this down step by step starting first with the relationship between CategoryStruct and Quiver, for the sake of simplicitly i'll abstract away some exact names and make all universes explicit:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      variable {α : Type m} [Preorder α] (a b c : α)

      class Box.{u, v} (obj : Type u) where
        pair : obj → obj → Sort v

      class A.{u, v} (obj : Type u) 
        : Type max u (v + 1) extends (Box.{u, v + 1} obj) where
    </html:code>
            </html:pre>
            <html:p>I think an interesting question I first had here is with the extension of <fr:tex display="inline"><![CDATA[\texttt {Box}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex> why might you want to increase the universe level of the arrows by one? The main reason this is done in general is to essentially constrain the <fr:tex display="inline"><![CDATA[v]]></fr:tex> to never be zero. The implication of this being that our extended class <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex> can never have any pairs which live in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>.</html:p>
            <html:p>A good follow up to this might be, why would you not want thigns to live in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>? In the most general sense some of the reasons are:</html:p>
            <html:ul><html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> is <html:em>proof irrelevant</html:em>: In Lean, propositions are considered proof irrelevant, meaning that all proofs of a given proposition are treated as equal. This can lead to loss of information when you want to be able to distinguish between different morphisms or in our simplified example pairs.</html:li>
      <html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> is <html:em>not computational</html:em>: Propositions in Lean are not computationally relevant, meaning that they do not have computational content. If you want to perform computations or extract algorithms from your morphisms or pairs, having them in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> would prevent that.</html:li>
      <html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> has <html:em>limited structure</html:em>: Propositions in Lean do not have the same rich structure as types in higher universes. If you need to work with morphisms or pairs that have additional structure (like being functions, sets, etc.), you would want them to live in a higher universe.</html:li></html:ul>
            <html:p>As an example we can consider the following:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      -- @classname disables universe inference for that class
      variable (a₁ : @A.{m, v} α)
      #check (a₁.pair a b : Sort (v + 1)) -- Box.pair a b : Type v
    </html:code>
            </html:pre>
            <html:p>We can see here that the pair now lives in <fr:tex display="inline"><![CDATA[\texttt {Sort (v + 1)}]]></fr:tex>, meaning that if we had <fr:tex display="inline"><![CDATA[v = 0]]></fr:tex> then our pairs would now live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>. A natural byproduct of this choice - having arrows live in <fr:tex display="inline"><![CDATA[\texttt {Sort (v + 1)}]]></fr:tex> - is that the type of the structure itself must now live in the largest universe such that it can contain both the objects and the arrows. This is why we have the type signature <fr:tex display="inline"><![CDATA[\texttt {Type max u (v + 1)}]]></fr:tex> for <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex>. Equivalently we can expand this as:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      -- since Type u = Sort (u + 1) and Type (v + 1) = Sort (v + 2)
      Sort (max (u + 1) (v + 2)) 
    </html:code>
            </html:pre>
            <html:p>If we then create similarly abstract versions for the Category class (B) and SmallCategory class (C) we have:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      class B.{u, v} (obj : Type u) 
        : Type max u (v + 1) extends A.{u, v} obj where

      class C.{u} (obj : Type u) 
        : Type (u + 1) extends B.{u, u} obj where 
      --                        ^ can also type B.{u} (inferres v = u)
    </html:code>
            </html:pre>
            <html:p>We can see here that our SmallCategory (C) now constrains the arrows to live in the same universe as the objects by setting <fr:tex display="inline"><![CDATA[v = u]]></fr:tex> in the extension of <fr:tex display="inline"><![CDATA[\texttt {B}]]></fr:tex>. Thus if we construct our pair, we have:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      variable (c : @C.{m} α)
      #check (c.pair a b : Sort (m + 1)) -- Box.pair a b : Type m
    </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Identity morphism">Identity morphism</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Next up let's look at the identity morphism:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      id a := .up &lt;| .up &lt;| le_refl a
    </html:code>
            </html:pre>
            <html:p>The identity is defined as a function that quantifies over all objects <fr:tex display="inline"><![CDATA[a]]></fr:tex> in our category and returns an arrow from <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[a]]></fr:tex>. Naturally we then first want to construct our arrow, the identity arrow from <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[a]]></fr:tex> is simply the reflexivity property of the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>, that is <fr:tex display="inline"><![CDATA[a \leq  a]]></fr:tex> which we can get via <fr:tex display="inline"><![CDATA[\texttt {le\_refl a}]]></fr:tex>. However since our arrows live in <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>, we need to lift our relation twice, first using <fr:tex display="inline"><![CDATA[\texttt {PLift.up}]]></fr:tex> to lift it from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>, and then again using <fr:tex display="inline"><![CDATA[\texttt {ULift.up}]]></fr:tex> to lift it from <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>. A note to make for people unfamiliar with the syntax here, the following pieces of code are equivalent:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      -- .up &lt;| .up &lt;| le_refl a == ULift.up (PLift.up (le_refl a))
    </html:code>
            </html:pre>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:title text="Composition">Composition</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Finally let's look at the composition of arrows:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      comp {a b c} f g := .up &lt;| .up &lt;| (le_trans f.down.down g.down.down)
    </html:code>
            </html:pre>
            <html:p>The lifting portion here follows the same reasoning as the identity morphism, we need to lift the resulting relation from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>. The actual composition is done via the transitivity property of the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>. The thing is here that our input arrows <fr:tex display="inline"><![CDATA[f]]></fr:tex> and <fr:tex display="inline"><![CDATA[g]]></fr:tex> are both lifted types corresponding to:</html:p>
            <html:pre class="code-block language-lean">
              <html:code class="language-lean">
      f : ULift (PLift (a ≤ b))
      g : ULift (PLift (b ≤ c))
    </html:code>
            </html:pre>
            <html:p>Thus to extract the actual preorder relations we need to use the <fr:tex display="inline"><![CDATA[\texttt {down}]]></fr:tex> method twice, first to go from <fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex>, and then again to go from <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> to the actual relation in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>. Once we have the two relations extracted we can then apply the transitivity property <fr:tex display="inline"><![CDATA[\texttt {le\_trans}]]></fr:tex> to get the composed relation <fr:tex display="inline"><![CDATA[a \leq  c]]></fr:tex> (which we then lift back up).</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>Baanen, Anne, Bentkamp, Alexander, Blanchette, Jasmin, Holzl, Johannes, Limperg, Jannis</fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/</fr:uri>
            <fr:display-uri>baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024</fr:display-uri>
            <fr:route>/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/</fr:route>
            <fr:title text="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)">The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="note">Desktop edition</fr:meta>
            <fr:meta name="external">https://raw.githubusercontent.com/lean-forward/logical_verification_2024/main/hitchhikers_guide_2024_desktop.pdf</fr:meta>
            <fr:meta name="publisher">Lean Forward</fr:meta>
            <fr:meta name="ENTRYTYPE">book</fr:meta>
            <fr:meta name="ID">baanen_bentkamp_blanchette_holzl_limperg_hitchhikers_2024</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/001a/</fr:uri>
            <fr:display-uri>001a</fr:display-uri>
            <fr:route>/notes/001a/</fr:route>
            <fr:title text="Blog posts">Blog posts</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>23</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/001b/</fr:uri>
                <fr:display-uri>001b</fr:display-uri>
                <fr:route>/notes/001b/</fr:route>
                <fr:title text="Understanding recursors with Lean4">Understanding recursors with Lean4</fr:title>
                <fr:taxon>Blog</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>23</fr:day>
                    </fr:date>
                    <fr:title text="The recursor for natural numbers">The recursor for natural numbers</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Before we define recursors, let's first introduce the idea of an inductive type. We'll do this by examining how lean defines natural numbers.</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
</html:code></html:pre><html:p>The idea here being that we can construct natural numbers by either using the constructor <html:code>zero</html:code> to get <html:code>0</html:code>, or by applying the constructor <html:code>succ</html:code> to an existing natural number to get its successor. For example, we can construct <html:code>3</html:code> as follows:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def three : Nat := Nat.succ (Nat.succ (Nat.succ Nat.zero))
</html:code></html:pre><html:p>We can equivalently express this definition using the type formation and term intruduction rules:</html:p>
  
    
    <fr:resource hash="27dec52c5491a90c3646fc97985842f7"><fr:resource-content><html:img src="/notes/27dec52c5491a90c3646fc97985842f7.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Form-Nat]{
  }{
    \mathbb {N} : \texttt {type}
  }
  \and  
  \inferrule *[right=Intro-Zero]{}{
    0 : \mathbb {N}
  }
  \and 
  \inferrule *[right=Intro-Succ]{
    n : \mathbb {N}
  }{
    \texttt {succ}\ n : \mathbb {N}
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>While this explanation for inductive types usually gives most people I think enough intuition to understand the basic notions of how to use them to construct something like natural numbers, I think it kind of misses the deeper idea of what an inductive type and by extension a recursor really is. To attempt to explain this we'll take a look into some of the categorical semantics behind inductive types.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001c/</fr:uri><fr:display-uri>001c</fr:display-uri><fr:route>/notes/001c/</fr:route><fr:title text="Natural Number Object (NNO)">Natural Number Object (NNO)</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We assume that <fr:tex display="inline"><![CDATA[\mathcal  L]]></fr:tex> is a category with a <fr:link href="/notes/001d/" title="Terminal Object (Category Theory)" uri="https://kaierikniermann.github.io/notes/001d/" display-uri="001d" type="local">terminal object</fr:link> <fr:tex display="inline"><![CDATA[1]]></fr:tex>. This category has a <html:em>natural number object</html:em> (NNO) if there exists an object <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> together with two morphisms:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[0 : 1 \to  \mathbb {N}]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[s : \mathbb {N} \to  \mathbb {N}]]></fr:tex></html:li></html:ul><html:p>such that, given any global element <fr:tex display="inline"><![CDATA[z : 1 \to  X]]></fr:tex> and any morphism <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, there exists a unique morphism <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> such that the following diagram commutes:</html:p>
 
  
  <html:figure><fr:resource hash="92582dc49da2538abac86319db8d23ab"><fr:resource-content><html:img src="/notes/92582dc49da2538abac86319db8d23ab.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
 
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to AndréC.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzcd}
    1 \arrow [r, "0"] \arrow [dr, "z"'] & \mathbb {N} \arrow [d, "u"] \arrow [r, "s"] & \mathbb {N} \arrow [d, "u"] \\
    & X \arrow [r, "f"'] & X
  \end {tikzcd}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter></fr:tree><html:p>While at first this definition seems a bit needlessly abstract, it actually captures what the inductive type of natural numbers really is. The basic thing to recognize is that the two morphisms (just think of them as functions for now) in reality don't have anything to do with natural numbers directly. Instead they act as a kind of blueprint for how we can use the properties or constraints of natural numbers to make anything. Here on a high level we can describe the two functions / constructors as follows:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[0 : 1 \to  \mathbb {N}]]></fr:tex> - The represents the abstract idea of having some starting point or base case. Within natural numbers this is represented by <html:code>0</html:code>, but in reality it denote an abstract concept of having a starting point.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[s : \mathbb {N} \to  \mathbb {N}]]></fr:tex> - This represents the abstract idea of being able to build upon existing things to create new things. Within natural numbers this is represented by the successor function.</html:li></html:ul><html:p>Now this might quite fairly still seem a bit confusing and abstract. How can we <html:em>use properties</html:em> to <html:em>make anything?</html:em>. To describe this more formally lets constrain ourselves to the category of sets, <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex>. If you are unfamiliar with category theory its sufficient to think of this as just a collection of all kinds of sets and functions between them.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001e/</fr:uri><fr:display-uri>001e</fr:display-uri><fr:route>/notes/001e/</fr:route><fr:title text="Natural Number Object (NNO) in Set">Natural Number Object (NNO) in Set</fr:title><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In the category <html:strong>Set</html:strong>, the natural number object (NNO) can be represented by the set of natural numbers <fr:tex display="inline"><![CDATA[\mathbb {N} = \{0, 1, 2, 3, \ldots \}]]></fr:tex>. If we take some arbitrary other set <fr:tex display="inline"><![CDATA[X]]></fr:tex> with some point <fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> (which can be identified with an element of <fr:tex display="inline"><![CDATA[X]]></fr:tex>) and some function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, we can define a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> as follows:</html:p><fr:tex display="block"><![CDATA[
  u(n) = \begin {cases}
    x & \text {if } n = 0 \\
    f^n(x) & \text {if } n \geq  0
  \end {cases}
]]></fr:tex></fr:mainmatter></fr:tree><html:p>So in plain english what this is saying is that given any set <fr:tex display="inline"><![CDATA[X]]></fr:tex> where we have some starting point <fr:tex display="inline"><![CDATA[x \in  X]]></fr:tex> and some way of building upon existing elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> (the function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>), we can use the properties of natural numbers to create a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> that maps natural numbers to elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> in a way that respects our starting point and building function. A natural next question to have might be </html:p><html:blockquote>
  But what does it mean to <html:em>respect</html:em> the starting point and building function?
</html:blockquote><html:p>Here I'd fast say intuitively you can just imagine construct which has some notion of a start and some way of building upon existing things. For example let's imagine the following graph:</html:p><fr:tex display="block"><![CDATA[
  a \to  b \to  c \to  d \to  e \to  \ldots 
]]></fr:tex><html:p>Clearly here with have:</html:p><html:ul><html:li><html:strong>Starting point</html:strong>: Our start here is the node <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li>
  <html:li><html:strong>Building function</html:strong>: Our building function i.e. successor mechanism here is just following the arrows to the next node.</html:li></html:ul><html:p>So our two morphisms then are:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> where <fr:tex display="inline"><![CDATA[x]]></fr:tex> maps to <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex> where <fr:tex display="inline"><![CDATA[f]]></fr:tex> maps each node to the next node along the arrow. That is
    <html:pre class="code-block language-lean"><html:code class="language-lean">
      f(a) = b
      f(b) = c
      f(c) = d
      f(d) = e
      ...
    </html:code></html:pre></html:li></html:ul><html:p>Creating a minimal replica of this in Lean we could do something like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive Node where
  | start : Node           -- this will play the role of “a”
  | next  : Node → Node   

  def succNode (v : Node) : Node :=
    Node.next v

  def natToNode : ℕ → Node
    | 0       =&gt; Node.start
    | n + 1   =&gt; succNode (natToNode n)
</html:code></html:pre><html:p>So we can see our function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> here is represented by <html:code>natToNode</html:code>. Where the function maps <html:code>0</html:code> to <html:code>a</html:code> and each successor natural number to the next node along the arrow.</html:p><html:p>Something you might notice here is that if our <html:code>natToNode</html:code> function is replaced by just an identity, i.e.:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToNat : ℕ → ℕ
    | 0       =&gt; 0
    | n + 1   =&gt; n + 1
</html:code></html:pre><html:p>Then we get just the natural numbers themselves as defined by their properties. This is precisely what's expressed by the earlier commuative diagram we say. The two arrows:</html:p><fr:tex display="block"><![CDATA[
  1 \xrightarrow {0} \mathbb {N}
  \quad  \text { and } \quad  \mathbb {N} \xrightarrow {s} \mathbb {N}
]]></fr:tex><html:p>Are just the natural numbers defined by their properties. So in a sense the natural numbers are the most basic instantiation of their own properties. So now a fair thing to wonder is:</html:p><html:blockquote>
  So what does this have to do with recursers?
</html:blockquote><html:p>Well the key insight here is that our functions <html:code>natToNat</html:code> and <html:code>natToNode</html:code> both <html:em>are our recursers</html:em> for the natural numbers. A recursor is just a function that allows us to define functions <html:em>out of</html:em> an inductive type by specifying how to handle each constructor of the inductive type. So equivalently we can express our recursor for natural numbers as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def recNat {C : Type} (z : C) (s : C → C) : ℕ → C
    | 0       =&gt; z
    | n + 1   =&gt; s (recNat z s n)
</html:code></html:pre><html:p>If we examine the actual type signature generated by <html:code>#check Nat.rec</html:code> we have:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  «Nat».rec.{u} 
  {motive : ℕ → Sort u} 
  (zero : motive «Nat».zero)
  (succ : (n : ℕ) 
    → motive n 
    → motive n.succ) 
  (t : ℕ) : motive t
</html:code></html:pre><html:p>In our examples above we can see that the <html:code>motive</html:code> is just the type we are mapping to (either <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> or <fr:tex display="inline"><![CDATA[X]]></fr:tex>), the <html:code>zero</html:code> is our starting point (either <html:code>0</html:code> or <html:code>a</html:code>) and the <html:code>succ</html:code> is our building function (either the successor function or following the arrows). So using the recursor we can rewrite our earlier <html:code>natToNat</html:code> and <html:code>natToNode</html:code> functions as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToNat : ℕ → ℕ :=
    Nat.rec 
      0                 -- | 0     =&gt; 0
      (fun n =&gt; n + 1)  -- | n + 1 =&gt; n + 1

  def natToNode : ℕ → Node :=
    Nat.rec 
      Node.start            -- | 0     =&gt; Node.start
      (fun n =&gt; succNode n) -- | n + 1 =&gt; succNode (natToNode n)
</html:code></html:pre></fr:mainmatter>
                </fr:tree>
                <html:p>This for the most part covers the basic idea of recursors for the sake of breviety I won't go into more instances of recursors for other inductive types though conceptually they work the same way. You specify how to handle each constructor of the inductive type and the recursor gives you a function that maps from the inductive type to whatever type you specified.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>23</fr:day>
                    </fr:date>
                    <fr:title text="The connection to induction">The connection to induction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A very important property of recursors emerges when we make the motive dependent. To elabroate on what that means let's first consider the situation of simple stepwise induction.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>23</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/001f/</fr:uri>
                        <fr:display-uri>001f</fr:display-uri>
                        <fr:route>/notes/001f/</fr:route>
                        <fr:title text="Stepwise (Mathematical) Induction">Stepwise (Mathematical) Induction</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Stepwise (mathematical/natural/ordinary) induction is a proof technique used to establish the truth of a statement <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> for all natural numbers <fr:tex display="inline"><![CDATA[n \in  \mathbb {N}]]></fr:tex>. The process involves two main steps:</html:p>
                        <html:ol><html:li><html:strong>Base Case:</html:strong> Prove that the statement <fr:tex display="inline"><![CDATA[P(0)]]></fr:tex> is true.</html:li>
  <html:li><html:strong>Inductive Step:</html:strong> Assume that the statement <fr:tex display="inline"><![CDATA[P(k)]]></fr:tex> is true for some arbitrary natural number <fr:tex display="inline"><![CDATA[k \in  \mathbb {N}]]></fr:tex> (this assumption is called the <html:em>inductive hypothesis</html:em>). Then, using this assumption, prove that the statement <fr:tex display="inline"><![CDATA[P(k + 1)]]></fr:tex> is also true.</html:li></html:ol>
                        <html:p>If both the base case and the inductive step are successfully proven, we can conclude that the statement <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds for all natural numbers <fr:tex display="inline"><![CDATA[n \in  \mathbb {N}]]></fr:tex>. The concise formulation of this can be given by the induction principle.</html:p>
                        <fr:tex display="block"><![CDATA[
  (P(0) \land  \forall  k \in  \mathbb {N}.\ (P(k) \to  P(k + 1))) \to  \forall  n \in  \mathbb {N}.\ P(n)
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>Something we can notice here just by superficial observation alone is that this seems to look an awful lot like the recursor for natural numbers we defined earlier. In fact it <html:em>is</html:em> an application of the recursor for natural numbers for the <html:em>dependent</html:em> motive <fr:tex display="inline"><![CDATA[P : \mathbb {N} \to  \texttt {Prop}.]]></fr:tex>. To make this a little more concrete let's define a simple property over natural numbers:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
  def P (n : ℕ) : Prop := n + 0 = n
</html:code>
                    </html:pre>
                    <html:p>Now its important to note that in an abstract sense this is no different then any other function from natural numbers to some type. The dependency comes into play when we try to use the recursor i.e. the properties of naturals with this motive.</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
  def natToProp (n : ℕ) : (P n) :=
    Nat.rec
      (motive := P)
      (by simp [P])                    -- base case: P 0
      (fun n ih =&gt; by simp [P])        -- inductive step: P n → P (n+1)
      n
</html:code>
                    </html:pre>
                    <html:p>A few things we can observe here:</html:p>
                    <html:ul><html:li>The recursor here represents a <html:em>dependent</html:em> function, which is to say that the return type of the function depends on the input value. Contrasing this to the earlier case where the return type was always just <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> or <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:li>
  <html:li><html:strong>Base case</html:strong> - Importantly here as opposed to providing a function that returns some value of type <fr:tex display="inline"><![CDATA[C]]></fr:tex> for the base case, we instead provide a proof that the property <fr:tex display="inline"><![CDATA[P(0)]]></fr:tex> holds.</html:li>
  <html:li><html:strong>Inductive step</html:strong> - Similarly for the inductive step we provide a function that takes an arbitrary natural number <fr:tex display="inline"><![CDATA[n]]></fr:tex> and a proof that <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds (the inductive hypothesis) and returns a proof that <fr:tex display="inline"><![CDATA[P(n + 1)]]></fr:tex> holds.</html:li></html:ul>
                    <html:p>If we view this through the lens of the Curry-Howard correspondence it quite nicely illustrates how our proof here is just a program which constructs witnesses (valid proofs) for each natural number that the property <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds. In the same way that our earlier recursor provided elements on the correct type, this dependent recursor provides proofs on the correct property. As this application of a recursor to a proposition represents said proposition being true for all natural numbers, we can equivalently use this within a theorem.</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
  theorem add_zero (n : ℕ) : n + 0 = n := natToProp n
</html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>23</fr:day>
                    </fr:date>
                    <fr:title text="Case Study: Evaluating arithmetic expressions">Case Study: Evaluating arithmetic expressions</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>As a little kind of case study I want to give an example of an inductive type (and its recursor) that most people become familiar with; in a sense; as early as primary school: the operational semantics of binary operators. We'll start by defining some of the basic syntax for arithmetic expressions:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive BinOp where 
  | add : BinOp
  | sub : BinOp
  | mul : BinOp
  | div : BinOp

  inductive Expr where
  | const : ℕ → Expr
  | binop : BinOp → Expr → Expr → Expr
</html:code></html:pre><html:p>So here we have defined a simple language of arithmetic expressions consisting of natural number constants and binary operations. This provides us with the means to construct expressions like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  #check Expr.binop BinOp.add (Expr.const 10) (Expr.const 20)
</html:code></html:pre><html:p>If we want to actually define the semantics of how to evaluate these expression we'll need to define a set of rewrite rules that describe how we can take an expression and reduce it to a value i.e. evaluate it. To evaluate an expression we want to traverse the expression tree and whenever we encounter a binary operation with two constant operands we want to apply the operation and replace the entire sub-expression with the resulting constant. We express this as 3 rewrite rules:</html:p><html:ul><html:li><html:strong>Left Evaluation</html:strong>: If the left operand of a binary operation can be reduced, then we reduce it.</html:li>
  <html:li><html:strong>Right Evaluation</html:strong>: If the left operand is a constant and the right operand can be reduced, then we reduce the right operand.</html:li>
  <html:li><html:strong>Operation Evaluation</html:strong>: If both operands are constants, we apply the binary operation and replace the entire sub-expression with the resulting constant.</html:li></html:ul><html:pre class="code-block language-lean"><html:code class="language-lean">
  def eval_op : BinOp → (Nat → Nat → Nat)
  | .add =&gt; Nat.add
  | .sub =&gt; Nat.sub
  | .mul =&gt; Nat.mul
  | .div =&gt; Nat.div

  inductive Step : Expr -&gt; Expr -&gt; Prop
  | ST_BinOp1 (op : BinOp)
      (e₁ e₁' e₂ : Expr)   
      (h : Step e₁ e₁') :  
      Step (Expr.binop op e₁ e₂) 
           (Expr.binop op e₁' e₂)
  | ST_BinOp2 (op : BinOp) 
      (v₁ : Nat) 
      (e₂ e₂' : Expr) 
      (h : Step e₂ e₂') :
      Step (Expr.binop op (Expr.const v₁) e₂) 
           (Expr.binop op (Expr.const v₁) e₂')
  | ST_BinOpConst (op : BinOp) (v₁ v₂ : Nat) :
      Step (Expr.binop op (Expr.const v₁) (Expr.const v₂)) 
           (Expr.const (eval_op op v₁ v₂))
</html:code></html:pre><html:p>Since expressions can naturally require multiple evaluations steps it makes sense to define a multi-step evaluation relation as the reflexive transitive closure of the single step evaluation relation defined above. This we can define as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  abbrev MultiStep := Relation.ReflTransGen Step

  -- helper notation to express multi-step evaluation
  notation:50 e " -&gt;ⁿ " e' =&gt;  MultiStep e e'
</html:code></html:pre><html:p>Let's also define a small helper syntax and macro to make it easier to write arithmetic expressions:</html:p>
  
<fr:tree show-metadata="false" expanded="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="A small arithmetic expression grammar">A small arithmetic expression grammar</fr:title></fr:frontmatter><fr:mainmatter><html:pre class="code-block language-lean"><html:code class="language-lean">
declare_syntax_cat arithTm

-- atoms
syntax num                      : arithTm
syntax "(" arithTm ")"          : arithTm

-- multiplicative level (higher precedence)
syntax:70 arithTm:70 "*" arithTm:71 : arithTm
syntax:70 arithTm:70 "/" arithTm:71 : arithTm

-- additive level (lower precedence)
syntax:60 arithTm:60 "+" arithTm:61 : arithTm
syntax:60 arithTm:60 "-" arithTm:61 : arithTm

syntax "ex{" arithTm "}" : term

macro_rules
  -- numerals
  | `(ex{ $n:num }) =&gt;
      `(Expr.const $n)

  -- parentheses
  | `(ex{ ($t:arithTm) }) =&gt;
      `(ex{$t})

  -- addition
  | `(ex{ $e₁:arithTm + $e₂:arithTm }) =&gt;
      `(Expr.binop BinOp.add (ex{$e₁}) (ex{$e₂}))

  -- subtraction
  | `(ex{ $e₁:arithTm - $e₂:arithTm }) =&gt;
      `(Expr.binop BinOp.sub (ex{$e₁}) (ex{$e₂}))

  -- multiplication
  | `(ex{ $e₁:arithTm * $e₂:arithTm }) =&gt;
      `(Expr.binop BinOp.mul (ex{$e₁}) (ex{$e₂}))

  -- division
  | `(ex{ $e₁:arithTm / $e₂:arithTm }) =&gt;
      `(Expr.binop BinOp.div (ex{$e₁}) (ex{$e₂}))
  </html:code></html:pre></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Describing arithmetic evaluation">Describing arithmetic evaluation</fr:title></fr:frontmatter><fr:mainmatter><html:p>Now say that we wanted to evaluate the expression <fr:tex display="inline"><![CDATA[((2 * 3) + 4)]]></fr:tex> on a high level what we would do is rewrite the multiplication to <fr:tex display="inline"><![CDATA[6 + 4]]></fr:tex> and then rewrite that to <fr:tex display="inline"><![CDATA[10]]></fr:tex>. Expressing this in lean we have:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  example : -- ((2 * 3) + 4) -&gt;ⁿ 10
  ex{ ((2 * 3) + 4) } -&gt;ⁿ ex{ 10 } :=
    .trans (rw_lhs (rw_const .mul 2 3)) (rw_const .add 6 4)
</html:code></html:pre><html:p>Here we say that the expression <fr:tex display="inline"><![CDATA[((2 * 3) + 4)]]></fr:tex> after multiple steps evaluates to <fr:tex display="inline"><![CDATA[10]]></fr:tex> by first rewriting the left hand side multiplication to <fr:tex display="inline"><![CDATA[6 + 4]]></fr:tex> and then rewriting that to <fr:tex display="inline"><![CDATA[10]]></fr:tex>. And we chain these operations together using the <html:code>.trans</html:code> constructor of the multi-step evaluation relation. Now the question becomes, how do we define these rewrite steps? Intuitively we can imagine evaluation as being described by the following sort of graph</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
 +(lhs [op] rhs) 
 |
 +-+(rw_lhs) -&gt;ⁿ lhs' [op] rhs    (1) reduce lhs some number of steps
   | 
   +-+(rw_rhs) -&gt;ⁿ lhs [op] rhs'  (2) reduce rhs some number of steps
     |
     +- (rw_const) -&gt; value       (3) reduce both to a constant value
</html:code></html:pre><html:p>The idea of each rule being that:</html:p><html:ul><html:li><html:strong>rw_lhs</html:strong>: If the left hand side can be reduced some number of steps we can reduce it while keeping the right hand side the same. This corresponds to the <html:code>ST_BinOp1</html:code> rule defined earlier.</html:li>
  <html:li><html:strong>rw_rhs</html:strong>: If the left hand side is a constant we can reduce the right hand side some number of steps while keeping the left hand side the same. This corresponds to the <html:code>ST_BinOp2</html:code> rule defined earlier.</html:li>
  <html:li><html:strong>rw_const</html:strong>: If both sides are constants we can apply the binary operation and reduce the entire expression to a single constant value. This corresponds to the <html:code>ST_BinOpConst</html:code> rule defined earlier.</html:li></html:ul><html:p>As these rules are defined over the structure of multi-step evaluation our implementation of them will naturally be in terms of the inductive structure of a multistep relationship:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
lemma rw_lhs (lhs_rw : lhs -&gt;ⁿ lhs') :
  (lhs [op] rhs) -&gt;ⁿ (lhs' [op] rhs) :=
match lhs_rw with
| .refl       =&gt; .refl
| .tail S₁ S₂ =&gt; (rw_lhs S₁).tail (.ST_BinOp1 S₂)

lemma rw_rhs (rhs_rw : rhs -&gt;ⁿ rhs') :
  ((.const lhs) [op] rhs) -&gt;ⁿ ((.const lhs) [op] rhs') :=
match rhs_rw with
| .refl       =&gt; .refl
| .tail S₁ S₂ =&gt; (rw_rhs S₁).tail (.ST_BinOp2 S₂)

lemma rw_const (op : BinOp) (lhs rhs : Nat) :
  ((.const lhs) [op] (.const rhs)) -&gt;ⁿ .const (eval_op op lhs rhs) :=
.single (.ST_BinOpConst op lhs rhs)
</html:code></html:pre><html:p>Alternatively we can specify the left and right rewrite rules using the recursor or or head induction principle for multi-step evaluation:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
lemma rw_rhs' (rhs_rw : rhs -&gt;ⁿ rhs') :
  ((.const lhs) [op] rhs) -&gt;ⁿ ((.const lhs) [op] rhs') :=
.rec
  (refl := .refl)
  (tail := by
    intro _ _ _ hcb ih
    exact ih.tail (.ST_BinOp2 hcb)
  ) rhs_rw

lemma rw_rhs'' (rhs_rw : rhs -&gt;ⁿ rhs') :
  ((.const lhs) [op] rhs) -&gt;ⁿ ((.const lhs) [op] rhs') :=
.head_induction_on
  (refl := .refl)
  (head := by
    intro _ _ hac _ ih
    exact ih.head (.ST_BinOp2 hac)
  ) rhs_rw
</html:code></html:pre><html:p>The motive function here is inferred by Lean via the Lemma, which allos us to avoid having to explicitly specify it. Other then this we can see that the recursors again simply correspond to providing methods to describe what to do for each of the constructors.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Recursors describe usage">Recursors describe usage</fr:title></fr:frontmatter><fr:mainmatter><html:p>So at this point you might I think fairly ask yourself:</html:p><html:blockquote>
  Wait why are you spending so much time on this random example for recursors?
</html:blockquote><html:p>The main reason is that to me it provides one of the most grounded direct examples of what it means for a recursor function to <html:em>eliminate</html:em> a term of an inductive type. In general in type theory we say that <html:em>term elimination</html:em> represents the natural deduction rules for <html:em>how to use</html:em> terms of a given type. Applied to our example we can see that these recursors precisely correspond to the rules of how we evaluate i.e. <html:em>use</html:em> arithmetic expressions.</html:p><html:p>Each rewrite rule describes how we can take an expression and reduce it step by step until we reach a final value. So in a sense the recursor here <html:em>eliminates</html:em> the expression by providing a systematic way to break it down into its constituent parts and evaluate it. This is precisely the essence of what recursors do in type theory; they provide a way to systematically deconstruct and utilize terms of inductive types according to their defined structure and properties.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Proving correct evaluation">Proving correct evaluation</fr:title></fr:frontmatter><fr:mainmatter><html:p>One of the wonderful things we then naturally get from these recusors is that we can use them to describe how a correct evaluation works. So given our evaluation function:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
@[simp]
def eval : Expr -&gt; Nat
  | Expr.const n =&gt; n
  | Expr.binop op e₁ e₂ =&gt;
      let v₁ := eval e₁
      let v₂ := eval e₂
      eval_op op v₁ v₂
</html:code></html:pre><html:p>We can use the recursors describing the rewrite rules to show that this evaluation function for our expressions both yields a constant and that we have some sequence of reduction steps (application of rewrite rules) to get to said constant. Or expressed formally:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  (e : Expr) : -- for any expression e
    (∃ v : Nat), -- there exists a value v
      (eval e = v) ∧ (e -&gt;ⁿ (.const v))
      -- such that eval e = v and e reduces to the constant v
</html:code></html:pre><html:p>The proof of this statement works by induction on the structure of the expression <html:code>e</html:code> if our expression represents a constant then the proof is trivial as we can just take the value of the constant itself. If our expression represents a binary operation then same as we showed for the concrete example we just apply our recursors to first rewrite the lhs, then the rhs and finally apply the operation to get the final constant value. In full the proof looks like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  theorem eval_correct (e : Expr) :
  ∃ v : Nat, (eval e = v) ∧ (e -&gt;ⁿ (.const v)) := by
  induction e with
  | const n =&gt; exists n
  | binop op lhs rhs eval_lhs eval_rhs =&gt;
    rcases eval_lhs with ⟨lhs_v, ⟨rhs_is_v, lhs_rw⟩⟩
    rcases eval_rhs with ⟨rhs_v, ⟨lhs_is_v, rhs_rw⟩⟩
    simp [rhs_is_v, lhs_is_v]

    exact
      (rw_lhs lhs_rw).trans (
        (rw_rhs rhs_rw).trans (
          rw_const op lhs_v rhs_v
        )
      )
</html:code></html:pre><html:p>In other words our proof for describing that our evaluation function is correct amounts to essentially simulating or describing quite literally how the evaluation works step by step using the recursors we defined earlier. To see precisely how <html:code>rcases</html:code> works here I'd recommend to paste the code into a Lean environment and examine the types of each of the intermediate values.</html:p></fr:mainmatter></fr:tree></fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>28</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/002r/</fr:uri>
                <fr:display-uri>002r</fr:display-uri>
                <fr:route>/notes/002r/</fr:route>
                <fr:title text="Type universes in Lean4">Type universes in Lean4</fr:title>
                <fr:taxon>Blog</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="A brief overview">A brief overview</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Universe hierarchy">Universe hierarchy</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>In Lean4, types are organized into a hierarchy of <html:em>universes</html:em> (also referred to as <html:em>sorts</html:em>). Each universe is assoicated with a <html:em>level</html:em>, which is a natural number. The <fr:tex display="inline"><![CDATA[\texttt {Sort}]]></fr:tex> operator constructs a universe from a given level. To avoid things like Girard's paradox, Lean4 employs a stratified type system where each universe can only contain types from lower universes, we have the following hierarchy <fr:link href="/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" title="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)" uri="https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" display-uri="baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024" type="local">(1)</fr:link>:</html:p><fr:tex display="block"><![CDATA[
    \begin {align*}
    \texttt {Prop} : \texttt {Type 0} : \texttt {Type 1} : \texttt {Type 2} : \cdots  \\
    \texttt {Sort 0} : \texttt {Sort 1} : \texttt {Sort 2} : \texttt {Sort 3} : \cdots 
    \end {align*}
  ]]></fr:tex><html:p><fr:tex display="inline"><![CDATA[\texttt {Sort}]]></fr:tex> has two main aliases used in Lean4: <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex>. Here, <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> (which is equivalent to <fr:tex display="inline"><![CDATA[\texttt {Sort 0}]]></fr:tex>) is the universe of logical propositions, while <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex> (which is equivalent to <fr:tex display="inline"><![CDATA[\texttt {Sort (u + 1)}]]></fr:tex>) represents a universe of types at level <fr:tex display="inline"><![CDATA[u]]></fr:tex>. So we can say:</html:p><fr:tex display="block"><![CDATA[
    \texttt {Type u} \equiv  \texttt {Sort (u + 1)}
  ]]></fr:tex><fr:tex display="block"><![CDATA[
    \texttt {Prop} \equiv  \texttt {Sort 0}
  ]]></fr:tex><html:p>In general we can express the hierarchy for any universe level <fr:tex display="inline"><![CDATA[u]]></fr:tex> as follows:</html:p>
  
    
    <fr:resource hash="d22c345c7afa48bf314e21f040d4332e"><fr:resource-content><html:img src="/notes/d22c345c7afa48bf314e21f040d4332e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule *[right=Sort]{
    }{
      \Gamma  \vdash  \texttt {Sort u} : \texttt {Sort (u + 1)}
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Predicative universes">Predicative universes</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>With the exception of propositions, a type in a universe at level <fr:tex display="inline"><![CDATA[u]]></fr:tex> cannot quantify over types from strictly larger universes unless the whole result is lifted to a larger universe. In the case of types we have:</html:p>
  
    
    <fr:resource hash="d764c9e89e1a835ed3d018e580fe27b4"><fr:resource-content><html:img src="/notes/d764c9e89e1a835ed3d018e580fe27b4.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=ArrowType]{
        \Gamma  \vdash  \sigma  : \texttt {Type u} \\
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Type v}
      }{
        \Gamma  \vdash  (x : \sigma ) \to  \tau [x] : \texttt {Type (max u v)}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>To demonstrate some valid instance of this inference rule lets consider the following lean examples:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
      example (α : Type 1) (β : Type 2) : Type 2 := α → β
      example (α : Type 2) (β : Type 1) : Type 2 := α → β
    </html:code></html:pre><html:p>Both of the above examples are valid because the resulting type is lifted to the maximum universe level of the input types. In general we say that the behavior of the <fr:tex display="inline"><![CDATA[\texttt {Type}]]></fr:tex> universes is called <html:strong>predicative</html:strong> meaning that objects <html:em>may not</html:em> be defined in terms of quantifiers ranging over that same object.</html:p></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Impredicative universes">Impredicative universes</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>We can observe that a function type's universe is determined by the universes of its argument and return types. However, in the case of propositions we have a different behavior:</html:p>
  
    
    <fr:resource hash="120b65d6f240b5db99f27acc7a668d16"><fr:resource-content><html:img src="/notes/120b65d6f240b5db99f27acc7a668d16.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=ArrowProp]{
        \Gamma  \vdash  \sigma  : \texttt {Sort u} \\ 
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Prop}
      }{
        \Gamma  \vdash  (\forall  x : \sigma , \tau [x]) : \texttt {Prop}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Predicates, which are functions that return propositions, may have argument types in any universe, but the function itself remains in the <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> universe. This behavior is called <html:strong>impredicative</html:strong> meaning that objects <html:em>may</html:em> be defined in terms of quantifiers ranging over that same object. The rule <fr:tex display="inline"><![CDATA[\textsc {ArrowProp}]]></fr:tex> means that expressions such <fr:tex display="inline"><![CDATA[\forall  a : \texttt {Prop}, a \to  a]]></fr:tex>, which quantify over all propositions (including themselves), yield a proposition, that is:</html:p><fr:tex display="block"><![CDATA[
      (\forall  a : \texttt {Prop},\ a \to  a) : \texttt {Prop}
    ]]></fr:tex><html:p>We can see some more examples of quantifying both over propositions and types as follows:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
      /-- Quantifying over propositions yields a proposition -/
      example : Prop := ∀ (P : Prop) (p1 p2 : P), p1 = p2

      /-- Proposition quantifying over all type stays in Prop -/
      example : Prop := ∀ (α : Type), ∀ (x : α), x = x
      example : Prop := ∀ (α : Type 5), ∀ (x : α), x = x
    </html:code></html:pre></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="The general rule">The general rule</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>We can combine these two rules to get a more general rule for function types that return types in any universe:</html:p>
  
    
    <fr:resource hash="bc08812524e6a16f5f31653540c8a6e2"><fr:resource-content><html:img src="/notes/bc08812524e6a16f5f31653540c8a6e2.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=Arrow]{
        \Gamma  \vdash  \sigma  : \texttt {Sort u} \\ 
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Sort v}
      }{
        \Gamma  \vdash  (x : \sigma ) \to  \tau [x] : \texttt {Sort (imax u v)}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Here the function type's universe is determined by the (impredicative max) <html:strong>imax</html:strong> of the universes of its argument and return types, where <fr:tex display="inline"><![CDATA[\texttt {imax}]]></fr:tex> is defined as follows:</html:p><fr:tex display="block"><![CDATA[
      \texttt {imax}(u, v) = \begin {cases}
        0 & \text {if } v = 0 \\
        \texttt {max}(u, v) & \text {otherwise}
      \end {cases}
    ]]></fr:tex></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="The level grammar">The level grammar</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We can describe the level grammar via the following inductive type:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      inductive Level
      | zero : Level
      | succ : Level → Level
      | max  : Level → Level → Level
      | imax : Level → Level → Level
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Universe Binding">Universe Binding</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Explicit">Explicit</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We can define functions and types that are <html:strong>universe polymorphic</html:strong> by introducing universe levels either <html:em>explicitly</html:em> or <html:em>implicitly</html:em>. An explicit universe level is specified directly in the definition, while an implicit universe level is inferred by Lean4. For example:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
        /-- Explicit universe level -/
        def map.{u v} {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β :=
          | []       =&gt; []
          | x :: xs  =&gt; f x :: map f xs
      </html:code>
                        </html:pre>
                        <html:p>Here the map is declared with explicit universe levels <fr:tex display="inline"><![CDATA[u]]></fr:tex> and <fr:tex display="inline"><![CDATA[v]]></fr:tex> and instantiates the polymorphic <fr:tex display="inline"><![CDATA[\texttt {List}]]></fr:tex>. We can also define the same function with implicit universe levels as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
        universe u v
        def map {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β := ...
      </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Implicit">Implicit</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>By default in Lean4 the option <fr:tex display="inline"><![CDATA[\texttt {autoImplicit}]]></fr:tex> is set to true, meaning that our universe levels will be inferred automatically meaning that we can simply write:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
        def map {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β := ...
      </html:code>
                        </html:pre>
                        <html:p>Importantly automatic implicit paramter inference <html:em>only works</html:em> if the universe is mentioned in the header preceding the assignment, i.e:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
        /-- Bad: unknown universe u -/
        def L := List (Type u)
        /-- Good: universe u mentioned in header -/
        def L.{u} := List (Type u)
      </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Implicit + fresh">Implicit + fresh</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We can also go even further with implicit universes by allowing Lean4 to generate fresh universe levels for us. This is done by omitting the universe annotation and replacing it with a * suffix:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      /-- Fresh implicit universe levels -/
      def map {α : Type*} {β : Type*} 
          (f : α → β) : List α → List β := ...
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Universe Lifting">Universe Lifting</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Sometimes we may want to explicitly  lift a type from one universe to a higher universe. Lean4 provides lifting operators which are wrappers around terms of a type that reside in a higher universe. There are two main lifting operators:</html:p>
                    <html:ul><html:li><fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex>: Lifts a proposition from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> (i.e. <fr:tex display="inline"><![CDATA[\texttt {Sort 1}]]></fr:tex>).</html:li>
    <html:li><fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex>: Lifts a type from <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex> to any number of levels.</html:li></html:ul>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="PLift">PLift</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> operator is used to lift propositions into the first type universe. It is defined as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      structure PLift (α : Sort u) : Type u where
        /-- Wraps a proof/value to increase its type's universe lvl -/
        up ::
        /-- Extracts a wrapped proof/value from a lifted prop/type. -/
        down : α
    </html:code>
                        </html:pre>
                        <html:p>Some simple examples:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      #check False       -- False : Prop
      #check PLift False -- PLift False : Type
      #check Nat         -- Nat : Type
      #check PLift Nat   -- PLift Nat : Type 1

      example : PLift Prop        := PLift.up True
      example : Prop              := (PLift.down (PLift.up False))
      example : List (PLift True) := [.up (by trivial), .up (by decide)]
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="ULift">ULift</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The <fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex> operator is used to lift types to higher universes. It is defined as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      structure ULift.{r, s} (α : Type s) : Type (max s r) where
        /-- Wraps a value to increase its type's universe level. -/
        up ::
        /-- Extracts a wrapped value from a universe-lifted type. -/
        down : α
    </html:code>
                        </html:pre>
                        <html:p>Some simple examples:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      #check Nat               -- Nat : Type
      #check ULift Nat         -- ULift Nat : Type 1
      #check ULift (ULift Nat) -- ULift (ULift Nat) : Type 2

      example : ULift Nat        := ULift.up 42
      example : List (ULift Nat) := [.up 1, .up 2, .up 3]
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Example: Preorder Category">Example: Preorder Category</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <html:em>preorder relation</html:em> is a binary relation that is <html:strong>reflexive</html:strong> and <html:strong>transitive</html:strong>. In Lean this is expressed as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
    class Preorder (α : Type*) extends LE α, LT α where
      le_refl   : ∀ a : α, a ≤ a
      le_trans  : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c
      lt := fun a b =&gt; a ≤ b ∧ ¬b ≤ a
      lt_iff_le_not_ge : ∀ a b : α, a &lt; b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl
  </html:code>
                    </html:pre>
                    <html:p>We can already see here that the preorder relation uses implicit universe polymorphism via the <fr:tex display="inline"><![CDATA[\texttt {Type*}]]></fr:tex> annotation. We can now construct a small category from a preorder relation as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
    open CategoryTheory

    instance {α : Type u} [Preorder α] : SmallCategory α where
      Hom a b          := ULift &lt;| PLift (a ≤ b)
      id a             := .up &lt;| .up &lt;| le_refl a
      comp {a b c} f g := .up &lt;| .up &lt;| (le_trans f.down.down g.down.down)
  </html:code>
                    </html:pre>
                    <html:p>Let's break this down part by part starting with the homomorphisms:</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Arrows">Arrows</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>For the case of the category definition, Lean fundamentally uses quivers to represent the homs between objects. Now before showing how lean defines them let's I think try and do it ourselves. So in this instance in an abstract sense we want the relationship <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> to represent our morphism or arrow between two objects, so in a sense the following two are equivalent:</html:p>
                        <fr:tex display="block"><![CDATA[
      a \leq  b \equiv  a \xrightarrow {\leq } b
    ]]></fr:tex>
                        <html:p>So in the most straightforward sense what we can do is define any kind of "container" to repreesnt our source and target objects under some label, we can define this naively as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      class Graph (Obj : Type) where
        arrow (source : Obj) (target : Obj) : Type
    </html:code>
                        </html:pre>
                        <html:p>Now let's try to define an instance of such a graph on a preorder relation in which our objects simply live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      instance {α : Type} [Preorder α] : Graph α where
        arrow a b := a ≤ b -- arrow from a to b is the relation a ≤ b
    </html:code>
                        </html:pre>
                        <html:p>Here we are declaring an instance, this instance takes
      <html:ul><html:li>An <html:strong>implicit type parameter</html:strong> <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> which is the type of our objects at the universe level 0.</html:li>
          <html:li>A <html:strong>type class constraint</html:strong> <fr:tex display="inline"><![CDATA[\texttt {[Preorder α]}]]></fr:tex> which ensures that the type <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> has a preorder relation defined on it. In other words it guarantees that the relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> is reflexive and transitive for all elements of type <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex>.</html:li></html:ul>
      And we provide the necessary implementation for the <fr:tex display="inline"><![CDATA[\texttt {arrow}]]></fr:tex> function by setting it to be the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>. But what you will notice is that we have a problem here, namely that our preorder relation lives in the universe <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> as its obviously a logical relation, but our graph arrows need to live in <fr:tex display="inline"><![CDATA[\texttt {Type}]]></fr:tex> (i.e. <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>).  
    </html:p>
                        <html:p>A first thought might be to just set the arrow type to be <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> directly, in our definition of the class <fr:tex display="inline"><![CDATA[\texttt {Graph}]]></fr:tex> though this is rather restrictive as it means that any graph we wish to define can only ever have arrows representing propositions, what if we want to have arrows represent other types such as functions or numbers?</html:p>
                        <html:p>One way to approach this is to use the <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> operator to lift our preorder relation from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      instance {α : Type} [Preorder α] : Graph α where
        arrow a b := PLift (a ≤ b) -- lift relation to Type 0
    </html:code>
                        </html:pre>
                        <html:p>While this does work, and often is probably a reasonable way to go about things, much of Lean's mathlib employs universe polymorphic types to define various kinds of structures. Thus parameterising over some universe level <fr:tex display="inline"><![CDATA[u]]></fr:tex> we define our polymorphic instance as:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      instance {α : Type u} [Preorder α] : Graph α where
        arrow a b := PLift (a ≤ b) 
    </html:code>
                        </html:pre>
                        <html:p>But now we naturally run into another issue, namely that the class for our graph is now no longer universe polymorphic which leads to a universe level mismatch. The most straightforward fix here is to simply make the objects in the graph universe polymorphic as well:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      class Graph (Obj : Type u) where -- now polymorphic over u
        arrow (source : Obj) (target : Obj) : Type
    </html:code>
                        </html:pre>
                        <html:p>But this leads to another question, what level should the arrows live in? We've already seen that arrows can represent various different kinds of things different from the types of objects themselves, (e.g. <fr:tex display="inline"><![CDATA[2 \leq  3]]></fr:tex> is a proposition but clearly 2 and 3 are numbers). Now one approach is to simply leave the arrows in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> but this already is mildly annoying as it forces us to lift any arrows that don't naturally live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>. Furthermore we've already seen that having the type stuck at Prop is also not nice, so what we can do is make the arrows universe polymorphic as well, though over a different universe level <fr:tex display="inline"><![CDATA[v]]></fr:tex> motivated by the aforementioned situation of different levels of arrows and objects:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      class Graph (Obj : Type u) where
        arrow (source : Obj) (target : Obj) : Sort v

      instance {α : Type u} [Preorder α] : Graph α where
        arrow a b := a ≤ b -- now lives in Sort 0 (i.e. Prop)
    </html:code>
                        </html:pre>
                        <html:p>But hold up, why are we lifting in the definition of the instance for the SmallCategory? Let's take a look at all the relevant type signatures:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- Quiver 
      -- (V : Type u) where

      -- CategoryStruct
      -- (obj : Type u) : Type max u (v + 1) extends Quiver.{v + 1} obj

      -- Category 
      -- (obj : Type u) : Type max u (v + 1) extends CategoryStruct.{v} obj 

      -- SmallCategory
      -- (obj : Type u) : Type (u + 1) extends Category.{u} obj 
    </html:code>
                        </html:pre>
                        <html:p>Let's break this down step by step starting first with the relationship between CategoryStruct and Quiver, for the sake of simplicitly i'll abstract away some exact names and make all universes explicit:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      variable {α : Type m} [Preorder α] (a b c : α)

      class Box.{u, v} (obj : Type u) where
        pair : obj → obj → Sort v

      class A.{u, v} (obj : Type u) 
        : Type max u (v + 1) extends (Box.{u, v + 1} obj) where
    </html:code>
                        </html:pre>
                        <html:p>I think an interesting question I first had here is with the extension of <fr:tex display="inline"><![CDATA[\texttt {Box}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex> why might you want to increase the universe level of the arrows by one? The main reason this is done in general is to essentially constrain the <fr:tex display="inline"><![CDATA[v]]></fr:tex> to never be zero. The implication of this being that our extended class <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex> can never have any pairs which live in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>.</html:p>
                        <html:p>A good follow up to this might be, why would you not want thigns to live in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>? In the most general sense some of the reasons are:</html:p>
                        <html:ul><html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> is <html:em>proof irrelevant</html:em>: In Lean, propositions are considered proof irrelevant, meaning that all proofs of a given proposition are treated as equal. This can lead to loss of information when you want to be able to distinguish between different morphisms or in our simplified example pairs.</html:li>
      <html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> is <html:em>not computational</html:em>: Propositions in Lean are not computationally relevant, meaning that they do not have computational content. If you want to perform computations or extract algorithms from your morphisms or pairs, having them in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> would prevent that.</html:li>
      <html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> has <html:em>limited structure</html:em>: Propositions in Lean do not have the same rich structure as types in higher universes. If you need to work with morphisms or pairs that have additional structure (like being functions, sets, etc.), you would want them to live in a higher universe.</html:li></html:ul>
                        <html:p>As an example we can consider the following:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- @classname disables universe inference for that class
      variable (a₁ : @A.{m, v} α)
      #check (a₁.pair a b : Sort (v + 1)) -- Box.pair a b : Type v
    </html:code>
                        </html:pre>
                        <html:p>We can see here that the pair now lives in <fr:tex display="inline"><![CDATA[\texttt {Sort (v + 1)}]]></fr:tex>, meaning that if we had <fr:tex display="inline"><![CDATA[v = 0]]></fr:tex> then our pairs would now live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>. A natural byproduct of this choice - having arrows live in <fr:tex display="inline"><![CDATA[\texttt {Sort (v + 1)}]]></fr:tex> - is that the type of the structure itself must now live in the largest universe such that it can contain both the objects and the arrows. This is why we have the type signature <fr:tex display="inline"><![CDATA[\texttt {Type max u (v + 1)}]]></fr:tex> for <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex>. Equivalently we can expand this as:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- since Type u = Sort (u + 1) and Type (v + 1) = Sort (v + 2)
      Sort (max (u + 1) (v + 2)) 
    </html:code>
                        </html:pre>
                        <html:p>If we then create similarly abstract versions for the Category class (B) and SmallCategory class (C) we have:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      class B.{u, v} (obj : Type u) 
        : Type max u (v + 1) extends A.{u, v} obj where

      class C.{u} (obj : Type u) 
        : Type (u + 1) extends B.{u, u} obj where 
      --                        ^ can also type B.{u} (inferres v = u)
    </html:code>
                        </html:pre>
                        <html:p>We can see here that our SmallCategory (C) now constrains the arrows to live in the same universe as the objects by setting <fr:tex display="inline"><![CDATA[v = u]]></fr:tex> in the extension of <fr:tex display="inline"><![CDATA[\texttt {B}]]></fr:tex>. Thus if we construct our pair, we have:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      variable (c : @C.{m} α)
      #check (c.pair a b : Sort (m + 1)) -- Box.pair a b : Type m
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Identity morphism">Identity morphism</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Next up let's look at the identity morphism:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      id a := .up &lt;| .up &lt;| le_refl a
    </html:code>
                        </html:pre>
                        <html:p>The identity is defined as a function that quantifies over all objects <fr:tex display="inline"><![CDATA[a]]></fr:tex> in our category and returns an arrow from <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[a]]></fr:tex>. Naturally we then first want to construct our arrow, the identity arrow from <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[a]]></fr:tex> is simply the reflexivity property of the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>, that is <fr:tex display="inline"><![CDATA[a \leq  a]]></fr:tex> which we can get via <fr:tex display="inline"><![CDATA[\texttt {le\_refl a}]]></fr:tex>. However since our arrows live in <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>, we need to lift our relation twice, first using <fr:tex display="inline"><![CDATA[\texttt {PLift.up}]]></fr:tex> to lift it from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>, and then again using <fr:tex display="inline"><![CDATA[\texttt {ULift.up}]]></fr:tex> to lift it from <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>. A note to make for people unfamiliar with the syntax here, the following pieces of code are equivalent:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- .up &lt;| .up &lt;| le_refl a == ULift.up (PLift.up (le_refl a))
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>28</fr:day>
                        </fr:date>
                        <fr:title text="Composition">Composition</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Finally let's look at the composition of arrows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      comp {a b c} f g := .up &lt;| .up &lt;| (le_trans f.down.down g.down.down)
    </html:code>
                        </html:pre>
                        <html:p>The lifting portion here follows the same reasoning as the identity morphism, we need to lift the resulting relation from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>. The actual composition is done via the transitivity property of the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>. The thing is here that our input arrows <fr:tex display="inline"><![CDATA[f]]></fr:tex> and <fr:tex display="inline"><![CDATA[g]]></fr:tex> are both lifted types corresponding to:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      f : ULift (PLift (a ≤ b))
      g : ULift (PLift (b ≤ c))
    </html:code>
                        </html:pre>
                        <html:p>Thus to extract the actual preorder relations we need to use the <fr:tex display="inline"><![CDATA[\texttt {down}]]></fr:tex> method twice, first to go from <fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex>, and then again to go from <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> to the actual relation in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>. Once we have the two relations extracted we can then apply the transitivity property <fr:tex display="inline"><![CDATA[\texttt {le\_trans}]]></fr:tex> to get the composed relation <fr:tex display="inline"><![CDATA[a \leq  c]]></fr:tex> (which we then lift back up).</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/002u/</fr:uri>
                <fr:display-uri>002u</fr:display-uri>
                <fr:route>/notes/002u/</fr:route>
                <fr:title text="A simple Bool category in Lean4">A simple Bool category in Lean4</fr:title>
                <fr:taxon>Blog</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>27</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/002m/</fr:uri>
                    <fr:display-uri>002m</fr:display-uri>
                    <fr:route>/notes/002m/</fr:route>
                    <fr:title text="Category">Category</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>There are a few ways you can define a <html:em>category</html:em>. In the most basic intuitive sense a category consits of a collection of things called <html:em>objects</html:em> and binary relationships (or transitions) between those objects called <html:em>morphisms</html:em> (or <html:em>arrows</html:em>). We can combine these relationships by <html:em>composing</html:em> them, and for each object there is an <html:em>identity morphism</html:em> that acts as a neutral element for composition. <fr:link href="/notes/nlab-category/" title="category" uri="https://kaierikniermann.github.io/notes/nlab-category/" display-uri="nlab-category" type="local">(1)</fr:link></html:p>
                    <html:p>In the context of <fr:link href="/notes/002l/" title="Quiver" uri="https://kaierikniermann.github.io/notes/002l/" display-uri="002l" type="local"><html:em>quivers</html:em></fr:link> a category can be defined as a quiver with a rule saying for how we can compose two edges that fit together to get a new edge. Furthermore, each vertex (object) has an edge starting and ending at that vertex (the identity morphism) an. The classical definition is something like this:</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>27</fr:day>
                        </fr:date>
                        <fr:title text="The data">The data</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A <html:em>category</html:em> <fr:tex display="inline"><![CDATA[C]]></fr:tex> consits of:</html:p>
                        <html:ul><html:li>A collection (or <html:em>class</html:em> <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(2)</fr:link>) of <html:strong>objects</html:strong>, denoted as <fr:tex display="inline"><![CDATA[\text {Ob}(C)]]></fr:tex> or <fr:tex display="inline"><![CDATA[C_0]]></fr:tex>.</html:li>
  <html:li>A collection (or <html:em>set</html:em> <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(2)</fr:link>) of <html:strong>morphisms</html:strong> (or <html:em>arrows</html:em>), denoted <fr:tex display="inline"><![CDATA[C_1]]></fr:tex> or <fr:tex display="inline"><![CDATA[C(x, y)]]></fr:tex> for <fr:tex display="inline"><![CDATA[x, y \in  \text {Ob}(C)]]></fr:tex>.
    <html:ul><html:li>For every morphism <fr:tex display="inline"><![CDATA[f \in  C(x, y)]]></fr:tex>, there are two associated objects: the <html:em>source</html:em> (or <html:em>domain</html:em>) <fr:tex display="inline"><![CDATA[x]]></fr:tex> and the <html:em>target</html:em> (or <html:em>codomain</html:em>) <fr:tex display="inline"><![CDATA[y]]></fr:tex>. In standard function notation, we write <fr:tex display="inline"><![CDATA[f: x \to  y]]></fr:tex> where <fr:tex display="inline"><![CDATA[x = \text {dom}(f)]]></fr:tex> and <fr:tex display="inline"><![CDATA[y = \text {cod}(f)]]></fr:tex>. NLab has a nice convention where it denotes the source <fr:tex display="inline"><![CDATA[s]]></fr:tex> of a morphism as <fr:tex display="inline"><![CDATA[s(f)]]></fr:tex> and the target <fr:tex display="inline"><![CDATA[t]]></fr:tex> as <fr:tex display="inline"><![CDATA[t(f)]]></fr:tex>.</html:li>
      <html:li>For every pair of morphisms <fr:tex display="inline"><![CDATA[f \in  C(x, y)]]></fr:tex> and <fr:tex display="inline"><![CDATA[g \in  C(y, z)]]></fr:tex> (s.t. <fr:tex display="inline"><![CDATA[t(f) = s(g)]]></fr:tex> i.e. the morphisms type check), there is a <html:strong>composition</html:strong> morphism <fr:tex display="inline"><![CDATA[g \circ  f \in  C(x, z)]]></fr:tex>. Written out we can denote this as:
        <fr:tex display="block"><![CDATA[
          C(x, y) \times  C(y, z) \to  C(x, z)
        ]]></fr:tex>
      in diagramatic order this is often written as <fr:tex display="inline"><![CDATA[f; g]]></fr:tex> we can equivalently use a more graphical notation:
        
 
  
  <html:figure><fr:resource hash="a1b158afe1c13bb548661319fcf84bb4"><fr:resource-content><html:img src="/notes/a1b158afe1c13bb548661319fcf84bb4.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
 
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to AndréC.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
          \[\begin {tikzcd}[column sep=small]
            x && y && z
            \arrow ["f", from=1-1, to=1-3]
            \arrow ["{f;g}", curve={height=-18pt}, from=1-1, to=1-5]
            \arrow ["g", from=1-3, to=1-5]
          \end {tikzcd}\]
        ]]></fr:resource-source></fr:resource></html:figure></html:li>
      <html:li>For every object <fr:tex display="inline"><![CDATA[x \in  \text {Ob}]]></fr:tex> there is an <html:strong>identity morphism</html:strong>:
        <fr:tex display="block"><![CDATA[
          (\text {id}_x : x \to  x) \in  C(x, x)
        ]]></fr:tex></html:li></html:ul>
    Note: Some additional notations for morphisms include <fr:tex display="inline"><![CDATA[\text {hom}(x, y)]]></fr:tex>, <fr:tex display="inline"><![CDATA[\text {hom}_C(x, y)]]></fr:tex> or <fr:tex display="inline"><![CDATA[C_1(x, y)]]></fr:tex>. Additionally people use the notation <fr:tex display="inline"><![CDATA[\text {Mor(C)}]]></fr:tex> to denote the following disjoint union
    <fr:tex display="block"><![CDATA[
      \text {Mor}(C) = \bigsqcup _{x, y \in  \text {Ob}(C)} C(x, y)
    ]]></fr:tex>
    Which just expresses the idea that the collection of all morphisms in a category is made up of the morphisms between each pair of objects.
  </html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>27</fr:day>
                        </fr:date>
                        <fr:title text="The axioms">The axioms</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The above are often called <html:strong>data</html:strong> of a category. In addition to this data, a category must satisfy the following <html:strong>axioms</html:strong> or (<html:em>conditions</html:em>):</html:p>
                        <html:ul><html:li>Morphisms need to be <html:strong>associative</html:strong> which means that for every triple of morphisms <fr:tex display="inline"><![CDATA[f \in  C(w, x)]]></fr:tex>, <fr:tex display="inline"><![CDATA[g \in  C(x, y)]]></fr:tex>, and <fr:tex display="inline"><![CDATA[h \in  C(y, z)]]></fr:tex> the following holds:
    <fr:tex display="block"><![CDATA[
      h \circ  (g \circ  f) = (h \circ  g) \circ  f
    ]]></fr:tex></html:li>
  <html:li>For each morphism <fr:tex display="inline"><![CDATA[f \in  C(x, y)]]></fr:tex> the identity morphisms act as <html:strong>neutral elements</html:strong> for composition:
    <fr:tex display="block"><![CDATA[
      \text {id}_y \circ  f = f = f \circ  \text {id}_x
    ]]></fr:tex>
    This is also known as the <html:em>left</html:em> and <html:em>right</html:em> <html:strong>unit laws</html:strong> or just <html:strong>unity</html:strong> in general.
  </html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>27</fr:day>
                        </fr:date>
                        <fr:title text="Remarks">Remarks</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:ul>
                          <html:li>A category such as the one described above is often also called a 1-category to distinguish it from higher categories such as 2-categories, n-categories.</html:li>
                        </html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>29</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/002s/</fr:uri>
                    <fr:display-uri>002s</fr:display-uri>
                    <fr:route>/notes/002s/</fr:route>
                    <fr:title text="Isomorphism (morphisms)">Isomorphism (morphisms)</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A morphism <fr:tex display="inline"><![CDATA[f : X \to  Y]]></fr:tex> is called an <html:strong>Isomorphism</html:strong> if there exists a morphism <fr:tex display="inline"><![CDATA[g : Y \to  X]]></fr:tex> such that the following hold <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(1)</fr:link>:</html:p>
                    <fr:tex display="block"><![CDATA[
  g \circ  f = 1_X
  \quad 
  f \circ  g = 1_Y
]]></fr:tex>
                    <html:p>Sometimes an isomorphism is also denoted</html:p>
                    <fr:tex display="block"><![CDATA[
  X \xrightarrow {\cong } Y
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>29</fr:day>
                    </fr:date>
                    <fr:title text="The category">The category</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>29</fr:day>
                        </fr:date>
                        <fr:title text="The data">The data</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We want to start off by defining the data of our category. On a high level we want to define a category with two objects, <fr:tex display="inline"><![CDATA[\texttt {true}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex>. Starting with the object representation we have:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      /-- A wrapper type to make a custom category on Bool -/
      structure BoolCat : Type where
        val : Bool
      deriving DecidableEq, Repr

      /-- The two objects -/
      def BoolCat.tt : BoolCat := ⟨true⟩
      def BoolCat.ff : BoolCat := ⟨false⟩
    </html:code>
                        </html:pre>
                        <html:p>Next we want to define the morphisms between these objects. For each pair of objects we express 3 kinds of morphisms: the identity morphism, a morphism from <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {true}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex>from <fr:tex display="inline"><![CDATA[\texttt {true}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex>. We can express this in Lean as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      /-- Morphisms: we allow identity on each, plus iso between them -/
      inductive BCHom : BoolCat → BoolCat → Type
        | id (b : BoolCat) : BCHom b b
        | swap : BCHom BoolCat.tt BoolCat.ff
        | swapInv : BCHom BoolCat.ff BoolCat.tt
    </html:code>
                        </html:pre>
                        <html:p>Formally what this describes is a kind of piecewise function:</html:p>
                        <fr:tex display="block"><![CDATA[
      \text {f}(x, y) =
      \begin {cases}
        1_x &: x \to  x & \texttt {if } x = y \\
        \texttt {swap} &: \text {tt} \to  \text {ff} & \texttt {if } x = \text {tt} \land  y = \text {ff} \\
        \texttt {swapInv} &: \text {ff} \to  \text {tt} & \texttt {if } x = \text {ff} \land  y = \text {tt} 
      \end {cases}
    ]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>29</fr:day>
                        </fr:date>
                        <fr:title text="Composition and Category instance">Composition and Category instance</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Now we have some notion of objects and morphisms between them, we can move on to defining composition of morphisms.</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      def comp : {X Y Z : BoolCat} → BCHom Y Z → BCHom X Y → BCHom X Z
        | _, _, _, id _, f =&gt; f
        | _, _, _, f, id _ =&gt; f
        | _, _, _, swapInv, swap =&gt; id _
        | _, _, _, swap, swapInv =&gt; id _
    </html:code>
                        </html:pre>
                        <html:p>This defines composition by pattern matching on the possible morphism combinations. Note that we have to explicitly handle the cases where we compose <fr:tex display="inline"><![CDATA[\texttt {swap}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {swapInv}]]></fr:tex> to get the identity morphism on the respective objects. To construct our category we have to provide proofs for the category axioms, namely associativity and identity.</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      @[simp] theorem id_comp' {X Y : BoolCat} (f : BCHom X Y) 
          : comp (id Y) f = f := by
        cases f &lt;;&gt; rfl

      @[simp] theorem comp_id' {X Y : BoolCat} (f : BCHom X Y) 
          : comp f (id X) = f := by
        cases f &lt;;&gt; rfl

      theorem assoc'  (f : BCHom W X) (g : BCHom X Y) (h : BCHom Y Z) :
          comp h (comp g f) = comp (comp h g) f := by
        cases f &lt;;&gt; cases g &lt;;&gt; cases h &lt;;&gt; rfl
    </html:code>
                        </html:pre>
                        <html:p>With all this in place we can finally define our category instance:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      instance : Category BoolCat where
        -- The data
        Hom     := BCHom
        id      := BCHom.id
        comp    := fun f g =&gt; BCHom.comp g f

        -- Category laws
        id_comp := fun f     =&gt; BCHom.comp_id' f
        comp_id := fun f     =&gt; BCHom.id_comp' f
        assoc   := fun f g h =&gt; BCHom.assoc' f g h
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>29</fr:day>
                        </fr:date>
                        <fr:title text="Isomorphisms in the Bool category">Isomorphisms in the Bool category</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Since we clearly see that the morphisms <fr:tex display="inline"><![CDATA[\texttt {swap}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {swapInv}]]></fr:tex> are inverses of each other, we can construct an isomorphism between the two objects <fr:tex display="inline"><![CDATA[\texttt {tt}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {ff}]]></fr:tex> as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      def ttFfIso : BoolCat.tt ≅ BoolCat.ff where
        hom := BCHom.swap
        inv := BCHom.swapInv
        hom_inv_id := rfl
        inv_hom_id := rfl
    </html:code>
                        </html:pre>
                        <html:p>We can see that lean uses a similar notation for isomorphisms as we do in our notes, namely the <fr:tex display="inline"><![CDATA[\texttt {≅}]]></fr:tex> symbol between the two objects. We can see that an isomorphism consists of a <fr:tex display="inline"><![CDATA[\texttt {hom}]]></fr:tex> and an <fr:tex display="inline"><![CDATA[\texttt {inv}]]></fr:tex> morphism along with proofs that composing them in either order yields the respective identity morphism. In Lean4 its defined as follows:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      structure Iso {C : Type u} [Category.{v} C] (X Y : C) where
        /-- The forward direction of an isomorphism. -/
        hom : X ⟶ Y
        /-- The backwards direction of an isomorphism. -/
        inv : Y ⟶ X
        /-- Composition is the identity on the source. -/
        hom_inv_id : hom ≫ inv = 𝟙 X := by cat_disch
        /-- Composition, in reverse, is the identity on the target. -/
        inv_hom_id : inv ≫ hom = 𝟙 Y := by cat_disch

      ...

      /-- Notation for an isomorphism in a category. -/
      infixr:10 " ≅ " =&gt; Iso 
    </html:code>
                        </html:pre>
                        <html:p>We can check out some of the properties of our isomorphism like so:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- Verify it's an isomorphism
      #check ttFfIso           -- BoolCat.tt ≅ BoolCat.ff
      #check ttFfIso.hom       -- BoolCat.tt ⟶ BoolCat.ff
      #check ttFfIso.inv       -- BoolCat.ff ⟶ BoolCat.tt
    </html:code>
                        </html:pre>
                        <html:p>Furthermore we can also show the identity isomorphism <fr:tex display="inline"><![CDATA[tt \cong  tt]]></fr:tex>:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- Every object is isomorphic to itself (trivially)
      def ttSelfIso : BoolCat.tt ≅ BoolCat.tt := Iso.refl _

      #check ttSelfIso -- BoolCat.tt ≅ BoolCat.tt
    </html:code>
                        </html:pre>
                        <html:p>Finally for the sake of completeness we can also demonstrate the isomorphism laws in examples as so:</html:p>
                        <html:pre class="code-block language-lean">
                          <html:code class="language-lean">
      -- The isomorphism laws
      example : ttFfIso.hom ≫ ttFfIso.inv = 𝟙 BoolCat.tt 
        := ttFfIso.hom_inv_id

      example : ttFfIso.inv ≫ ttFfIso.hom = 𝟙 BoolCat.ff 
        := ttFfIso.inv_hom_id
    </html:code>
                        </html:pre>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

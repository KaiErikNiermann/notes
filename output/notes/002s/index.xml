<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>11</fr:month>
      <fr:day>29</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/002s/</fr:uri>
    <fr:display-uri>002s</fr:display-uri>
    <fr:route>/notes/002s/</fr:route>
    <fr:title text="Isomorphism (morphisms)">Isomorphism (morphisms)</fr:title>
    <fr:taxon>Definition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>
  A morphism <fr:tex display="inline"><![CDATA[f : X \to  Y]]></fr:tex> is called an <html:strong>Isomorphism</html:strong> if there exists a morphism <fr:tex display="inline"><![CDATA[g : Y \to  X]]></fr:tex> such that the following hold <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(1)</fr:link>:
</html:p>
    <fr:tex display="block"><![CDATA[
  g \circ  f = 1_X
  \quad 
  f \circ  g = 1_Y
]]></fr:tex>
    <html:p>
  Sometimes an isomorphism is also denoted
</html:p>
    <fr:tex display="block"><![CDATA[
  X \xrightarrow {\cong } Y
]]></fr:tex>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>Johnson, Niles, Yau, Donald</fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>6</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/</fr:uri>
            <fr:display-uri>johnson-yau-2d-categories-2020</fr:display-uri>
            <fr:route>/notes/johnson-yau-2d-categories-2020/</fr:route>
            <fr:title text="2-Dimensional Categories">2-Dimensional Categories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">https://arxiv.org/abs/2002.06055v3</fr:meta>
            <fr:meta name="eprint">2002.06055</fr:meta>
            <fr:meta name="ENTRYTYPE">misc</fr:meta>
            <fr:meta name="ID">johnson_yau_2d_categories_2020</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>29</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/002u/</fr:uri>
            <fr:display-uri>002u</fr:display-uri>
            <fr:route>/notes/002u/</fr:route>
            <fr:title text="A simple Bool category in Lean4">A simple Bool category in Lean4</fr:title>
            <fr:taxon>Blog</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>27</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/002m/</fr:uri>
                <fr:display-uri>002m</fr:display-uri>
                <fr:route>/notes/002m/</fr:route>
                <fr:title text="Category">Category</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  There are a few ways you can define a <html:em>category</html:em>. In the most basic intuitive sense a category consists of a collection of things called <html:em>objects</html:em> and binary relationships (or transitions) between those objects called <html:em>morphisms</html:em> (or <html:em>arrows</html:em>). We can combine these relationships by <html:em>composing</html:em> them, and for each object there is an <html:em>identity morphism</html:em> that acts as a neutral element for composition. <fr:link href="/notes/nlab-category/" title="category" uri="https://kaierikniermann.github.io/notes/nlab-category/" display-uri="nlab-category" type="local">(1)</fr:link></html:p>
                <html:p>
  In the context of <fr:link href="/notes/002l/" title="Quiver" uri="https://kaierikniermann.github.io/notes/002l/" display-uri="002l" type="local"><html:em>quivers</html:em></fr:link> a category can be defined as a quiver with a rule saying for how we can compose two edges that fit together to get a new edge. Furthermore, each vertex (object) has an edge starting and ending at that vertex (the identity morphism). The classical definition is something like this:
</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>27</fr:day>
                    </fr:date>
                    <fr:title text="The data">The data</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
    A <html:em>category</html:em> <fr:tex display="inline"><![CDATA[C]]></fr:tex> consists of:
  </html:p>
                    <html:ul><html:li>
      A collection (or <html:em>class</html:em> <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(2)</fr:link>) of <html:strong>objects</html:strong>, denoted as <fr:tex display="inline"><![CDATA[\text {Ob}(C)]]></fr:tex> or <fr:tex display="inline"><![CDATA[C_0]]></fr:tex>.
    </html:li>
    <html:li>
      A collection (or <html:em>set</html:em> <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(2)</fr:link>) of <html:strong>morphisms</html:strong> (or <html:em>arrows</html:em>), denoted <fr:tex display="inline"><![CDATA[C_1]]></fr:tex> or <fr:tex display="inline"><![CDATA[C(x, y)]]></fr:tex> for <fr:tex display="inline"><![CDATA[x, y \in  \text {Ob}(C)]]></fr:tex>.
      <html:ul><html:li>
          For every morphism <fr:tex display="inline"><![CDATA[f \in  C(x, y)]]></fr:tex>, there are two associated objects: the <html:em>source</html:em> (or <html:em>domain</html:em>) <fr:tex display="inline"><![CDATA[x]]></fr:tex> and the <html:em>target</html:em> (or <html:em>co-domain</html:em>) <fr:tex display="inline"><![CDATA[y]]></fr:tex>. In standard function notation, we write <fr:tex display="inline"><![CDATA[f: x \to  y]]></fr:tex> where <fr:tex display="inline"><![CDATA[x = \text {dom}(f)]]></fr:tex> and <fr:tex display="inline"><![CDATA[y = \text {cod}(f)]]></fr:tex>. NLab has a nice convention where it denotes the source <fr:tex display="inline"><![CDATA[s]]></fr:tex> of a morphism as <fr:tex display="inline"><![CDATA[s(f)]]></fr:tex> and the target <fr:tex display="inline"><![CDATA[t]]></fr:tex> as <fr:tex display="inline"><![CDATA[t(f)]]></fr:tex>.
        </html:li>
        <html:li>
          For every pair of morphisms <fr:tex display="inline"><![CDATA[f \in  C(x, y)]]></fr:tex> and <fr:tex display="inline"><![CDATA[g \in  C(y, z)]]></fr:tex> (s.t. <fr:tex display="inline"><![CDATA[t(f) = s(g)]]></fr:tex> i.e. the morphisms type check), there is a <html:strong>composition</html:strong> morphism <fr:tex display="inline"><![CDATA[g \circ  f \in  C(x, z)]]></fr:tex>. Written out we can denote this as:
          <fr:tex display="block"><![CDATA[
            C(x, y) \times  C(y, z) \to  C(x, z)
          ]]></fr:tex>
          in diagrammatic order this is often written as <fr:tex display="inline"><![CDATA[f; g]]></fr:tex> we can equivalently use a more graphical notation:
          
 
  
  <html:figure><fr:resource hash="d8323ce59463aa832587ad5330c42c75"><fr:resource-content><html:img src="/notes/d8323ce59463aa832587ad5330c42c75.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
   % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
  
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to Andr√©C.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
          \[\begin {tikzcd}[column sep=small]
            x && y && z
            \arrow ["f", from=1-1, to=1-3]
            \arrow ["{f;g}", curve={height=-18pt}, from=1-1, to=1-5]
            \arrow ["g", from=1-3, to=1-5]
          \end {tikzcd}\]
        ]]></fr:resource-source></fr:resource></html:figure></html:li>
        <html:li>
          For every object <fr:tex display="inline"><![CDATA[x \in  \text {Ob}]]></fr:tex> there is an <html:strong>identity morphism</html:strong>:
          <fr:tex display="block"><![CDATA[
            (\text {id}_x : x \to  x) \in  C(x, x)
          ]]></fr:tex></html:li></html:ul>
      Note: Some additional notations for morphisms include <fr:tex display="inline"><![CDATA[\text {hom}(x, y)]]></fr:tex>, <fr:tex display="inline"><![CDATA[\text {hom}_C(x, y)]]></fr:tex> or <fr:tex display="inline"><![CDATA[C_1(x, y)]]></fr:tex>. Additionally, people use the notation <fr:tex display="inline"><![CDATA[\text {Mor(C)}]]></fr:tex> to denote the following disjoint union
      <fr:tex display="block"><![CDATA[
        \text {Mor}(C) = \bigsqcup _{x, y \in  \text {Ob}(C)} C(x, y)
      ]]></fr:tex>
      Which just expresses the idea that the collection of all morphisms in a category is made up of the morphisms between each pair of objects.
    </html:li></html:ul>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>27</fr:day>
                    </fr:date>
                    <fr:title text="The axioms">The axioms</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
    The above are often called <html:strong>data</html:strong> of a category. In addition to this data, a category must satisfy the following <html:strong>axioms</html:strong> or (<html:em>conditions</html:em>):
  </html:p>
                    <html:ul><html:li>
      Morphisms need to be <html:strong>associative</html:strong> which means that for every triple of morphisms <fr:tex display="inline"><![CDATA[f \in  C(w, x)]]></fr:tex>, <fr:tex display="inline"><![CDATA[g \in  C(x, y)]]></fr:tex>, and <fr:tex display="inline"><![CDATA[h \in  C(y, z)]]></fr:tex> the following holds:
      <fr:tex display="block"><![CDATA[
        h \circ  (g \circ  f) = (h \circ  g) \circ  f
      ]]></fr:tex></html:li>
    <html:li>
      For each morphism <fr:tex display="inline"><![CDATA[f \in  C(x, y)]]></fr:tex> the identity morphisms act as <html:strong>neutral elements</html:strong> for composition:
      <fr:tex display="block"><![CDATA[
        \text {id}_y \circ  f = f = f \circ  \text {id}_x
      ]]></fr:tex>
      This is also known as the <html:em>left</html:em> and <html:em>right</html:em> <html:strong>unit laws</html:strong> or just <html:strong>unity</html:strong> in general.
    </html:li></html:ul>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>27</fr:day>
                    </fr:date>
                    <fr:title text="Remarks">Remarks</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:ul>
                      <html:li>
      A category such as the one described above is often also called a 1-category to distinguish it from higher categories such as 2-categories, n-categories.
    </html:li>
                    </html:ul>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/002s/</fr:uri>
                <fr:display-uri>002s</fr:display-uri>
                <fr:route>/notes/002s/</fr:route>
                <fr:title text="Isomorphism (morphisms)">Isomorphism (morphisms)</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
  A morphism <fr:tex display="inline"><![CDATA[f : X \to  Y]]></fr:tex> is called an <html:strong>Isomorphism</html:strong> if there exists a morphism <fr:tex display="inline"><![CDATA[g : Y \to  X]]></fr:tex> such that the following hold <fr:link href="/notes/johnson-yau-2d-categories-2020/" title="2-Dimensional Categories" uri="https://kaierikniermann.github.io/notes/johnson-yau-2d-categories-2020/" display-uri="johnson-yau-2d-categories-2020" type="local">(1)</fr:link>:
</html:p>
                <fr:tex display="block"><![CDATA[
  g \circ  f = 1_X
  \quad 
  f \circ  g = 1_Y
]]></fr:tex>
                <html:p>
  Sometimes an isomorphism is also denoted
</html:p>
                <fr:tex display="block"><![CDATA[
  X \xrightarrow {\cong } Y
]]></fr:tex>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:title text="The category">The category</fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>29</fr:day>
                    </fr:date>
                    <fr:title text="The data">The data</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
      We want to start off by defining the data of our category. On a high level we want to define a category with two objects, <fr:tex display="inline"><![CDATA[\texttt {true}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex>. Starting with the object representation we have:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      /-- A wrapper type to make a custom category on Bool -/
      structure BoolCat : Type where
        val : Bool
      deriving DecidableEq, Repr

      /-- The two objects -/
      def BoolCat.tt : BoolCat := ‚ü®true‚ü©
      def BoolCat.ff : BoolCat := ‚ü®false‚ü©
    </html:code>
                    </html:pre>
                    <html:p>
      Next we want to define the morphisms between these objects. For each pair of objects we express 3 kinds of morphisms: the identity morphism, a morphism from <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {true}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex>from <fr:tex display="inline"><![CDATA[\texttt {true}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {false}]]></fr:tex>. We can express this in Lean as follows:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      /-- Morphisms: we allow identity on each, plus iso between them -/
      inductive BCHom : BoolCat ‚Üí BoolCat ‚Üí Type
        | id (b : BoolCat) : BCHom b b
        | swap : BCHom BoolCat.tt BoolCat.ff
        | swapInv : BCHom BoolCat.ff BoolCat.tt
    </html:code>
                    </html:pre>
                    <html:p>
      Formally what this describes is a kind of piecewise function:
    </html:p>
                    <fr:tex display="block"><![CDATA[
      \text {f}(x, y) =
      \begin {cases}
      1_x &: x \to  x & \texttt {if } x = y \\
      \texttt {swap} &: \text {tt} \to  \text {ff} & \texttt {if } x = \text {tt} \land  y = \text {ff} \\
      \texttt {swapInv} &: \text {ff} \to  \text {tt} & \texttt {if } x = \text {ff} \land  y = \text {tt}
      \end {cases}
    ]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>29</fr:day>
                    </fr:date>
                    <fr:title text="Composition and Category instance">Composition and Category instance</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
      Now we have some notion of objects and morphisms between them, we can move on to defining composition of morphisms.
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      def comp : {X Y Z : BoolCat} ‚Üí BCHom Y Z ‚Üí BCHom X Y ‚Üí BCHom X Z
        | _, _, _, id _, f =&gt; f
        | _, _, _, f, id _ =&gt; f
        | _, _, _, swapInv, swap =&gt; id _
        | _, _, _, swap, swapInv =&gt; id _
    </html:code>
                    </html:pre>
                    <html:p>
      This defines composition by pattern matching on the possible morphism combinations. Note that we have to explicitly handle the cases where we compose <fr:tex display="inline"><![CDATA[\texttt {swap}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {swapInv}]]></fr:tex> to get the identity morphism on the respective objects. To construct our category we have to provide proofs for the category axioms, namely associativity and identity.
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      @[simp] theorem id_comp' {X Y : BoolCat} (f : BCHom X Y) 
          : comp (id Y) f = f := by
        cases f &lt;;&gt; rfl

      @[simp] theorem comp_id' {X Y : BoolCat} (f : BCHom X Y) 
          : comp f (id X) = f := by
        cases f &lt;;&gt; rfl

      theorem assoc'  (f : BCHom W X) (g : BCHom X Y) (h : BCHom Y Z) :
          comp h (comp g f) = comp (comp h g) f := by
        cases f &lt;;&gt; cases g &lt;;&gt; cases h &lt;;&gt; rfl
    </html:code>
                    </html:pre>
                    <html:p>
      With all this in place we can finally define our category instance:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      instance : Category BoolCat where
        -- The data
        Hom     := BCHom
        id      := BCHom. id
        comp    := fun f g =&gt; BCHom. comp g f

        -- Category laws
        id_comp := fun f     =&gt; BCHom.comp_id' f
        comp_id := fun f     =&gt; BCHom.id_comp' f
        assoc   := fun f g h =&gt; BCHom.assoc' f g h
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>29</fr:day>
                    </fr:date>
                    <fr:title text="Isomorphisms in the Bool category">Isomorphisms in the Bool category</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
      Since we clearly see that the morphisms <fr:tex display="inline"><![CDATA[\texttt {swap}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {swapInv}]]></fr:tex> are inverses of each other, we can construct an isomorphism between the two objects <fr:tex display="inline"><![CDATA[\texttt {tt}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {ff}]]></fr:tex> as follows:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      def ttFfIso : BoolCat.tt ‚âÖ BoolCat.ff where
        hom := BCHom.swap
        inv := BCHom.swapInv
        hom_inv_id := rfl
        inv_hom_id := rfl
    </html:code>
                    </html:pre>
                    <html:p>
      We can see that lean uses a similar notation for isomorphism as we do in our notes, namely the <fr:tex display="inline"><![CDATA[\texttt {‚âÖ}]]></fr:tex> symbol between the two objects. We can see that an isomorphism consists of a <fr:tex display="inline"><![CDATA[\texttt {hom}]]></fr:tex> and an <fr:tex display="inline"><![CDATA[\texttt {inv}]]></fr:tex> morphism along with proofs that composing them in either order yields the respective identity morphism. In Lean4 its defined as follows:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      structure Iso {C : Type u} [Category.{v} C] (X Y : C) where
        /-- The forward direction of an isomorphism. -/
        hom : X ‚ü∂ Y
        /-- The backwards direction of an isomorphism. -/
        inv : Y ‚ü∂ X
        /-- Composition is the identity on the source. -/
        hom_inv_id : hom ‚â´ inv = ùüô X := by cat_disch
        /-- Composition, in reverse, is the identity on the target. -/
        inv_hom_id : inv ‚â´ hom = ùüô Y := by cat_disch

      ...

      /-- Notation for an isomorphism in a category. -/
      infixr:10 " ‚âÖ " =&gt; Iso 
    </html:code>
                    </html:pre>
                    <html:p>
      We can check out some properties of our isomorphism like so:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- Verify it's an isomorphism
      #check ttFfIso           -- BoolCat.tt ‚âÖ BoolCat.ff
      #check ttFfIso.hom       -- BoolCat.tt ‚ü∂ BoolCat.ff
      #check ttFfIso.inv       -- BoolCat.ff ‚ü∂ BoolCat.tt
    </html:code>
                    </html:pre>
                    <html:p>
      Furthermore we can also show the identity isomorphism <fr:tex display="inline"><![CDATA[tt \cong  tt]]></fr:tex>:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- Every object is isomorphic to itself (trivially)
      def ttSelfIso : BoolCat.tt ‚âÖ BoolCat.tt := Iso.refl _

      #check ttSelfIso -- BoolCat.tt ‚âÖ BoolCat.tt
    </html:code>
                    </html:pre>
                    <html:p>
      Finally for the sake of completeness we can also demonstrate the isomorphism laws in examples as so:
    </html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- The isomorphism laws
      example : ttFfIso.hom ‚â´ ttFfIso.inv = ùüô BoolCat.tt 
        := ttFfIso.hom_inv_id

      example : ttFfIso.inv ‚â´ ttFfIso.hom = ùüô BoolCat.ff 
        := ttFfIso.inv_hom_id
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>30</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/002w/</fr:uri>
            <fr:display-uri>002w</fr:display-uri>
            <fr:route>/notes/002w/</fr:route>
            <fr:title text="Full and faithful functors">Full and faithful functors</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  We consider a <fr:link href="/notes/002v/" title="Functor" uri="https://kaierikniermann.github.io/notes/002v/" display-uri="002v" type="local">functor</fr:link> between two <fr:link href="/notes/002o/" title="(Essentially/Locally) small categories" uri="https://kaierikniermann.github.io/notes/002o/" display-uri="002o" type="local">(locally small)</fr:link> categories <fr:tex display="inline"><![CDATA[F : C \to  D]]></fr:tex>. For each pair of objects <fr:tex display="inline"><![CDATA[X, Y \in  \mathrm {Ob}(C)]]></fr:tex> the functor induces a function between hom-sets:
</html:p>
            <fr:tex display="block"><![CDATA[
    F_{X, Y} : C(X, Y) \to  D(F(X), F(Y))
  ]]></fr:tex>
            <html:p>

    We can describe functors based on the properties of these induced functions as follows:
  </html:p>
            <html:ul><html:li>
      The functor <fr:tex display="inline"><![CDATA[F]]></fr:tex> is called <html:strong>faithful</html:strong> if for every pair of objects <fr:tex display="inline"><![CDATA[X, Y \in  \mathrm {Ob}(C)]]></fr:tex> the function <fr:tex display="inline"><![CDATA[F_{X, Y}]]></fr:tex> is injective. We can also denote this as:
<fr:tex display="block"><![CDATA[
  (x \xrightarrow {f} y) \mapsto  (F(x) \xrightarrow {F(f)} F(y))
]]></fr:tex>
or using the notation of an embedding as:
<fr:tex display="block"><![CDATA[
        C(X, Y) \hookrightarrow  D(F(X), F(Y))
      ]]></fr:tex>
      An important note to make here is that a faithful functor only presereves distinctness of morphisms, so what this means is that:
      <html:blockquote>

        no two different arrows with the same domain and codomain in <fr:tex display="inline"><![CDATA[C]]></fr:tex> are mapped to (or get identified by) the same arrow in <fr:tex display="inline"><![CDATA[D]]></fr:tex></html:blockquote>
      It <html:strong>does not</html:strong> say
      <html:ul><html:li>

          different objects in <fr:tex display="inline"><![CDATA[C]]></fr:tex> are mapped to different objects in <fr:tex display="inline"><![CDATA[D]]></fr:tex>.
        </html:li>
        <html:li>

          two morphisms with different domains/codomains in <fr:tex display="inline"><![CDATA[C]]></fr:tex> are mapped to different morphisms in <fr:tex display="inline"><![CDATA[D]]></fr:tex>.
        </html:li></html:ul>
      So in a diagrammatic sense a faithful functor essentially guarantees this:
      
 
  
  <html:figure><html:a href="https://q.uiver.app/#q=WzAsNCxbMCwyLCJYIl0sWzIsMiwiWSJdLFsxLDAsIkYoWCkiXSxbMywwLCJGKFkpIl0sWzAsMSwiZiIsMCx7ImN1cnZlIjotM31dLFswLDEsImciLDAseyJjdXJ2ZSI6M31dLFsyLDMsIkYoZikiLDAseyJjdXJ2ZSI6LTN9XSxbMiwzLCJGKGcpIiwwLHsiY3VydmUiOjN9XSxbMSwzLCIiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwyLCIiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbNSw3LCIiLDAseyJzaG9ydGVuIjp7InNvdXJjZSI6MjAsInRhcmdldCI6MjB9LCJsZXZlbCI6MSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzQsNiwiIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwibGV2ZWwiOjEsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ==" target="_blank" class="quiver-link">
    <fr:resource hash="5b9e5f3e38d50a3379b87a54a1f4738c"><fr:resource-content><html:img src="/notes/5b9e5f3e38d50a3379b87a54a1f4738c.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
   % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
  
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to Andr√©C.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \[\begin {tikzcd}
          & {F(X)} && {F(Y)} \\
          \\
          X && Y
          \arrow [""{name=0, anchor=center, inner sep=0}, "{F(f)}", curve={height=-18pt}, from=1-2, to=1-4]
          \arrow [""{name=1, anchor=center, inner sep=0}, "{F(g)}", curve={height=18pt}, from=1-2, to=1-4]
          \arrow [dashed, from=3-1, to=1-2]
          \arrow [""{name=2, anchor=center, inner sep=0}, "f", curve={height=-18pt}, from=3-1, to=3-3]
          \arrow [""{name=3, anchor=center, inner sep=0}, "g", curve={height=18pt}, from=3-1, to=3-3]
          \arrow [dashed, from=3-3, to=1-4]
          \arrow [between={0.2}{0.8}, dashed, from=3, to=1]
          \arrow [between={0.2}{0.8}, dashed, from=2, to=0]
          \end {tikzcd}\]
  ]]></fr:resource-source></fr:resource>
   </html:a></html:figure>
 

      <html:li>
        The functor <fr:tex display="inline"><![CDATA[F]]></fr:tex> is called <html:strong>full</html:strong> if for every pair of objects <fr:tex display="inline"><![CDATA[X, Y \in  \mathrm {Ob}(C)]]></fr:tex> the function <fr:tex display="inline"><![CDATA[F_{X, Y}]]></fr:tex> is surjective. Likewise here its important to note that
        <html:blockquote>
          a full functor only guarantees that any morphism between two objects in the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex> comes from a morphism in <fr:tex display="inline"><![CDATA[C]]></fr:tex></html:blockquote>
        It <html:strong>does not</html:strong> say
        <html:ul><html:li>
            every object in <fr:tex display="inline"><![CDATA[D]]></fr:tex> is in the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex>. In other words objects in <fr:tex display="inline"><![CDATA[D]]></fr:tex> outside the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex> may not have any preimage in <fr:tex display="inline"><![CDATA[C]]></fr:tex>.
          </html:li>
          <html:li>

            every morphism with a domain/codomain outside the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex> comes from a morphism in <fr:tex display="inline"><![CDATA[C]]></fr:tex>. Similarly morphisms between objects in the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex> may not have a preimage in <fr:tex display="inline"><![CDATA[C]]></fr:tex>.
          </html:li></html:ul>
        We can again demonstrate this diagrammatically as follows:
        
 
  
  <html:figure><fr:resource hash="003b56849dff35fb61d9f02cf7874d94"><fr:resource-content><html:img src="/notes/003b56849dff35fb61d9f02cf7874d94.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
   % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
  
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to Andr√©C.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
          \[\begin {tikzcd}
            && {F(X)} && {F(Y)} \\
            \\
            X && Y
            \arrow [""{name=0, anchor=center, inner sep=0}, "{F(f)}", from=1-3, to=1-5]
            \arrow [dashed, from=3-1, to=1-3]
            \arrow [""{name=1, anchor=center, inner sep=0}, "f", from=3-1, to=3-3]
            \arrow [dashed, from=3-3, to=1-5]
            \arrow [between={0.2}{0.8}, dashed, from=1, to=0]
            \end {tikzcd}\]
  ]]></fr:resource-source></fr:resource></html:figure>
 

        The main idea being that a full functor only guarantees that if we have some arrow between two objects in the image (application) of <fr:tex display="inline"><![CDATA[F]]></fr:tex> then there exists some preimage arrow in <fr:tex display="inline"><![CDATA[C]]></fr:tex> that maps to it. But we can have objects and morphisms outside the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex> that do not have any preimage in <fr:tex display="inline"><![CDATA[C]]></fr:tex>.
      </html:li>
      In other words it <html:strong>does not mean</html:strong> the functor is <html:em>surjective on objects</html:em> or <html:em>morphisms</html:em> in general.
    </html:li>

    <html:li>

      The functor <fr:tex display="inline"><![CDATA[F]]></fr:tex> is called <html:strong>fully faithful</html:strong> if for every pair of objects <fr:tex display="inline"><![CDATA[X, Y \in  \mathrm {Ob}(C)]]></fr:tex> the function <fr:tex display="inline"><![CDATA[F_{X, Y}]]></fr:tex> is bijective. We say that a fully faithful functor is necessarily injective on objects up to <fr:link href="/notes/002s/" title="Isomorphism (morphisms)" uri="https://kaierikniermann.github.io/notes/002s/" display-uri="002s" type="local">isomorphism</fr:link>, that is assuming <fr:tex display="inline"><![CDATA[F]]></fr:tex> is fully faithful then we have:
<fr:tex display="block"><![CDATA[
  F(X) \cong  F(Y) \implies  X \cong  Y
]]></fr:tex>
This means that if two objects in the image of <fr:tex display="inline"><![CDATA[F]]></fr:tex> are isomorphic then their preimages in <fr:tex display="inline"><![CDATA[C]]></fr:tex> must also be isomorphic. In other words what this means is that a fully faithful functor preserves distinctness of objects up to the point of being the same for all practical purposes (i.e. isomorphism).
</html:li></html:ul>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

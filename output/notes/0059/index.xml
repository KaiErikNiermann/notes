<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>19</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/0059/</fr:uri>
    <fr:display-uri>0059</fr:display-uri>
    <fr:route>/notes/0059/</fr:route>
    <fr:title text="Normalizing Horn clauses">Normalizing Horn clauses</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>
  Something of note when dealing with weakets preconditions <fr:link href="/notes/0056/" title="Weakest preconditions and Horn clauses" uri="https://kaierikniermann.github.io/notes/0056/" display-uri="0056" type="local">in terms of horn clauses</fr:link> is that we have to first normalize them to ensure they are in the correct horn format, which is to say we commonly have some horn clause in the form
</html:p>
    <fr:tex display="block"><![CDATA[
  p(e_1, e_2) \land  \ldots  \land  \phi  \to  H(e_3) 
]]></fr:tex>
    <html:p>
  where <fr:tex display="inline"><![CDATA[e_i]]></fr:tex> represents an expression, to normalize these clauses we lift the expressions out of the parameters for the predicates and into the list of conjuncts, i.e.:
</html:p>
    <fr:tex display="block"><![CDATA[
  p(x_1, x_2) \land  x_1 = e_1 \land  x_2 = e_2 \land  x_3 = e_3 \land  \ldots  \land  \phi  \to  H(x_3)
]]></fr:tex>
    <html:p>
  So we create fresh variables <fr:tex display="inline"><![CDATA[x_1, x_2, x_3]]></fr:tex> and assign these to the respective expressions then use them in place of the expressions themselves.
</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/0056/</fr:uri>
            <fr:display-uri>0056</fr:display-uri>
            <fr:route>/notes/0056/</fr:route>
            <fr:title text="Weakest preconditions and Horn clauses"><fr:link href="/notes/004k/" title="Working backwards - weakest precondition" uri="https://kaierikniermann.github.io/notes/004k/" display-uri="004k" type="local">Weakest preconditions</fr:link> and <fr:link href="/notes/004v/" title="Horn clauses - Syntax" uri="https://kaierikniermann.github.io/notes/004v/" display-uri="004v" type="local">Horn clauses</fr:link></fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:title text="A motivating example">A motivating example</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>
    Let's consider the following Hoare triple:
  </html:p><fr:tex display="block"><![CDATA[
    \vdash  \{x > 0\}\ y := x;z := x + y\ \{z > 0\}
  ]]></fr:tex><html:p>
    In order to prove that the triple is valid we would apply the rule of composition (or sequencing)
  </html:p>
  
    
    <fr:resource hash="3f67366c4a3fd44306960755fd1ad232"><fr:resource-content><html:img src="/notes/3f67366c4a3fd44306960755fd1ad232.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule {
      \vdash  \{P\}\ s_1\ \{R\} \\
      \vdash  \{R\}\ s_2\ \{Q\}
    }{
      \vdash  \{P\}\ s_1; s_2\ \{Q\}
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
    We know intuitively that what this means is we have to find an assertion <fr:tex display="inline"><![CDATA[r]]></fr:tex> on the memory state such that 
  </html:p><fr:tex display="block"><![CDATA[
    \vdash  \{x > 0\}\ y := x\ \{r(x, y, z)\} \land  \vdash  \{r(x, y, z)\}\ z := x + y\ \{z > 0\}
  ]]></fr:tex><html:p>
    So the predicate / relation <fr:tex display="inline"><![CDATA[r]]></fr:tex> represents some assertion over the variables in our state <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>. The natural question then becomes what is this predicate? The natural approach that could be taken here is to use the weakest precondition approach.
  </html:p><fr:tex display="block"><![CDATA[
    \begin {align}
      \texttt {wp}(y := x,\ \texttt {wp}(z := x + y,\ z > 0)) &\equiv  \\
      \texttt {wp}(y := x,\ (z > 0)[z \mapsto  x + y]) &\equiv  \\
      \texttt {wp}(y := x,\ x + y > 0)
    \end {align}
  ]]></fr:tex><html:p>
    an equivalent way we can write this is 
  </html:p><fr:tex display="block"><![CDATA[
    \begin {align}
      \forall  \sigma ,\sigma '.\ (x > 0 \land  y = x)(\sigma ) \to  (s_1, \sigma ) \Downarrow  \sigma ' &\to  q(x, y, z)(\sigma ') \\
      \forall  \sigma ,\sigma '.\ (q(x, y, z) \land  z' = x + y) \to  (s_2, \sigma ) \Downarrow  \sigma ' &\to  (z' > 0)(\sigma )
    \end {align}
  ]]></fr:tex><html:p>
    The important observation to make here is that if the Hoare triple is valid, we must have a solution for our relation <fr:tex display="inline"><![CDATA[q(x, y, z)]]></fr:tex>. Since our reasoning is furthermore predicated on the successful execution of the two statements, and we can implicitly assume we are reasoning over memory states let's simplify the above equations.
  </html:p><fr:tex display="block"><![CDATA[
    \begin {align}
      (x > 0 \land  y = x) &\to  q(x, y, z) \\
      (q(x, y, z) \land  z' = x + y) &\to  z' > 0
    \end {align}
  ]]></fr:tex><html:p>
    Now let's see if we can verify our earlier solution <fr:tex display="inline"><![CDATA[q(x, y, z) \triangleq  x + y > 0]]></fr:tex></html:p><fr:tex display="block"><![CDATA[
    \begin {align}
      x > 0 \land  y = x &\to  x + y > 0 \\
      x + y > 0 \land  z' = x + y &\to  z' > 0
    \end {align}
  ]]></fr:tex><html:p>
    Clearly we can see both implications hold thus our earlier solution is indeed valid.
  </html:p></fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:title text="The rules">The rules</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
    We'll enumerate the rules as a list:
  </html:p>
                <html:ul><html:li>
      For <html:em>assignment</html:em>:
      <fr:tex display="block"><![CDATA[
        \texttt {wp}(x := e, p(\overline  x)) \triangleq  p(\overline  x)[x \mapsto  e]
      ]]></fr:tex></html:li>
    <html:li>
      For <html:em>sequential composition</html:em>:
      <fr:tex display="block"><![CDATA[
        \texttt {wp}(s_1;s_2, p(\overline  x)) \triangleq  \texttt {wp}(s_1, \texttt {wp}(s_2, p(\overline  x)))
      ]]></fr:tex></html:li>
    <html:li>
      For <html:em>if statements</html:em>:
      <fr:tex display="block"><![CDATA[
        \texttt {wp}(\texttt {if}\ b\texttt {then}\ s_1\ \texttt {else}\ s_2, p(\overline  x)) \triangleq  q(\overline  x)
      ]]></fr:tex>
      with the constraints 
      <fr:tex display="block"><![CDATA[
        \begin {align}
          q(\overline  x) \land  b &\to  \texttt {wp}(s_1, p(\overline  x)) \\ 
          q(\overline  x) \land  \neg  b &\to  \texttt {wp}(s_2, p(\overline  x))
        \end {align}
      ]]></fr:tex></html:li>
    <html:li>
      For <html:em>while loops</html:em>: 
      <fr:tex display="block"><![CDATA[
        \texttt {wp}(\texttt {while}\ b\ \texttt {do}\ s, p(\overline  x)) \triangleq  q(\overline  x)
      ]]></fr:tex>
      with the constriants
      <fr:tex display="block"><![CDATA[
        \begin {align}
          q(\overline  x) \land  b &\to  \texttt {wp}(s, q(\overline  x)) \\
          q(\overline  x) \land  \neg  b &\to  p(\overline  x)
        \end {align}
      ]]></fr:tex></html:li></html:ul>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

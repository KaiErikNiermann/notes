<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>19</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/005a/</fr:uri>
    <fr:display-uri>005a</fr:display-uri>
    <fr:route>/notes/005a/</fr:route>
    <fr:title text="Verifying Hoare triples with wp horn clauses">Verifying Hoare triples with wp horn clauses</fr:title>
    <fr:taxon>Definition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter><html:p>
  We start off with our usual Hoare triple:
</html:p><fr:tex display="block"><![CDATA[
  \{P\}\ s\ \{Q\}
]]></fr:tex><html:p>
  In the context of Horn clauses the typical idea is that as opposed to <html:em>computing</html:em> the weakest precondition as we have done before we <html:strong>solve</html:strong> for it based off a system of constraints over predicate variables. What this means practically speaking is that we introduce a predicate variable AKA query <fr:tex display="inline"><![CDATA[p(\overline  x)]]></fr:tex>. We then define 
</html:p><fr:tex display="block"><![CDATA[
  \texttt {wp}(s, p(\overline  x)) = p'(\overline  e)
]]></fr:tex><html:p>
  The important observation here is that there are 3 main constraints which emerge from this computation 
</html:p><html:ul><html:li>
    The first is the precondition constraint
    <fr:tex display="block"><![CDATA[
      P \to  p'(\overline  x)
    ]]></fr:tex></html:li>
  <html:li>
    The second is the postcondition constraint, since our weakest precondition computation is based on a synthesized unknown predicate variable we must ensure we can use postcondition weakening to ensure compatibility with our postcondition <fr:tex display="inline"><![CDATA[Q]]></fr:tex>
    <fr:tex display="block"><![CDATA[
      Q \to  p(\overline  x)
    ]]></fr:tex></html:li>
  <html:li>
    Finally we also have our set of constraints generated by the <fr:tex display="inline"><![CDATA[\texttt {wp}]]></fr:tex> computation itself. As a reminder when we talk about <fr:tex display="inline"><![CDATA[\texttt {wp}]]></fr:tex> for the case of horn clauses we are talking about the synthesis of a predicate variable or query characterized by a system of constraints. We can denote this set of constraints as the set of horn clauses <fr:tex display="inline"><![CDATA[\mathcal  C]]></fr:tex>.
  </html:li></html:ul><html:p>
  The idea then is that if our constraints are valid, i.e. the assertions hold for all states <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>, then through consequence so is our hoare triple. Expressed as an inference rule:
</html:p>
  
    
    <fr:resource hash="62cee43673dd15b5c8e9699481039a51"><fr:resource-content><html:img src="/notes/62cee43673dd15b5c8e9699481039a51.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \mprset {flushleft}
  \inferrule {
    \forall  \sigma .\ P(\sigma ) \to  p'(\sigma ) \\\\
    \forall  \sigma .\ p(\sigma ) \to  Q(\sigma ) \\\\
    \forall  \sigma .\ \forall  (C \equiv  A \to  B) \in  \mathcal  C.\ A(\sigma ) \to  B(\sigma )  
  }{
    \vdash  \{P\}\ s\ \{Q\}
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

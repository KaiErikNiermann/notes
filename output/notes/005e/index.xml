<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>22</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/005e/</fr:uri>
    <fr:display-uri>005e</fr:display-uri>
    <fr:route>/notes/005e/</fr:route>
    <fr:title text="Abstract strongest postcondition"><fr:link href="/notes/005d/" title="Abstraction &amp; Concretization function" uri="https://kaierikniermann.github.io/notes/005d/" display-uri="005d" type="local">Abstract</fr:link> strongest postcondition</fr:title>
    <fr:taxon>Definition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="The idea">The idea</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>
    Our usual strongest postcondition can be understood as a mapping from a concrete domain to a concrete domain, i.e.
  </html:p>
        <fr:tex display="block"><![CDATA[
    \begin {align}
      \texttt {sp} : \texttt {Stmt} \times  \texttt {C} \to  C
    \end {align}
  ]]></fr:tex>
        <html:p>
    Where <fr:tex display="inline"><![CDATA[C]]></fr:tex> represents our concrete domain, in the world of program logic this is typically assertions on the state of some memory environment. The idea behind the <html:em>abstract</html:em> <fr:tex display="inline"><![CDATA[\texttt {sp}]]></fr:tex>, is that we have a function
  </html:p>
        <fr:tex display="block"><![CDATA[
    \begin {align}
      \texttt {sp}^\# : \texttt {Stmt} \times  \texttt {A} \to  \texttt {A}
    \end {align}
  ]]></fr:tex>
        <html:p>
    In other words we are considering the strongest postcondition from within the abstract domain. Intuitively this just means that our predicates or assertions on the memory states (or equivalently the set of states we characterize) will be expressed in abstract terms.
  </html:p>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="In more detail">In more detail</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>
    The abstract strongest postcondition, denoted <fr:tex display="inline"><![CDATA[\texttt {sp}^\#]]></fr:tex> or <fr:tex display="inline"><![CDATA[\textrm {post\#}]]></fr:tex> is defined as
  </html:p>
        <fr:tex display="block"><![CDATA[
    \texttt {sp}^\# (s, a) = \alpha  (\texttt {sp}(s, \gamma (a)))
  ]]></fr:tex>
        <html:p>
    Let's explain a bit on how we can derive this, we begin with the idea that for each <fr:tex display="inline"><![CDATA[a \in  A]]></fr:tex> and each statement <fr:tex display="inline"><![CDATA[s]]></fr:tex> we want:
  </html:p>
        <fr:tex display="block"><![CDATA[
    \texttt {sp}(s, \gamma (a)) \subseteq  \gamma (\texttt {sp}^\#(s, a))
  ]]></fr:tex>
        <html:p>
    This expresses <html:strong>soundness</html:strong> in other words, the resulting set of states, generated by concretizing the abstraction <fr:tex display="inline"><![CDATA[a]]></fr:tex> must be contained within the prediction of the abstract transformer predicate <fr:tex display="inline"><![CDATA[\texttt {sp}^\#]]></fr:tex>. Then using the Galois connection we have between <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\gamma ]]></fr:tex></html:p>
        <fr:tex display="block"><![CDATA[
    \forall  a \in  A, c \in  C.\ \alpha (c) \subseteq  a \iff  c \leq  \gamma  (a)
  ]]></fr:tex>
        <html:p>
    which expresses the notion that <fr:tex display="inline"><![CDATA[c]]></fr:tex> is <html:em>approximated</html:em> by <fr:tex display="inline"><![CDATA[a]]></fr:tex>. We can rewrite our earlier soundness condition as:
  </html:p>
        <fr:tex display="block"><![CDATA[
    \alpha (\texttt {sp}(s, \gamma (a))) \sqsubseteq  \texttt {sp}^\# (s, a)
  ]]></fr:tex>
        <html:p>
    two again denote the same conceptual thing that our abstract predicate transformer <fr:tex display="inline"><![CDATA[\texttt {sp}^\#]]></fr:tex> is an over-approximation of the analogous transformer for the concrete domain. As we would preferably like to have the most precise approximation we choose equality. Or stated differently by definition the most precise abstracted approximation of the strongest post-condition we can have for some abstracted state is literally just this state concretized, and the resulting set abstracted. 
  </html:p>
        <fr:tex display="block"><![CDATA[
    \texttt {sp}^\# (s, a) = \alpha (\texttt {sp}(s, \gamma (a)))
  ]]></fr:tex>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:title text="Correctness">Correctness</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>
    The most important property to remember about the abstract strongest post-condition is that if we <html:em>do over-approximate an error state</html:em> it <html:strong>does not</html:strong> allow us to conclude that the program is wrong.
  </html:p>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/004u/</fr:uri>
            <fr:display-uri>004u</fr:display-uri>
            <fr:route>/notes/004u/</fr:route>
            <fr:title text="Lecture 8 - Horn Clauses">Lecture 8 - Horn Clauses</fr:title>
            <fr:taxon>VU-VFS-2025</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:title text="Introduction &amp; Syntax">Introduction &amp; Syntax</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/004v/</fr:uri>
                    <fr:display-uri>004v</fr:display-uri>
                    <fr:route>/notes/004v/</fr:route>
                    <fr:title text="Horn clauses - Syntax">Horn clauses - Syntax</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  A Horn clause is a disjunctive clause (disjunction of literals) with at most one positive, i.e. unnegated literal. Often written in implication form as a conjunction of literals implying some literal called the head.
</html:p>
                    <fr:tex display="block"><![CDATA[
  \underbrace {\underbrace {p(x_1, x_2) \land  q(x_1, x_2, x_3) \land  \ldots }_\text {queries} \land  \underbrace {\phi }_\text {constraint}}_\text {body} \to  \underbrace {H}_\text {head}
]]></fr:tex>
                    <html:p>
  Here:
</html:p>
                    <html:ol><html:li><html:em>queries</html:em> are <html:strong>relations</html:strong> over some vector of variables
  </html:li>
  <html:li><fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> represents a formula in a first-order theory which does not contain queries
  </html:li>
  <html:li><fr:tex display="inline"><![CDATA[H]]></fr:tex> is called the head and represents either a <html:em>query</html:em> in which case we also call the horn clause a <html:em>definite class</html:em> if it has the following shape
    <fr:tex display="block"><![CDATA[
      (p \land  q \land  \ldots  \land  \phi ) \to  H
    ]]></fr:tex>
    or a <html:em>fact</html:em> if it has the following shape
    <fr:tex display="block"><![CDATA[
      \top  \to  H
    ]]></fr:tex>
    <fr:tex display="inline"><![CDATA[H]]></fr:tex> can also be <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex> in which case we refer to the horn clause as a <html:em>gloal clause</html:em> with the shape 
    <fr:tex display="block"><![CDATA[
      (p \land  q \land  \ldots  \land  \phi ) \to  \bot 
    ]]></fr:tex>
    with the idea being that as opposed to <html:em>assuming</html:em> the query holds we now <html:em>show</html:em> that it holds
  </html:li></html:ol>
                    <html:p>
  Free variables are implicitly universally quantified over, so a horn clause like
</html:p>
                    <fr:tex display="block"><![CDATA[
  \texttt {mortal}(X) \to  \texttt {human}(X)
]]></fr:tex>
                    <html:p>
  stands for
</html:p>
                    <fr:tex display="block"><![CDATA[
  \forall  X.\ \texttt {mortal}(X) \to  \texttt {human}(X)
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/004w/</fr:uri>
                    <fr:display-uri>004w</fr:display-uri>
                    <fr:route>/notes/004w/</fr:route>
                    <fr:title text="Horn clauses - Semantics">Horn clauses - Semantics</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/0050/</fr:uri>
                    <fr:display-uri>0050</fr:display-uri>
                    <fr:route>/notes/0050/</fr:route>
                    <fr:title text="Horn clause - Solution">Horn clause - Solution</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  A <html:strong>solution</html:strong> is a function <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> that maps <html:em>queries</html:em> to <html:em>formulas</html:em> in the background theory over the same variables. Formally we write <fr:tex display="inline"><![CDATA[\Sigma  \vDash  C]]></fr:tex> and say that <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> satisfies <fr:tex display="inline"><![CDATA[C]]></fr:tex>, if <fr:tex display="inline"><![CDATA[C]]></fr:tex> is true if we replace all queries by their solutions, written as an inference rule:
</html:p>
  
    
    <fr:resource hash="d9ed32b08e0e488df79f18da6d8f0646"><fr:resource-content><html:img src="/notes/d9ed32b08e0e488df79f18da6d8f0646.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule {
    \Sigma (p) \land  \Sigma (q) \land  \ldots  \land  \phi  \to  \Sigma (r)
  }{
    \Sigma  \models  p(x_1, x_2) \land  q(x_1, x_2, x_3) \land  \ldots  \land  \phi  \to  r(x_1)
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
  We write <fr:tex display="inline"><![CDATA[\Sigma  \vDash  \mathcal {C}]]></fr:tex> and say that <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> <html:em>satisfies</html:em> the set of clauses <fr:tex display="inline"><![CDATA[\{C_1, C_2, \ldots , C_n\}]]></fr:tex>, if it satisfies all <html:em>individual clauses</html:em>, i.e:
</html:p><fr:tex display="block"><![CDATA[
  \Sigma  \vDash  C_1 \land  \Sigma  \vDash  C_2 \land  \ldots  \land  \Sigma  \vDash  C_n
]]></fr:tex><html:p>
  We say that <fr:tex display="inline"><![CDATA[\mathcal  C]]></fr:tex> is <html:strong>satisfiable</html:strong>, if <fr:tex display="inline"><![CDATA[\exists  \Sigma .\ \Sigma  \vDash  \mathcal  C]]></fr:tex></html:p></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/004z/</fr:uri>
                    <fr:display-uri>004z</fr:display-uri>
                    <fr:route>/notes/004z/</fr:route>
                    <fr:title text="Finding recursive Horn clauses">Finding recursive Horn clauses</fr:title>
                    <fr:taxon>Quiz</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>
  Is the following set of horn clauses recursive?
</html:p><html:ol><html:li><fr:tex display="block"><![CDATA[
      \begin {align}
        q(x) \land  r(x) &\to  p(x) \\
        p(x) \land  (x < n) &\to  \bot 
      \end {align}
    ]]></fr:tex></html:li>
  <html:li><fr:tex display="block"><![CDATA[
      \begin {align}
        q(x) \land  r(x) &\to  p(x) \\
        p(x) \land  (x > 0) &\to  r(x) \\
        p(x) \land  (x < n) &\to  \bot 
      \end {align}
    ]]></fr:tex></html:li></html:ol>
  
    
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>
      No, we can draw the dependency graph as follows
      
 
  
  <html:figure><html:a href="https://q.uiver.app/#q=WzAsMyxbMSwwLCJwIl0sWzAsMSwicSJdLFsyLDEsInIiXSxbMSwwXSxbMiwwXV0=" target="_blank" class="quiver-link">
    <fr:resource hash="182baed65cc7d3866c81269a209a1558"><fr:resource-content><html:img src="/notes/182baed65cc7d3866c81269a209a1558.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
   % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
  
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to AndréC.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \[\begin {tikzcd}
          & p \\
          q && r
          \arrow [from=2-1, to=1-2]
          \arrow [from=2-3, to=1-2]
        \end {tikzcd}\]
      ]]></fr:resource-source></fr:resource>
   </html:a></html:figure></html:li>
    <html:li>
      Yes, because the head <fr:tex display="inline"><![CDATA[p]]></fr:tex> depends on the query <fr:tex display="inline"><![CDATA[r]]></fr:tex> and vv. again as a graph we can draw it as follows
      
 
  
  <html:figure><html:a href="https://q.uiver.app/#q=WzAsMyxbMSwwLCJwIl0sWzAsMSwicSJdLFsyLDEsInIiXSxbMSwwXSxbMiwwXSxbMCwyLCIiLDIseyJvZmZzZXQiOi0yLCJjdXJ2ZSI6LTJ9XV0=" target="_blank" class="quiver-link">
    <fr:resource hash="1d857ace1a4564b61ec6d573c46bf6ec"><fr:resource-content><html:img src="/notes/1d857ace1a4564b61ec6d573c46bf6ec.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
   % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
  
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{arrows.meta, shapes, positioning, calc, decorations.pathreplacing, backgrounds, fit, matrix, spath3}

  % A TikZ style for curved arrows of a fixed height, due to AndréC.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \[\begin {tikzcd}
          & p \\
          q && r
          \arrow [shift left=2, curve={height=-12pt}, from=1-2, to=2-3]
          \arrow [from=2-1, to=1-2]
          \arrow [from=2-3, to=1-2]
        \end {tikzcd}\]
      ]]></fr:resource-source></fr:resource>
   </html:a></html:figure></html:li></html:ol>
</fr:mainmatter></fr:tree>
  
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:title text="Application of Horn clauses">Application of Horn clauses</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/0059/</fr:uri>
                    <fr:display-uri>0059</fr:display-uri>
                    <fr:route>/notes/0059/</fr:route>
                    <fr:title text="Normalizing Horn clauses">Normalizing Horn clauses</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Something of note when dealing with weakets preconditions <fr:link href="/notes/0056/" title="Weakest preconditions and Horn clauses" uri="https://kaierikniermann.github.io/notes/0056/" display-uri="0056" type="local">in terms of horn clauses</fr:link> is that we have to first normalize them to ensure they are in the correct horn format, which is to say we commonly have some horn clause in the form
</html:p>
                    <fr:tex display="block"><![CDATA[
  p(e_1, e_2) \land  \ldots  \land  \phi  \to  H(e_3) 
]]></fr:tex>
                    <html:p>
  where <fr:tex display="inline"><![CDATA[e_i]]></fr:tex> represents an expression, to normalize these clauses we lift the expressions out of the parameters for the predicates and into the list of conjuncts, i.e.:
</html:p>
                    <fr:tex display="block"><![CDATA[
  p(x_1, x_2) \land  x_1 = e_1 \land  x_2 = e_2 \land  x_3 = e_3 \land  \ldots  \land  \phi  \to  H(x_3)
]]></fr:tex>
                    <html:p>
  So we create fresh variables <fr:tex display="inline"><![CDATA[x_1, x_2, x_3]]></fr:tex> and assign these to the respective expressions then use them in place of the expressions themselves.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/005c/</fr:uri>
                    <fr:display-uri>005c</fr:display-uri>
                    <fr:route>/notes/005c/</fr:route>
                    <fr:title text="Strongest Postcondition">Strongest Postcondition</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  In the most straightforward sense the strongest postcondition, denoted <fr:tex display="inline"><![CDATA[\texttt {sp}]]></fr:tex> or <fr:tex display="inline"><![CDATA[\texttt {post}]]></fr:tex>, denotes the exact or <html:em>least</html:em> set of <html:strong>final states</html:strong> which we land in after a successful execution. Set theoretically we can denote it as.
</html:p>
                    <fr:tex display="block"><![CDATA[
  \texttt {sp}(s, P) = \{\sigma  \in  \Sigma  \mid  \exists  \sigma ' \in  \Sigma  : \sigma  ' \vDash  P \land  (s, \sigma ') \Downarrow  \sigma \}
]]></fr:tex>
                    <html:p>
  We can also use a more logic way of expressing it as follows
</html:p>
                    <fr:tex display="block"><![CDATA[
  \texttt {sp}(s, P) \triangleq  \exists  \sigma '.\ P(\sigma ') \land  (s, \sigma ') \Downarrow  \sigma 
]]></fr:tex>
                    <html:p>
  But the idea is in principle the same, it represents the set of states corresponding to some evaluated result based on some existing safe state.
</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>25</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/005k/</fr:uri>
                    <fr:display-uri>005k</fr:display-uri>
                    <fr:route>/notes/005k/</fr:route>
                    <fr:title text="Computing the strongest post-condition">Computing the strongest post-condition</fr:title>
                    <fr:taxon>Quiz</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  Consider the following set of Horn clauses
</html:p>
                    <fr:tex display="block"><![CDATA[
  \begin {align}
    x = 0 &\to  q(x) \\
    (q(y) \land  y < 6 \land  x = y + 1) \to  q(x)
  \end {align}
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:title text="Abstraction">Abstraction</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/005d/</fr:uri>
                    <fr:display-uri>005d</fr:display-uri>
                    <fr:route>/notes/005d/</fr:route>
                    <fr:title text="Abstraction &amp; Concretization function">Abstraction &amp; Concretization function</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
  In the most general sense we consider two domains, an abstract domain <fr:tex display="inline"><![CDATA[A]]></fr:tex> and a concrete domain <fr:tex display="inline"><![CDATA[C]]></fr:tex>. We have two functions the abstraction function
</html:p>
                    <fr:tex display="block"><![CDATA[
  \alpha  : C \to  A
]]></fr:tex>
                    <html:p>
  and the concretization function
</html:p>
                    <fr:tex display="block"><![CDATA[
  \gamma  : A \to  C
]]></fr:tex>
                    <html:p>
  Naturally we often instantiate these two domains for different scenarios.
</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:title text="Example: Interval abstraction">Example: Interval abstraction</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
    Let's consider a basic instance of abstraction where we think of the concrete domain as set's of numbers and the abstract domain as rangers or intervals of numbers which characterize these sets. So formally we say
  </html:p>
                        <html:ul><html:li>
      Our concrete domain is the power set <fr:tex display="inline"><![CDATA[\mathcal  P(\mathbb {R})]]></fr:tex> of the natural real numbers <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> ordered by set-inclusion so <fr:tex display="inline"><![CDATA[\sqsubseteq  \equiv  \subseteq ]]></fr:tex></html:li>
    <html:li>
      Our abstract domain is represented by intervals in addition to the symbols for true and false, so
      <fr:tex display="block"><![CDATA[
        A = \textrm {Intervals} \cup  \{\top , \bot \}
      ]]></fr:tex></html:li>
    <html:li>
      Our concretization function maps from an interval to all those numbers contained within the interval, so as an example
      <fr:tex display="block"><![CDATA[
        \gamma ([l, u]) \equiv  \{x \mid  l \leq  x \leq  u\}
      ]]></fr:tex></html:li>
    <html:li>
      Our abstraction function which takes a concrete element <fr:tex display="inline"><![CDATA[c]]></fr:tex> then maps this to the meet or conjunct of all abstract element in which the ordering with the concretization function holds, i.e.
      <fr:tex display="block"><![CDATA[
        \alpha (c) = \bigwedge  \{a \in  A \mid  c \subseteq  \gamma (a)\}
      ]]></fr:tex>
      the idea is that it represents the most precise abstract representation which can capture the concrete element c. Operationally we can express this equivalently as 
      <fr:tex display="block"><![CDATA[
                \alpha(c \equiv \{x_1, x_2, \ldots, x_n\}) = \begin{cases}
          [\textrm{min}\ c, \textrm{max}\ c] & \textrm{if bounded} \\
          [\textrm{min}\ c, +\infty) & \textrm{if only lb} \\
          (-\infty, \textrm{max}\ c] & \textrm{if only ub} \\
          \top & \textrm{if unbounded} \\
          \bot & \textrm{if}\ = \emptyset
        \end{cases}
      ]]></fr:tex> 
      so more plainly we can understand the abstraction function of just being the most exact combination i.e. meet / conjunction of intervals to express our concrete element.
    </html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:title text="Example: Predicate abstraction">Example: Predicate abstraction</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
    A common application within the domain of logic and computer science is to consider the concrete domain as referring to formulas or equivalently set's of states, not too much unlike our power-set of numbers. With our abstract state then being a conjunct of predicates from some finite set <fr:tex display="inline"><![CDATA[P]]></fr:tex> which best characterize our concrete formulas.
  </html:p>
                        <html:ul><html:li>
      Each element in the abstract domain is some permutation of our finite predicate set <fr:tex display="inline"><![CDATA[P]]></fr:tex>, so we have 
      <fr:tex display="block"><![CDATA[
        A = \mathcal  P(P) \quad  P_1 \sqsubseteq  P_2 \iff  P_2 \subseteq  P_1
      ]]></fr:tex>
      each abstract element <fr:tex display="inline"><![CDATA[a \in  P]]></fr:tex> is defined by the conjunction 
      <fr:tex display="block"><![CDATA[
        \bigwedge  _{p \in  a} p
      ]]></fr:tex> 
      hence our concretization function yields those set's of concrete states (or predicates representing these states) which satisfy <fr:tex display="inline"><![CDATA[a]]></fr:tex>. 
      <fr:tex display="block"><![CDATA[
        \gamma (a) = \{\sigma  \in  \Sigma  \mid  \forall  p \in  a.\ p(\sigma ) = \top \} \equiv  \llbracket  \bigwedge _{p \in  a} p \rrbracket  
      ]]></fr:tex></html:li>
    <html:li>
      The abstraction function is then defined more or less the usual way, we take in a concrete set of states <fr:tex display="inline"><![CDATA[c]]></fr:tex> then aggregate those predicates which describe our concrete set of states most precisely.
      <fr:tex display="block"><![CDATA[
        \alpha  (c) = \bigcap  \{a \in  A \mid  c \subseteq  \gamma (a)\}
      ]]></fr:tex>
      can equivalent formulation is 
      <fr:tex display="block"><![CDATA[
        \alpha  (c) = \bigwedge  \{p \in  P \mid  c \to  p\}
      ]]></fr:tex></html:li></html:ul>
                        <html:p>
    Let's consider as an example 
  </html:p>
                        <fr:tex display="block"><![CDATA[
    P = \{x \geq  0, x \geq  5, x \leq  10\} \quad  c = \{x = 7\}
  ]]></fr:tex>
                        <html:p>
    Here we can define the abstraction function as follows
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \alpha  (x = 7) = \bigwedge  \{x \geq  0, x \geq  5, x \leq  10\}
  ]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/005e/</fr:uri>
                    <fr:display-uri>005e</fr:display-uri>
                    <fr:route>/notes/005e/</fr:route>
                    <fr:title text="Abstract strongest postcondition"><fr:link href="/notes/005d/" title="Abstraction &amp; Concretization function" uri="https://kaierikniermann.github.io/notes/005d/" display-uri="005d" type="local">Abstract</fr:link> strongest postcondition</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:title text="The idea">The idea</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
    Our usual strongest postcondition can be understood as a mapping from a concrete domain to a concrete domain, i.e.
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \begin {align}
      \texttt {sp} : \texttt {Stmt} \times  \texttt {C} \to  C
    \end {align}
  ]]></fr:tex>
                        <html:p>
    Where <fr:tex display="inline"><![CDATA[C]]></fr:tex> represents our concrete domain, in the world of program logic this is typically assertions on the state of some memory environment. The idea behind the <html:em>abstract</html:em> <fr:tex display="inline"><![CDATA[\texttt {sp}]]></fr:tex>, is that we have a function
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \begin {align}
      \texttt {sp}^\# : \texttt {Stmt} \times  \texttt {A} \to  \texttt {A}
    \end {align}
  ]]></fr:tex>
                        <html:p>
    In other words we are considering the strongest postcondition from within the abstract domain. Intuitively this just means that our predicates or assertions on the memory states (or equivalently the set of states we characterize) will be expressed in abstract terms.
  </html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:title text="In more detail">In more detail</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
    The abstract strongest postcondition, denoted <fr:tex display="inline"><![CDATA[\texttt {sp}^\#]]></fr:tex> or <fr:tex display="inline"><![CDATA[\textrm {post\#}]]></fr:tex> is defined as
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \texttt {sp}^\# (s, a) = \alpha  (\texttt {sp}(s, \gamma (a)))
  ]]></fr:tex>
                        <html:p>
    Let's explain a bit on how we can derive this, we begin with the idea that for each <fr:tex display="inline"><![CDATA[a \in  A]]></fr:tex> and each statement <fr:tex display="inline"><![CDATA[s]]></fr:tex> we want:
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \texttt {sp}(s, \gamma (a)) \subseteq  \gamma (\texttt {sp}^\#(s, a))
  ]]></fr:tex>
                        <html:p>
    This expresses <html:strong>soundness</html:strong> in other words, the resulting set of states, generated by concretizing the abstraction <fr:tex display="inline"><![CDATA[a]]></fr:tex> must be contained within the prediction of the abstract transformer predicate <fr:tex display="inline"><![CDATA[\texttt {sp}^\#]]></fr:tex>. Then using the Galois connection we have between <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\gamma ]]></fr:tex></html:p>
                        <fr:tex display="block"><![CDATA[
    \forall  a \in  A, c \in  C.\ \alpha (c) \subseteq  a \iff  c \leq  \gamma  (a)
  ]]></fr:tex>
                        <html:p>
    which expresses the notion that <fr:tex display="inline"><![CDATA[c]]></fr:tex> is <html:em>approximated</html:em> by <fr:tex display="inline"><![CDATA[a]]></fr:tex>. We can rewrite our earlier soundness condition as:
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \alpha (\texttt {sp}(s, \gamma (a))) \sqsubseteq  \texttt {sp}^\# (s, a)
  ]]></fr:tex>
                        <html:p>
    two again denote the same conceptual thing that our abstract predicate transformer <fr:tex display="inline"><![CDATA[\texttt {sp}^\#]]></fr:tex> is an over-approximation of the analogous transformer for the concrete domain. As we would preferably like to have the most precise approximation we choose equality. Or stated differently by definition the most precise abstracted approximation of the strongest post-condition we can have for some abstracted state is literally just this state concretized, and the resulting set abstracted. 
  </html:p>
                        <fr:tex display="block"><![CDATA[
    \texttt {sp}^\# (s, a) = \alpha (\texttt {sp}(s, \gamma (a)))
  ]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>12</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:title text="Correctness">Correctness</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
    The most important property to remember about the abstract strongest post-condition is that if we <html:em>do over-approximate an error state</html:em> it <html:strong>does not</html:strong> allow us to conclude that the program is wrong.
  </html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/005d/</fr:uri>
            <fr:display-uri>005d</fr:display-uri>
            <fr:route>/notes/005d/</fr:route>
            <fr:title text="Abstraction &amp; Concretization function">Abstraction &amp; Concretization function</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  In the most general sense we consider two domains, an abstract domain <fr:tex display="inline"><![CDATA[A]]></fr:tex> and a concrete domain <fr:tex display="inline"><![CDATA[C]]></fr:tex>. We have two functions the abstraction function
</html:p>
            <fr:tex display="block"><![CDATA[
  \alpha  : C \to  A
]]></fr:tex>
            <html:p>
  and the concretization function
</html:p>
            <fr:tex display="block"><![CDATA[
  \gamma  : A \to  C
]]></fr:tex>
            <html:p>
  Naturally we often instantiate these two domains for different scenarios.
</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:title text="Example: Interval abstraction">Example: Interval abstraction</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
    Let's consider a basic instance of abstraction where we think of the concrete domain as set's of numbers and the abstract domain as rangers or intervals of numbers which characterize these sets. So formally we say
  </html:p>
                <html:ul><html:li>
      Our concrete domain is the power set <fr:tex display="inline"><![CDATA[\mathcal  P(\mathbb {R})]]></fr:tex> of the natural real numbers <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> ordered by set-inclusion so <fr:tex display="inline"><![CDATA[\sqsubseteq  \equiv  \subseteq ]]></fr:tex></html:li>
    <html:li>
      Our abstract domain is represented by intervals in addition to the symbols for true and false, so
      <fr:tex display="block"><![CDATA[
        A = \textrm {Intervals} \cup  \{\top , \bot \}
      ]]></fr:tex></html:li>
    <html:li>
      Our concretization function maps from an interval to all those numbers contained within the interval, so as an example
      <fr:tex display="block"><![CDATA[
        \gamma ([l, u]) \equiv  \{x \mid  l \leq  x \leq  u\}
      ]]></fr:tex></html:li>
    <html:li>
      Our abstraction function which takes a concrete element <fr:tex display="inline"><![CDATA[c]]></fr:tex> then maps this to the meet or conjunct of all abstract element in which the ordering with the concretization function holds, i.e.
      <fr:tex display="block"><![CDATA[
        \alpha (c) = \bigwedge  \{a \in  A \mid  c \subseteq  \gamma (a)\}
      ]]></fr:tex>
      the idea is that it represents the most precise abstract representation which can capture the concrete element c. Operationally we can express this equivalently as 
      <fr:tex display="block"><![CDATA[
                \alpha(c \equiv \{x_1, x_2, \ldots, x_n\}) = \begin{cases}
          [\textrm{min}\ c, \textrm{max}\ c] & \textrm{if bounded} \\
          [\textrm{min}\ c, +\infty) & \textrm{if only lb} \\
          (-\infty, \textrm{max}\ c] & \textrm{if only ub} \\
          \top & \textrm{if unbounded} \\
          \bot & \textrm{if}\ = \emptyset
        \end{cases}
      ]]></fr:tex> 
      so more plainly we can understand the abstraction function of just being the most exact combination i.e. meet / conjunction of intervals to express our concrete element.
    </html:li></html:ul>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:title text="Example: Predicate abstraction">Example: Predicate abstraction</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
    A common application within the domain of logic and computer science is to consider the concrete domain as referring to formulas or equivalently set's of states, not too much unlike our power-set of numbers. With our abstract state then being a conjunct of predicates from some finite set <fr:tex display="inline"><![CDATA[P]]></fr:tex> which best characterize our concrete formulas.
  </html:p>
                <html:ul><html:li>
      Each element in the abstract domain is some permutation of our finite predicate set <fr:tex display="inline"><![CDATA[P]]></fr:tex>, so we have 
      <fr:tex display="block"><![CDATA[
        A = \mathcal  P(P) \quad  P_1 \sqsubseteq  P_2 \iff  P_2 \subseteq  P_1
      ]]></fr:tex>
      each abstract element <fr:tex display="inline"><![CDATA[a \in  P]]></fr:tex> is defined by the conjunction 
      <fr:tex display="block"><![CDATA[
        \bigwedge  _{p \in  a} p
      ]]></fr:tex> 
      hence our concretization function yields those set's of concrete states (or predicates representing these states) which satisfy <fr:tex display="inline"><![CDATA[a]]></fr:tex>. 
      <fr:tex display="block"><![CDATA[
        \gamma (a) = \{\sigma  \in  \Sigma  \mid  \forall  p \in  a.\ p(\sigma ) = \top \} \equiv  \llbracket  \bigwedge _{p \in  a} p \rrbracket  
      ]]></fr:tex></html:li>
    <html:li>
      The abstraction function is then defined more or less the usual way, we take in a concrete set of states <fr:tex display="inline"><![CDATA[c]]></fr:tex> then aggregate those predicates which describe our concrete set of states most precisely.
      <fr:tex display="block"><![CDATA[
        \alpha  (c) = \bigcap  \{a \in  A \mid  c \subseteq  \gamma (a)\}
      ]]></fr:tex>
      can equivalent formulation is 
      <fr:tex display="block"><![CDATA[
        \alpha  (c) = \bigwedge  \{p \in  P \mid  c \to  p\}
      ]]></fr:tex></html:li></html:ul>
                <html:p>
    Let's consider as an example 
  </html:p>
                <fr:tex display="block"><![CDATA[
    P = \{x \geq  0, x \geq  5, x \leq  10\} \quad  c = \{x = 7\}
  ]]></fr:tex>
                <html:p>
    Here we can define the abstraction function as follows
  </html:p>
                <fr:tex display="block"><![CDATA[
    \alpha  (x = 7) = \bigwedge  \{x \geq  0, x \geq  5, x \leq  10\}
  ]]></fr:tex>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

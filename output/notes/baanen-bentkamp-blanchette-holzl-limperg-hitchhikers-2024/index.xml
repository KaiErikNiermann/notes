<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>Baanen, Anne, Bentkamp, Alexander, Blanchette, Jasmin, Holzl, Johannes, Limperg, Jannis</fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>3</fr:month>
      <fr:day>28</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/</fr:uri>
    <fr:display-uri>baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024</fr:display-uri>
    <fr:route>/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/</fr:route>
    <fr:title text="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)">The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="note">Desktop edition</fr:meta>
    <fr:meta name="external">https://raw.githubusercontent.com/lean-forward/logical_verification_2024/main/hitchhikers_guide_2024_desktop.pdf</fr:meta>
    <fr:meta name="publisher">Lean Forward</fr:meta>
    <fr:meta name="ENTRYTYPE">book</fr:meta>
    <fr:meta name="ID">baanen_bentkamp_blanchette_holzl_limperg_hitchhikers_2024</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/002r/</fr:uri>
            <fr:display-uri>002r</fr:display-uri>
            <fr:route>/notes/002r/</fr:route>
            <fr:title text="Type universes in Lean4">Type universes in Lean4</fr:title>
            <fr:taxon>Blog</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>28</fr:day>
                </fr:date>
                <fr:title text="A brief overview">A brief overview</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Universe hierarchy">Universe hierarchy</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>In Lean4, types are organized into a hierarchy of <html:em>universes</html:em> (also referred to as <html:em>sorts</html:em>). Each universe is assoicated with a <html:em>level</html:em>, which is a natural number. The <fr:tex display="inline"><![CDATA[\texttt {Sort}]]></fr:tex> operator constructs a universe from a given level. To avoid things like Girard's paradox, Lean4 employs a stratified type system where each universe can only contain types from lower universes, we have the following hierarchy <fr:link href="/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" title="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)" uri="https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" display-uri="baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024" type="local">(1)</fr:link>:</html:p><fr:tex display="block"><![CDATA[
    \begin {align*}
    \texttt {Prop} : \texttt {Type 0} : \texttt {Type 1} : \texttt {Type 2} : \cdots  \\
    \texttt {Sort 0} : \texttt {Sort 1} : \texttt {Sort 2} : \texttt {Sort 3} : \cdots 
    \end {align*}
  ]]></fr:tex><html:p><fr:tex display="inline"><![CDATA[\texttt {Sort}]]></fr:tex> has two main aliases used in Lean4: <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex>. Here, <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> (which is equivalent to <fr:tex display="inline"><![CDATA[\texttt {Sort 0}]]></fr:tex>) is the universe of logical propositions, while <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex> (which is equivalent to <fr:tex display="inline"><![CDATA[\texttt {Sort (u + 1)}]]></fr:tex>) represents a universe of types at level <fr:tex display="inline"><![CDATA[u]]></fr:tex>. So we can say:</html:p><fr:tex display="block"><![CDATA[
    \texttt {Type u} \equiv  \texttt {Sort (u + 1)}
  ]]></fr:tex><fr:tex display="block"><![CDATA[
    \texttt {Prop} \equiv  \texttt {Sort 0}
  ]]></fr:tex><html:p>In general we can express the hierarchy for any universe level <fr:tex display="inline"><![CDATA[u]]></fr:tex> as follows:</html:p>
  
    
    <fr:resource hash="d94eb728c2b2b4c4d53e790ae8b3c721"><fr:resource-content><html:img src="/notes/d94eb728c2b2b4c4d53e790ae8b3c721.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule *[right=Sort]{
    }{
      \Gamma  \vdash  \texttt {Sort u} : \texttt {Sort (u + 1)}
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Predicative universes">Predicative universes</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>With the exception of propositions, a type in a universe at level <fr:tex display="inline"><![CDATA[u]]></fr:tex> cannot quantify over types from strictly larger universes unless the whole result is lifted to a larger universe. In the case of types we have:</html:p>
  
    
    <fr:resource hash="6421c48de3f29311e497b41a79a808fd"><fr:resource-content><html:img src="/notes/6421c48de3f29311e497b41a79a808fd.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=ArrowType]{
        \Gamma  \vdash  \sigma  : \texttt {Type u} \\
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Type v}
      }{
        \Gamma  \vdash  (x : \sigma ) \to  \tau [x] : \texttt {Type (max u v)}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>To demonstrate some valid instance of this inference rule lets consider the following lean examples:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
      example (α : Type 1) (β : Type 2) : Type 2 := α → β
      example (α : Type 2) (β : Type 1) : Type 2 := α → β
    </html:code></html:pre><html:p>Both of the above examples are valid because the resulting type is lifted to the maximum universe level of the input types. In general we say that the behavior of the <fr:tex display="inline"><![CDATA[\texttt {Type}]]></fr:tex> universes is called <html:strong>predicative</html:strong> meaning that objects <html:em>may not</html:em> be defined in terms of quantifiers ranging over that same object.</html:p></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Impredicative universes">Impredicative universes</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>We can observe that a function type's universe is determined by the universes of its argument and return types. However, in the case of propositions we have a different behavior:</html:p>
  
    
    <fr:resource hash="01b9da1304665deaca41d0e69e7e2b67"><fr:resource-content><html:img src="/notes/01b9da1304665deaca41d0e69e7e2b67.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=ArrowProp]{
        \Gamma  \vdash  \sigma  : \texttt {Sort u} \\ 
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Prop}
      }{
        \Gamma  \vdash  (\forall  x : \sigma , \tau [x]) : \texttt {Prop}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Predicates, which are functions that return propositions, may have argument types in any universe, but the function itself remains in the <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> universe. This behavior is called <html:strong>impredicative</html:strong> meaning that objects <html:em>may</html:em> be defined in terms of quantifiers ranging over that same object. The rule <fr:tex display="inline"><![CDATA[\textsc {ArrowProp}]]></fr:tex> means that expressions such <fr:tex display="inline"><![CDATA[\forall  a : \texttt {Prop}, a \to  a]]></fr:tex>, which quantify over all propositions (including themselves), yield a proposition, that is:</html:p><fr:tex display="block"><![CDATA[
      (\forall  a : \texttt {Prop},\ a \to  a) : \texttt {Prop}
    ]]></fr:tex><html:p>We can see some more examples of quantifying both over propositions and types as follows:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
      /-- Quantifying over propositions yields a proposition -/
      example : Prop := ∀ (P : Prop) (p1 p2 : P), p1 = p2

      /-- Proposition quantifying over all type stays in Prop -/
      example : Prop := ∀ (α : Type), ∀ (x : α), x = x
      example : Prop := ∀ (α : Type 5), ∀ (x : α), x = x
    </html:code></html:pre></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="The general rule">The general rule</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>We can combine these two rules to get a more general rule for function types that return types in any universe:</html:p>
  
    
    <fr:resource hash="0701b5f9a243365e0125751bf06c9e91"><fr:resource-content><html:img src="/notes/0701b5f9a243365e0125751bf06c9e91.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata}
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

  \newcommand{\cf}[1]{\texttt{#1}}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
      \inferrule *[right=Arrow]{
        \Gamma  \vdash  \sigma  : \texttt {Sort u} \\ 
        \Gamma  , x : \sigma  \vdash  \tau [x] : \texttt {Sort v}
      }{
        \Gamma  \vdash  (x : \sigma ) \to  \tau [x] : \texttt {Sort (imax u v)}
      }
    \end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Here the function type's universe is determined by the (impredicative max) <html:strong>imax</html:strong> of the universes of its argument and return types, where <fr:tex display="inline"><![CDATA[\texttt {imax}]]></fr:tex> is defined as follows:</html:p><fr:tex display="block"><![CDATA[
      \texttt {imax}(u, v) = \begin {cases}
        0 & \text {if } v = 0 \\
        \texttt {max}(u, v) & \text {otherwise}
      \end {cases}
    ]]></fr:tex></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="The level grammar">The level grammar</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We can describe the level grammar via the following inductive type:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      inductive Level
      | zero : Level
      | succ : Level → Level
      | max  : Level → Level → Level
      | imax : Level → Level → Level
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>28</fr:day>
                </fr:date>
                <fr:title text="Universe Binding">Universe Binding</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Explicit">Explicit</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We can define functions and types that are <html:strong>universe polymorphic</html:strong> by introducing universe levels either <html:em>explicitly</html:em> or <html:em>implicitly</html:em>. An explicit universe level is specified directly in the definition, while an implicit universe level is inferred by Lean4. For example:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
        /-- Explicit universe level -/
        def map.{u v} {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β :=
          | []       =&gt; []
          | x :: xs  =&gt; f x :: map f xs
      </html:code>
                    </html:pre>
                    <html:p>Here the map is declared with explicit universe levels <fr:tex display="inline"><![CDATA[u]]></fr:tex> and <fr:tex display="inline"><![CDATA[v]]></fr:tex> and instantiates the polymorphic <fr:tex display="inline"><![CDATA[\texttt {List}]]></fr:tex>. We can also define the same function with implicit universe levels as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
        universe u v
        def map {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β := ...
      </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Implicit">Implicit</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>By default in Lean4 the option <fr:tex display="inline"><![CDATA[\texttt {autoImplicit}]]></fr:tex> is set to true, meaning that our universe levels will be inferred automatically meaning that we can simply write:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
        def map {α : Type u} {β : Type v} 
            (f : α → β) : List α → List β := ...
      </html:code>
                    </html:pre>
                    <html:p>Importantly automatic implicit paramter inference <html:em>only works</html:em> if the universe is mentioned in the header preceding the assignment, i.e:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
        /-- Bad: unknown universe u -/
        def L := List (Type u)
        /-- Good: universe u mentioned in header -/
        def L.{u} := List (Type u)
      </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Implicit + fresh">Implicit + fresh</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We can also go even further with implicit universes by allowing Lean4 to generate fresh universe levels for us. This is done by omitting the universe annotation and replacing it with a * suffix:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      /-- Fresh implicit universe levels -/
      def map {α : Type*} {β : Type*} 
          (f : α → β) : List α → List β := ...
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>28</fr:day>
                </fr:date>
                <fr:title text="Universe Lifting">Universe Lifting</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Sometimes we may want to explicitly  lift a type from one universe to a higher universe. Lean4 provides lifting operators which are wrappers around terms of a type that reside in a higher universe. There are two main lifting operators:</html:p>
                <html:ul><html:li><fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex>: Lifts a proposition from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> (i.e. <fr:tex display="inline"><![CDATA[\texttt {Sort 1}]]></fr:tex>).</html:li>
    <html:li><fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex>: Lifts a type from <fr:tex display="inline"><![CDATA[\texttt {Type u}]]></fr:tex> to any number of levels.</html:li></html:ul>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="PLift">PLift</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> operator is used to lift propositions into the first type universe. It is defined as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      structure PLift (α : Sort u) : Type u where
        /-- Wraps a proof/value to increase its type's universe lvl -/
        up ::
        /-- Extracts a wrapped proof/value from a lifted prop/type. -/
        down : α
    </html:code>
                    </html:pre>
                    <html:p>Some simple examples:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      #check False       -- False : Prop
      #check PLift False -- PLift False : Type
      #check Nat         -- Nat : Type
      #check PLift Nat   -- PLift Nat : Type 1

      example : PLift Prop        := PLift.up True
      example : Prop              := (PLift.down (PLift.up False))
      example : List (PLift True) := [.up (by trivial), .up (by decide)]
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="ULift">ULift</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The <fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex> operator is used to lift types to higher universes. It is defined as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      structure ULift.{r, s} (α : Type s) : Type (max s r) where
        /-- Wraps a value to increase its type's universe level. -/
        up ::
        /-- Extracts a wrapped value from a universe-lifted type. -/
        down : α
    </html:code>
                    </html:pre>
                    <html:p>Some simple examples:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      #check Nat               -- Nat : Type
      #check ULift Nat         -- ULift Nat : Type 1
      #check ULift (ULift Nat) -- ULift (ULift Nat) : Type 2

      example : ULift Nat        := ULift.up 42
      example : List (ULift Nat) := [.up 1, .up 2, .up 3]
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>28</fr:day>
                </fr:date>
                <fr:title text="Example: Preorder Category">Example: Preorder Category</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A <html:em>preorder relation</html:em> is a binary relation that is <html:strong>reflexive</html:strong> and <html:strong>transitive</html:strong>. In Lean this is expressed as follows:</html:p>
                <html:pre class="code-block language-lean">
                  <html:code class="language-lean">
    class Preorder (α : Type*) extends LE α, LT α where
      le_refl   : ∀ a : α, a ≤ a
      le_trans  : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c
      lt := fun a b =&gt; a ≤ b ∧ ¬b ≤ a
      lt_iff_le_not_ge : ∀ a b : α, a &lt; b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl
  </html:code>
                </html:pre>
                <html:p>We can already see here that the preorder relation uses implicit universe polymorphism via the <fr:tex display="inline"><![CDATA[\texttt {Type*}]]></fr:tex> annotation. We can now construct a small category from a preorder relation as follows:</html:p>
                <html:pre class="code-block language-lean">
                  <html:code class="language-lean">
    open CategoryTheory

    instance {α : Type u} [Preorder α] : SmallCategory α where
      Hom a b          := ULift &lt;| PLift (a ≤ b)
      id a             := .up &lt;| .up &lt;| le_refl a
      comp {a b c} f g := .up &lt;| .up &lt;| (le_trans f.down.down g.down.down)
  </html:code>
                </html:pre>
                <html:p>Let's break this down part by part starting with the homomorphisms:</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Arrows">Arrows</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>For the case of the category definition, Lean fundamentally uses quivers to represent the homs between objects. Now before showing how lean defines them let's I think try and do it ourselves. So in this instance in an abstract sense we want the relationship <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> to represent our morphism or arrow between two objects, so in a sense the following two are equivalent:</html:p>
                    <fr:tex display="block"><![CDATA[
      a \leq  b \equiv  a \xrightarrow {\leq } b
    ]]></fr:tex>
                    <html:p>So in the most straightforward sense what we can do is define any kind of "container" to repreesnt our source and target objects under some label, we can define this naively as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      class Graph (Obj : Type) where
        arrow (source : Obj) (target : Obj) : Type
    </html:code>
                    </html:pre>
                    <html:p>Now let's try to define an instance of such a graph on a preorder relation in which our objects simply live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      instance {α : Type} [Preorder α] : Graph α where
        arrow a b := a ≤ b -- arrow from a to b is the relation a ≤ b
    </html:code>
                    </html:pre>
                    <html:p>Here we are declaring an instance, this instance takes
      <html:ul><html:li>An <html:strong>implicit type parameter</html:strong> <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> which is the type of our objects at the universe level 0.</html:li>
          <html:li>A <html:strong>type class constraint</html:strong> <fr:tex display="inline"><![CDATA[\texttt {[Preorder α]}]]></fr:tex> which ensures that the type <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> has a preorder relation defined on it. In other words it guarantees that the relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> is reflexive and transitive for all elements of type <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex>.</html:li></html:ul>
      And we provide the necessary implementation for the <fr:tex display="inline"><![CDATA[\texttt {arrow}]]></fr:tex> function by setting it to be the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>. But what you will notice is that we have a problem here, namely that our preorder relation lives in the universe <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> as its obviously a logical relation, but our graph arrows need to live in <fr:tex display="inline"><![CDATA[\texttt {Type}]]></fr:tex> (i.e. <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>).  
    </html:p>
                    <html:p>A first thought might be to just set the arrow type to be <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> directly, in our definition of the class <fr:tex display="inline"><![CDATA[\texttt {Graph}]]></fr:tex> though this is rather restrictive as it means that any graph we wish to define can only ever have arrows representing propositions, what if we want to have arrows represent other types such as functions or numbers?</html:p>
                    <html:p>One way to approach this is to use the <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> operator to lift our preorder relation from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> as follows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      instance {α : Type} [Preorder α] : Graph α where
        arrow a b := PLift (a ≤ b) -- lift relation to Type 0
    </html:code>
                    </html:pre>
                    <html:p>While this does work, and often is probably a reasonable way to go about things, much of Lean's mathlib employs universe polymorphic types to define various kinds of structures. Thus parameterising over some universe level <fr:tex display="inline"><![CDATA[u]]></fr:tex> we define our polymorphic instance as:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      instance {α : Type u} [Preorder α] : Graph α where
        arrow a b := PLift (a ≤ b) 
    </html:code>
                    </html:pre>
                    <html:p>But now we naturally run into another issue, namely that the class for our graph is now no longer universe polymorphic which leads to a universe level mismatch. The most straightforward fix here is to simply make the objects in the graph universe polymorphic as well:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      class Graph (Obj : Type u) where -- now polymorphic over u
        arrow (source : Obj) (target : Obj) : Type
    </html:code>
                    </html:pre>
                    <html:p>But this leads to another question, what level should the arrows live in? We've already seen that arrows can represent various different kinds of things different from the types of objects themselves, (e.g. <fr:tex display="inline"><![CDATA[2 \leq  3]]></fr:tex> is a proposition but clearly 2 and 3 are numbers). Now one approach is to simply leave the arrows in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> but this already is mildly annoying as it forces us to lift any arrows that don't naturally live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>. Furthermore we've already seen that having the type stuck at Prop is also not nice, so what we can do is make the arrows universe polymorphic as well, though over a different universe level <fr:tex display="inline"><![CDATA[v]]></fr:tex> motivated by the aforementioned situation of different levels of arrows and objects:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      class Graph (Obj : Type u) where
        arrow (source : Obj) (target : Obj) : Sort v

      instance {α : Type u} [Preorder α] : Graph α where
        arrow a b := a ≤ b -- now lives in Sort 0 (i.e. Prop)
    </html:code>
                    </html:pre>
                    <html:p>But hold up, why are we lifting in the definition of the instance for the SmallCategory? Let's take a look at all the relevant type signatures:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- Quiver 
      -- (V : Type u) where

      -- CategoryStruct
      -- (obj : Type u) : Type max u (v + 1) extends Quiver.{v + 1} obj

      -- Category 
      -- (obj : Type u) : Type max u (v + 1) extends CategoryStruct.{v} obj 

      -- SmallCategory
      -- (obj : Type u) : Type (u + 1) extends Category.{u} obj 
    </html:code>
                    </html:pre>
                    <html:p>Let's break this down step by step starting first with the relationship between CategoryStruct and Quiver, for the sake of simplicitly i'll abstract away some exact names and make all universes explicit:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      variable {α : Type m} [Preorder α] (a b c : α)

      class Box.{u, v} (obj : Type u) where
        pair : obj → obj → Sort v

      class A.{u, v} (obj : Type u) 
        : Type max u (v + 1) extends (Box.{u, v + 1} obj) where
    </html:code>
                    </html:pre>
                    <html:p>I think an interesting question I first had here is with the extension of <fr:tex display="inline"><![CDATA[\texttt {Box}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex> why might you want to increase the universe level of the arrows by one? The main reason this is done in general is to essentially constrain the <fr:tex display="inline"><![CDATA[v]]></fr:tex> to never be zero. The implication of this being that our extended class <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex> can never have any pairs which live in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>.</html:p>
                    <html:p>A good follow up to this might be, why would you not want thigns to live in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>? In the most general sense some of the reasons are:</html:p>
                    <html:ul><html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> is <html:em>proof irrelevant</html:em>: In Lean, propositions are considered proof irrelevant, meaning that all proofs of a given proposition are treated as equal. This can lead to loss of information when you want to be able to distinguish between different morphisms or in our simplified example pairs.</html:li>
      <html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> is <html:em>not computational</html:em>: Propositions in Lean are not computationally relevant, meaning that they do not have computational content. If you want to perform computations or extract algorithms from your morphisms or pairs, having them in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> would prevent that.</html:li>
      <html:li><fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> has <html:em>limited structure</html:em>: Propositions in Lean do not have the same rich structure as types in higher universes. If you need to work with morphisms or pairs that have additional structure (like being functions, sets, etc.), you would want them to live in a higher universe.</html:li></html:ul>
                    <html:p>As an example we can consider the following:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- @classname disables universe inference for that class
      variable (a₁ : @A.{m, v} α)
      #check (a₁.pair a b : Sort (v + 1)) -- Box.pair a b : Type v
    </html:code>
                    </html:pre>
                    <html:p>We can see here that the pair now lives in <fr:tex display="inline"><![CDATA[\texttt {Sort (v + 1)}]]></fr:tex>, meaning that if we had <fr:tex display="inline"><![CDATA[v = 0]]></fr:tex> then our pairs would now live in <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>. A natural byproduct of this choice - having arrows live in <fr:tex display="inline"><![CDATA[\texttt {Sort (v + 1)}]]></fr:tex> - is that the type of the structure itself must now live in the largest universe such that it can contain both the objects and the arrows. This is why we have the type signature <fr:tex display="inline"><![CDATA[\texttt {Type max u (v + 1)}]]></fr:tex> for <fr:tex display="inline"><![CDATA[\texttt {A}]]></fr:tex>. Equivalently we can expand this as:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- since Type u = Sort (u + 1) and Type (v + 1) = Sort (v + 2)
      Sort (max (u + 1) (v + 2)) 
    </html:code>
                    </html:pre>
                    <html:p>If we then create similarly abstract versions for the Category class (B) and SmallCategory class (C) we have:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      class B.{u, v} (obj : Type u) 
        : Type max u (v + 1) extends A.{u, v} obj where

      class C.{u} (obj : Type u) 
        : Type (u + 1) extends B.{u, u} obj where 
      --                        ^ can also type B.{u} (inferres v = u)
    </html:code>
                    </html:pre>
                    <html:p>We can see here that our SmallCategory (C) now constrains the arrows to live in the same universe as the objects by setting <fr:tex display="inline"><![CDATA[v = u]]></fr:tex> in the extension of <fr:tex display="inline"><![CDATA[\texttt {B}]]></fr:tex>. Thus if we construct our pair, we have:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      variable (c : @C.{m} α)
      #check (c.pair a b : Sort (m + 1)) -- Box.pair a b : Type m
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Identity morphism">Identity morphism</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Next up let's look at the identity morphism:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      id a := .up &lt;| .up &lt;| le_refl a
    </html:code>
                    </html:pre>
                    <html:p>The identity is defined as a function that quantifies over all objects <fr:tex display="inline"><![CDATA[a]]></fr:tex> in our category and returns an arrow from <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[a]]></fr:tex>. Naturally we then first want to construct our arrow, the identity arrow from <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[a]]></fr:tex> is simply the reflexivity property of the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>, that is <fr:tex display="inline"><![CDATA[a \leq  a]]></fr:tex> which we can get via <fr:tex display="inline"><![CDATA[\texttt {le\_refl a}]]></fr:tex>. However since our arrows live in <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>, we need to lift our relation twice, first using <fr:tex display="inline"><![CDATA[\texttt {PLift.up}]]></fr:tex> to lift it from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex>, and then again using <fr:tex display="inline"><![CDATA[\texttt {ULift.up}]]></fr:tex> to lift it from <fr:tex display="inline"><![CDATA[\texttt {Type 0}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>. A note to make for people unfamiliar with the syntax here, the following pieces of code are equivalent:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      -- .up &lt;| .up &lt;| le_refl a == ULift.up (PLift.up (le_refl a))
    </html:code>
                    </html:pre>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:title text="Composition">Composition</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Finally let's look at the composition of arrows:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      comp {a b c} f g := .up &lt;| .up &lt;| (le_trans f.down.down g.down.down)
    </html:code>
                    </html:pre>
                    <html:p>The lifting portion here follows the same reasoning as the identity morphism, we need to lift the resulting relation from <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {Type m}]]></fr:tex>. The actual composition is done via the transitivity property of the preorder relation <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex>. The thing is here that our input arrows <fr:tex display="inline"><![CDATA[f]]></fr:tex> and <fr:tex display="inline"><![CDATA[g]]></fr:tex> are both lifted types corresponding to:</html:p>
                    <html:pre class="code-block language-lean">
                      <html:code class="language-lean">
      f : ULift (PLift (a ≤ b))
      g : ULift (PLift (b ≤ c))
    </html:code>
                    </html:pre>
                    <html:p>Thus to extract the actual preorder relations we need to use the <fr:tex display="inline"><![CDATA[\texttt {down}]]></fr:tex> method twice, first to go from <fr:tex display="inline"><![CDATA[\texttt {ULift}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex>, and then again to go from <fr:tex display="inline"><![CDATA[\texttt {PLift}]]></fr:tex> to the actual relation in <fr:tex display="inline"><![CDATA[\texttt {Prop}]]></fr:tex>. Once we have the two relations extracted we can then apply the transitivity property <fr:tex display="inline"><![CDATA[\texttt {le\_trans}]]></fr:tex> to get the composed relation <fr:tex display="inline"><![CDATA[a \leq  c]]></fr:tex> (which we then lift back up).</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>25</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/002c/</fr:uri>
            <fr:display-uri>002c</fr:display-uri>
            <fr:route>/notes/002c/</fr:route>
            <fr:title text="Complete Lattice">Complete Lattice</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A <html:em>complete lattice</html:em> is a <fr:link href="/notes/002d/" title="Partial order" uri="https://kaierikniermann.github.io/notes/002d/" display-uri="002d" type="local">partially ordered set</fr:link> in which all subsets have both a <html:em>greatest lower bound</html:em> (also known as <html:em>infimum</html:em> or <html:em>meet</html:em>) and a <html:em>least upper bound</html:em> (also known as <html:em>supremum</html:em> or <html:em>join</html:em>). This means that for any subset <fr:tex display="inline"><![CDATA[S]]></fr:tex> of the complete lattice <fr:tex display="inline"><![CDATA[L]]></fr:tex>, there exists an element <fr:tex display="inline"><![CDATA[\sqcup \ S]]></fr:tex> in <fr:tex display="inline"><![CDATA[L]]></fr:tex> such that: <fr:link href="/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" title="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)" uri="https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" display-uri="baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024" type="local">(1)</fr:link></html:p>
            <html:ul><html:li><fr:tex display="inline"><![CDATA[\sqcup \ S]]></fr:tex> is a lower bound of <fr:tex display="inline"><![CDATA[S]]></fr:tex>: For all elements <fr:tex display="inline"><![CDATA[s \in  S]]></fr:tex>, <fr:tex display="inline"><![CDATA[\sqcup \ S \leq  s]]></fr:tex>.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[\sqcup \ S]]></fr:tex> is the greatest of all lower bounds: For any other lower bound <fr:tex display="inline"><![CDATA[b]]></fr:tex> of <fr:tex display="inline"><![CDATA[S]]></fr:tex>, <fr:tex display="inline"><![CDATA[b \leq  \sqcup \ S]]></fr:tex>.</html:li></html:ul>
            <html:p>Similarly, there exists an element <fr:tex display="inline"><![CDATA[\sqcap \ S]]></fr:tex> in <fr:tex display="inline"><![CDATA[L]]></fr:tex> such that:</html:p>
            <html:ul><html:li><fr:tex display="inline"><![CDATA[\sqcap \ S]]></fr:tex> is an upper bound of <fr:tex display="inline"><![CDATA[S]]></fr:tex>: For all elements <fr:tex display="inline"><![CDATA[s \in  S]]></fr:tex>, <fr:tex display="inline"><![CDATA[s \leq  \sqcap \ S]]></fr:tex>.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[\sqcap \ S]]></fr:tex> is the least of all upper bounds: For any other upper bound <fr:tex display="inline"><![CDATA[b]]></fr:tex> of <fr:tex display="inline"><![CDATA[S]]></fr:tex>, <fr:tex display="inline"><![CDATA[\sqcap \ S \leq  b]]></fr:tex>.</html:li></html:ul>
            <html:p>In a complete lattice, every subset, including the empty set and the entire set itself, has both a supremum and an infimum within the lattice.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>25</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/0028/</fr:uri>
            <fr:display-uri>0028</fr:display-uri>
            <fr:route>/notes/0028/</fr:route>
            <fr:title text="Fixpoint">Fixpoint</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A <html:em>fixpoint</html:em> (or <html:em>fixed point</html:em>) of a function <fr:tex display="inline"><![CDATA[f: S \to  S]]></fr:tex> is an element <fr:tex display="inline"><![CDATA[x \in  S]]></fr:tex> such that applying the function <fr:tex display="inline"><![CDATA[f]]></fr:tex> to <fr:tex display="inline"><![CDATA[x]]></fr:tex> returns <fr:tex display="inline"><![CDATA[x]]></fr:tex> itself. In other words, <fr:tex display="inline"><![CDATA[x]]></fr:tex> is a fixpoint of <fr:tex display="inline"><![CDATA[f]]></fr:tex> if the following condition holds: <fr:link href="/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" title="The Hitchhiker’s Guide to Logical Verification (2024 Desktop Edition)" uri="https://kaierikniermann.github.io/notes/baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024/" display-uri="baanen-bentkamp-blanchette-holzl-limperg-hitchhikers-2024" type="local">(1)</fr:link></html:p>
            <fr:tex display="block"><![CDATA[
  f(x) = x
]]></fr:tex>
            <html:p>This means that when you input <fr:tex display="inline"><![CDATA[x]]></fr:tex> into the function <fr:tex display="inline"><![CDATA[f]]></fr:tex>, the output is the same as the input.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

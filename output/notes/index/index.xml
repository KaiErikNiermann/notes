<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="true" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://kaierikniermann.github.io/notes/index/</fr:uri>
    <fr:display-uri>index</fr:display-uri>
    <fr:route>/notes/index/</fr:route>
    <fr:title text="Kai Erik Niermann">Kai Erik Niermann</fr:title>
    <fr:meta name="institution">Vrije Universiteit Amsterdam</fr:meta>
    <fr:meta name="position">Student</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>22</fr:day>
        </fr:date>
        <fr:uri>https://kaierikniermann.github.io/notes/0002/</fr:uri>
        <fr:display-uri>0002</fr:display-uri>
        <fr:route>/notes/0002/</fr:route>
        <fr:title text="Course Notes">Course Notes</fr:title>
        <fr:meta name="description">Course Notes</fr:meta>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>
  This is a collection of notes for various courses I have taken.
</html:p>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/0003/</fr:uri>
            <fr:display-uri>0003</fr:display-uri>
            <fr:route>/notes/0003/</fr:route>
            <fr:title text="All VFS Quiz Solutions">All VFS Quiz Solutions</fr:title>
            <fr:taxon>VU-VFS-2025</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
  This is an explanation and solution to all quizzes in the VFS lectures. By default I have the solutions minimized, but you can expand them by clicking on the upper part of the solution box (i.e. just click the solution section).
</html:p>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/0004/</fr:uri>
                <fr:display-uri>0004</fr:display-uri>
                <fr:route>/notes/0004/</fr:route>
                <fr:title text="Lecture 1 - Propositional Logic">Lecture 1 - Propositional Logic</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Syntax">Syntax</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0005/</fr:uri>
                        <fr:display-uri>0005</fr:display-uri>
                        <fr:route>/notes/0005/</fr:route>
                        <fr:title text="Syntax">Syntax</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Using BNF notation, the syntax of propositional logic can be defined as follows:</html:p>
 
  
  <html:figure><fr:resource hash="aeb968467886f85e1939e467d64293d7"><fr:resource-content><html:img src="/notes/aeb968467886f85e1939e467d64293d7.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
 
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}

  % A TikZ style for curved arrows of a fixed height, due to AndrÃ©C.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {align*}
    \text {Atom} \quad  \alpha  &::= p \mid  q \mid  r \mid  \top  \mid  \bot  \\
    \text {Literal} \quad  l &::= \alpha  \mid  \neg  \alpha  \\
    \text {Formula} \quad  F &::= l \mid  \neg  F  \mid  (F \land  F) \mid  (F \lor  F) \mid  (F \to  F) \mid  (F \leftrightarrow  F)
  \end {align*}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0006/</fr:uri>
                        <fr:display-uri>0006</fr:display-uri>
                        <fr:route>/notes/0006/</fr:route>
                        <fr:title text="Evaluating Syntax">Evaluating Syntax</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:ol><html:li><html:strong>Is <fr:tex display="inline"><![CDATA[p]]></fr:tex> an atom?</html:strong></html:li>
  <html:li><html:strong>Is <fr:tex display="inline"><![CDATA[p]]></fr:tex> a literal?</html:strong></html:li>
  <html:li><html:strong>Is <fr:tex display="inline"><![CDATA[p]]></fr:tex> a formula?</html:strong></html:li>
  <html:li><html:strong>What about <fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex>?</html:strong></html:li>
  <html:li><html:strong>What about <fr:tex display="inline"><![CDATA[\neg  \neg  p]]></fr:tex>? </html:strong></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>
      Yes, <fr:tex display="inline"><![CDATA[p]]></fr:tex> is an atom.
    </html:li>
    <html:li>
      Yes, <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a literal. Literals are either atoms or negated atoms, and since <fr:tex display="inline"><![CDATA[p]]></fr:tex> is an atom, it is also a literal.
    </html:li>
    <html:li>
      Yes, <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a formula. Formulas can be literals, and since <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a literal, it is also a formula.
    </html:li>
    <html:li><fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex> is not an atom, but it is a literal (as it is a negated atom) and therefore also a formula.
    </html:li>
    <html:li><fr:tex display="inline"><![CDATA[\neg  \neg  p]]></fr:tex> is a formula, since the inner negation <fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex> is a literal and any additional negation applied promotes it to a formula. In other words only <html:em>negated atoms</html:em> are literals but <html:em>negated literals</html:em> are formulas. This is especially important when we later discuss Negation Normal Form (NNF). 
    </html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Semantics &amp; Intepretations">Semantics &amp; Intepretations</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0007/</fr:uri>
                        <fr:display-uri>0007</fr:display-uri>
                        <fr:route>/notes/0007/</fr:route>
                        <fr:title text="Semantics">Semantics</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>We can define the semantic inference rules for propositional logic formulas under interpretations as follows inductively, starting with the base cases:</html:p>
  
    
    <fr:resource hash="98f1ded5c64073562293977be012aa77"><fr:resource-content><html:img src="/notes/98f1ded5c64073562293977be012aa77.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Atom-$\top $]{
    I(p) = \top 
  }{
    I \models  p
  }
  \and 
  \inferrule *[right=Atom-$\bot $]{
    I(p) = \bot 
  }{
    I \not \models  p
  }
  \and 
  \inferrule *[right=True]{
  }{
    I \models  \top 
  }
  \and 
  \inferrule *[right=False]{
  }{
    I \not \models  \bot 
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>Moving on to the inductive case we have</html:p>
  
    
    <fr:resource hash="9e66b8d3c6180df36be5c59336932e10"><fr:resource-content><html:img src="/notes/9e66b8d3c6180df36be5c59336932e10.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Neg-$\top $]{
    I \models  \neg  F
  }{
    I \not \models  F
  }
  \and  
  \inferrule *[right=Conj-$\top $]{
    I \models  F_1 \quad  I \models  F_2
  }{
    I \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=Disj-$\top $]{
    I \models  F_1 \quad  \text {or} \quad  I \models  F_2
  }{
    I \models  F_1 \lor  F_2
  }
  \and  
  \inferrule *[right=Imp-$\top $]{
    I \not \models  F_1 \quad  \text {or} \quad  I \models  F_2
  }{
    I \models  F_1 \to  F_2
  }
  \and 
  \inferrule *[right=Contr-$\top $]{
    I \models  F \\ I \not \models  F
  }{
    I \models  \bot 
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>
Similarly, the rules for when an interpretation does not satisfy a formula are as follows:
</html:p>
  
    
    <fr:resource hash="94c0fb6507f78107d95fffce5b28eb60"><fr:resource-content><html:img src="/notes/94c0fb6507f78107d95fffce5b28eb60.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Neg-$\bot $]{
    I \not \models  \neg  F
  }{
    I \models  F
  }
  \and  
  \inferrule *[right=Conj-$\bot $]{
    I \not \models  F_1 \quad  \text {or} \quad  I \not \models  F_2
  }{
    I \not \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=Disj-$\bot $]{
    I \not \models  F_1 \\ I \not \models  F_2
  }{
    I \not \models  F_1 \lor  F_2
  }
  \and  
  \inferrule *[right=Imp-$\bot $]{
    I \models  F_1 \\ I \not \models  F_2
  }{
    I \not \models  F_1 \to  F_2
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0008/</fr:uri>
                        <fr:display-uri>0008</fr:display-uri>
                        <fr:route>/notes/0008/</fr:route>
                        <fr:title text="Interpretation">Interpretation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We define an interpretation as a function which maps propositional variables in a formula to truth values, so formally</html:p>
                        <fr:tex display="block"><![CDATA[
  I : \texttt {Var} \to  \{\top , \bot \}
]]></fr:tex>
                        <html:p>We can <html:em>evaluate</html:em> a formula <html:em>under</html:em> an interpretation <fr:tex display="inline"><![CDATA[I]]></fr:tex> by substituting each propositional variable with its corresponding truth value given by <fr:tex display="inline"><![CDATA[I]]></fr:tex>. Naturally under different kinds of interpretations formulas can evaluate to different truth values. We can create a classifcation of formulas based on how many interpretations evaluate them to true or false.</html:p>
                        <html:ol><html:li><html:strong>satisfiable</html:strong>: A formula is satisfiable if there exists at least one interpretation under which it evaluates to true.</html:li>
  <html:li><html:strong>unsatisfying</html:strong>: A formula is unsatisfying if there exists at least one interpretation under which it evaluates to false.</html:li>
  <html:li><html:strong>tautology</html:strong>: A formula is a tautology if it evaluates to true under every possible interpretation.</html:li>
  <html:li><html:strong>contradiction</html:strong>: A formula is a contradiction if it evaluates to false under every possible interpretation.</html:li>
  <html:li><html:strong>contingent</html:strong>: A formula is contingent if it is satisfiable and unsatisfying, i.e., there exists at least one interpretation under which it evaluates to true and at least one interpretation under which it evaluates to false.</html:li></html:ol>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0009/</fr:uri>
                        <fr:display-uri>0009</fr:display-uri>
                        <fr:route>/notes/0009/</fr:route>
                        <fr:title text="Evaluating PL Formulae">Evaluating PL Formulae</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>
  Consider the formula 
  <fr:tex display="inline"><![CDATA[
    F \triangleq  (\neg  p \land  q)
  ]]></fr:tex>
  and interpretation 
  <fr:tex display="inline"><![CDATA[
    I \triangleq  \{p \to  \top , q \to  \bot \}
  ]]></fr:tex>
  Which of the following is true
</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[I \models  F]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[I \nvDash  F]]></fr:tex></html:li></html:ol><html:strong>
  What about the formula
  <fr:tex display="block"><![CDATA[
    (p \land  q) \to  (\neg  p \lor  q)
  ]]></fr:tex>
  under the same interpretation?
</html:strong>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  Theres two main ways you can usually approach questions like this, the more drawn out operational way and then just going by observation more or less. Starting out with the more pedantic approach we can try to construct a proof tree for the formula under the given interpretation. So considering the first formula we have: 
  
  
    
    <fr:resource hash="bf7ed9631e84666547b9f155ffe495f8"><fr:resource-content><html:img src="/notes/bf7ed9631e84666547b9f155ffe495f8.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
    \inferrule {
      \inferrule {
        \inferrule {
          I(p) = \top 
        }{
          I \models  p
        }
      }{
        I \nvDash  \neg  p
      }
      \quad 
      \inferrule {
        \inferrule {
          I(q) = \bot 
        }{
          I \nvDash  q
        }
      }{
        I \nvDash  q
      }
    }{
      I \nvDash  (\neg  p \land  q)
    }
  \end {mathpar}]]></fr:resource-source></fr:resource>
  


  <html:p>So we can see that the interpretation does not satisfy the formula. In other words for this assignment the formula does not hold true. Given that this is a somewhat simple formula we could also just see this by observation, i.e. </html:p>
  <fr:tex display="block"><![CDATA[
    \underbrace {\neg  p}_{\texttt {False}} \land  \underbrace {q}_{\texttt {False}} \equiv  \bot 
  ]]></fr:tex>
  <html:p>For the second formula lets just go with the simpler approach again, so we have</html:p>
  <fr:resource hash="f4ab80a835ec37191d2964edcfdc39a1"><fr:resource-content><html:img src="/notes/f4ab80a835ec37191d2964edcfdc39a1.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
    \usepackage {amsmath}
    \usepackage {eulervm}
    \usepackage [scaled=0.92]{inconsolata} 

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        {\small
      \begin{align*}
          (p \land q) \to (\neg p \lor q) &\equiv (\texttt{true} \land \texttt{false}) \to (\neg \texttt{true} \lor \texttt{false}) \tag{by $I$}\\
      &\equiv \texttt{false} \to (\texttt{false} \lor \texttt{false}) \\
      &\equiv \texttt{false} \to \texttt{false} \\
      &\equiv \texttt{true} \tag{vacuously true} 
      \end{align*}
    }
  ]]></fr:resource-source></fr:resource>

  <html:p>So in this case the formula is satisfied by the interpretation.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000a/</fr:uri>
                        <fr:display-uri>000a</fr:display-uri>
                        <fr:route>/notes/000a/</fr:route>
                        <fr:title text="Evaluating sat/unsat/valid">Evaluating sat/unsat/valid</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Are the following formulas sat., unsat., or valid?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[(p\land  q) \to  \neg  p]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[(p \land  q) \to  (p \lor  \neg  q)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[(p \to  (q \to  r)) \land  \neg ((p \land  q) \to  r)]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  As a reminder lets recap the definitions:
  <html:ul><html:li>A formula is <html:strong>satisfiable</html:strong> if there exists at least one combination of true/false assignments to its variables that makes the formula true.</html:li>
    <html:li>A formula is <html:strong>unsatisfiable</html:strong> if there is no combination of true/false assignments to its variables that makes the formula true (i.e., it is always false).</html:li>
    <html:li>A formula is <html:strong>valid</html:strong> (or a tautology) if it is true under all possible combinations of true/false assignments to its variables.</html:li></html:ul>
  <html:p>Now we can analyze each formula:</html:p>
  <html:ol><html:li>For the lhs to be true both p and q must be true. However if p is true then <fr:tex display="inline"><![CDATA[\neg  p]]></fr:tex> is false, making the implication false. If p is false then the then the implication is vacuously true regardless of what we set q to. Thus this formula is satisfiable (e.g., when p is false) but not valid (e.g., when p and q are true).</html:li>
    <html:li>If both p and q are true then the lhs is true and so is the rhs by virtue of p being true. If p is false then the implication is vacuously true regardless of q. If q is false then the rhs is true regardless of p. Thus this formula is valid as it is true for all combinations of truth values for p and q.</html:li>
    <html:li>The first part <fr:tex display="inline"><![CDATA[(p \to  (q \to  r))]]></fr:tex> is true unless p is true and either q or r is false. The second part <fr:tex display="inline"><![CDATA[\neg ((p \land  q) \to  r)]]></fr:tex> is true when p and q are true but r is false. Thus we can satisfy the entire formula by setting p and q to true and r to false. However if we set p to false then the first part is vacuously true but the second part becomes false. Thus this formula is satisfiable (e.g., when p and q are true and r is false) but not valid (e.g., when p is false).</html:li></html:ol>

  If you want to be absolutely sure about these kinds of questions constructing truth tables is always a good idea, albeit a bit tedious for formulas with many variables so just doing a bit of analysis like above is usually sufficient
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/000b/</fr:uri>
                <fr:display-uri>000b</fr:display-uri>
                <fr:route>/notes/000b/</fr:route>
                <fr:title text="Lecture 2 - Normal Forms &amp; DPLL">Lecture 2 - Normal Forms &amp; DPLL</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Formula Equivalence">Formula Equivalence</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000c/</fr:uri>
                        <fr:display-uri>000c</fr:display-uri>
                        <fr:route>/notes/000c/</fr:route>
                        <fr:title text="Equivalence of Formulae">Equivalence of Formulae</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  Two formulas <fr:tex display="inline"><![CDATA[F]]></fr:tex> and <fr:tex display="inline"><![CDATA[G]]></fr:tex> are said to be <html:strong>equivalent</html:strong>, written <fr:tex display="inline"><![CDATA[F \equiv  G]]></fr:tex>, if they have the same truth value under every interpretation. In other words, for every interpretation <fr:tex display="inline"><![CDATA[I]]></fr:tex>, <fr:tex display="inline"><![CDATA[I \models  F]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[I \models  G]]></fr:tex>.
</html:p>
                        <fr:tex display="block"><![CDATA[
  F \equiv  G \iff  \forall  I (I \models  F \iff  I \models  G)
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000d/</fr:uri>
                        <fr:display-uri>000d</fr:display-uri>
                        <fr:route>/notes/000d/</fr:route>
                        <fr:title text="Normal Forms &amp; DPLL - Equivalence">Normal Forms &amp; DPLL - Equivalence</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Which of the following equivalences hold?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[\bot  \equiv  \bot ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\top  \equiv  \top ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  \top  \equiv  \neg  \bot ]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  (p \land  q) \equiv  \neg  p \lor  \neg  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \equiv  p \lor  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\neg  \neg  p \equiv  p]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>True. Both sides are always false.</html:li>
    <html:li>True. Both sides are always true.</html:li>
    <html:li>False. Left side is always false, right side is always true.</html:li>
    <html:li>True. This is <fr:link href="/notes/000g/" title="De Morgan's Laws" uri="https://kaierikniermann.github.io/notes/000g/" display-uri="000g" type="local">De Morgan's law</fr:link>. Good to remember 
      <fr:tex display="block"><![CDATA[
        \neg  (p \land  q) \equiv  \neg  p \lor  \neg  q
      ]]></fr:tex></html:li>
    <html:li>False. Left side is true when p is true, right side is true when either p or q is true.</html:li>
    <html:li>True. Double negation elimination.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Negation Normal Forms">Negation Normal Forms</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000e/</fr:uri>
                        <fr:display-uri>000e</fr:display-uri>
                        <fr:route>/notes/000e/</fr:route>
                        <fr:title text="Negation Normal Form (NNF)">Negation Normal Form (NNF)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is in Negation Normal Form (NNF) if the negation operator <fr:tex display="inline"><![CDATA[\neg ]]></fr:tex> is onyl applied to literlas (i.e., propositional variables or their negations), and the only other allowed operators are conjunction <fr:tex display="inline"><![CDATA[\land ]]></fr:tex> and disjunction <fr:tex display="inline"><![CDATA[\lor ]]></fr:tex>. A nice way to think about it is that we can never have the case where we need to apply <fr:link href="/notes/000g/" title="De Morgan's Laws" uri="https://kaierikniermann.github.io/notes/000g/" display-uri="000g" type="local">De Morgan's laws</fr:link> to push negations further down the formula tree. So all negations come pre-distributed to the literals.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000f/</fr:uri>
                        <fr:display-uri>000f</fr:display-uri>
                        <fr:route>/notes/000f/</fr:route>
                        <fr:title text="Negation Normal Form (NNF)">Negation Normal Form (NNF)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Which of the following formulas are in Negation Normal Form (NNF)?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[p \to  q]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q  \land  (r \lor  \neg  s))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q \land  \neg  (\neg  r \land  s))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p \lor  (\neg  q \land  (\neg  \neg  r \lor  \neg  s)) ]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>No. The implication operator <fr:tex display="inline"><![CDATA[\to ]]></fr:tex> is not allowed in NNF.</html:li>
    <html:li>Yes. Negations are only applied to literals, and only <fr:tex display="inline"><![CDATA[\land ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lor ]]></fr:tex> are used.</html:li>
    <html:li>No. The negation operator <fr:tex display="inline"><![CDATA[\neg ]]></fr:tex> is applied to a non-literal formula <fr:tex display="inline"><![CDATA[(\neg  r \land  s)]]></fr:tex>.</html:li>
    <html:li>No. The double negation <fr:tex display="inline"><![CDATA[\neg  \neg  r]]></fr:tex> is not allowed in NNF. Important to remember since that can trip you up.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Disjunctive Normal Form">Disjunctive Normal Form</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000k/</fr:uri>
                        <fr:display-uri>000k</fr:display-uri>
                        <fr:route>/notes/000k/</fr:route>
                        <fr:title text="Distributing Conjunction">Distributing Conjunction</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The distributive law of conjunction over disjunction states that for any formulas <fr:tex display="inline"><![CDATA[F]]></fr:tex>, <fr:tex display="inline"><![CDATA[G]]></fr:tex>, and <fr:tex display="inline"><![CDATA[H]]></fr:tex>, the following equivalence holds:</html:p>
                        <fr:tex display="block"><![CDATA[
  \begin {align*}
    F \land  (G \lor  H) &\equiv  (F \land  G) \lor  (F \land  H) \\
    (F \lor  G) \land  H &\equiv  (F \land  H) \lor  (G \land  H)
  \end {align*}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000j/</fr:uri>
                        <fr:display-uri>000j</fr:display-uri>
                        <fr:route>/notes/000j/</fr:route>
                        <fr:title text="Eliminating Implications and Biconditionals">Eliminating Implications and Biconditionals</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>To eliminate implications (<fr:tex display="inline"><![CDATA[\to ]]></fr:tex>) and biconditionals (<fr:tex display="inline"><![CDATA[\leftrightarrow ]]></fr:tex>) from a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex>, we can use the following equivalences:</html:p>
                        <fr:tex display="block"><![CDATA[
  \begin {align*}
    p \to  q &\equiv  \neg  p \lor  q \\
    p \leftrightarrow  q &\equiv  (p \land  q) \lor  (\neg  p \land  \neg  q)
  \end {align*}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000h/</fr:uri>
                        <fr:display-uri>000h</fr:display-uri>
                        <fr:route>/notes/000h/</fr:route>
                        <fr:title text="Disjunctive Normal Form (DNF)">Disjunctive Normal Form (DNF)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is in Disjunctive Normal Form (DNF) if it is a disjunction of one or more conjunctions of one or more literals. In other words, <fr:tex display="inline"><![CDATA[F]]></fr:tex> can be expressed as a series of clauses connected by disjunctions (<fr:tex display="inline"><![CDATA[\lor ]]></fr:tex>), where each clause is a series of literals connected by conjunctions (<fr:tex display="inline"><![CDATA[\land ]]></fr:tex>). A literal is either a propositional variable or its negation.</html:p>
                        <fr:tex display="block"><![CDATA[
  F = C_1 \lor  C_2 \lor  ... \lor  C_n
]]></fr:tex>
                        <html:p>Where each clause <fr:tex display="inline"><![CDATA[C_i]]></fr:tex> is of the form:</html:p>
                        <fr:tex display="block"><![CDATA[
  C_i = L_{i1} \land  L_{i2} \land  ... \land  L_{im}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000l/</fr:uri>
                        <fr:display-uri>000l</fr:display-uri>
                        <fr:route>/notes/000l/</fr:route>
                        <fr:title text="Converting to DNF">Converting to DNF</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Convert the following formula into Disjunctive Normal Form (DNF):</html:p><fr:tex display="block"><![CDATA[
  (q \lor  \neg  \neg  p) \land  (\neg  r \to  s)
]]></fr:tex>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <fr:resource hash="0ed774c5f98ccbf4fe2a8d866cb96b0e"><fr:resource-content><html:img src="/notes/0ed774c5f98ccbf4fe2a8d866cb96b0e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
    \usepackage {amsmath}
    \usepackage {eulervm}
    \usepackage [scaled=0.92]{inconsolata} 
  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        {\small
      \begin{align*}
        & (q \lor \neg \neg p) \land (\neg r \to s) \\
        & \equiv (q \lor p) \land (r \lor s) \tag{Eliminate Implication} \\
        & \equiv ((q \lor p) \land r) \lor ((q \lor p) \land s) \tag{Distribute Conjunction} \\
        & \equiv (q \land r) \lor (p \land r) \lor (q \land s) \lor (p \land s) \tag{Distribute Conjunction} \\
      \end{align*}
    }
  ]]></fr:resource-source></fr:resource>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000q/</fr:uri>
                        <fr:display-uri>000q</fr:display-uri>
                        <fr:route>/notes/000q/</fr:route>
                        <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Two formulas are said to be <html:strong>equisatisfiable</html:strong> if either both formulas are satisfiable or both are unsatisfiable. In other words, there exists an assignment of truth values to the variables that makes one formula true if and only if there exists; not necessarily the same assignment; that makes the other formula true. Equisatisfiability is a weaker condition than logical equivalence, as equisatisfiable formulas may not have the same truth values under all assignments, but they share the same satisfiability status.</html:p>
                        <fr:tex display="block"><![CDATA[
  \texttt {equisat}(F, G) \iff  (\exists  I.\ I \models  F) \iff  (\exists  J.\ J \models  G)
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000r/</fr:uri>
                        <fr:display-uri>000r</fr:display-uri>
                        <fr:route>/notes/000r/</fr:route>
                        <fr:title text="Equisatisfiability">Equisatisfiability</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> and <fr:tex display="inline"><![CDATA[G]]></fr:tex> are equisatisfiable, then are they equivalent?</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  No. We can answer this in a few different ways. In the most direct sense they are just definitionally not the same thing, in that equivalence requires that both formulas have the same truth value under all interpretations, whereas equisatisfiability only requires that both formulas have <html:em>a</html:em> satisfying interpretation or both be unsatisfiable.

  Another way to see it is that in an abstract sense equivalence describes an object-level relationship between formulas, whereas equisatisfiability describes a meta-level relationship about the existence of satisfying interpretations. Thus they are fundamentally different kinds of relationships.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Tseitin Transformation">Tseitin Transformation</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000n/</fr:uri>
                        <fr:display-uri>000n</fr:display-uri>
                        <fr:route>/notes/000n/</fr:route>
                        <fr:title text="Conjunctive Normal Form (CNF)">Conjunctive Normal Form (CNF)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  A formula is in <html:strong>Conjunctive Normal Form (CNF)</html:strong> if it is expressed as a conjunction of disjunctions of literals. In other words, a CNF formula is a series of clauses (disjunctions) connected by AND operators. Each clause contains literals (variables or their negations) connected by OR operators. For example, the formula <fr:tex display="inline"><![CDATA[(p \lor  \neg  q) \land  (r \lor  s \lor  \neg  t)]]></fr:tex> is in CNF.
</html:p>
                        <fr:tex display="block"><![CDATA[
  F = C_1 \land  C_2 \land  ... \land  C_n
]]></fr:tex>
                        <html:p>Where each clause <fr:tex display="inline"><![CDATA[C_i]]></fr:tex> is of the form:</html:p>
                        <fr:tex display="block"><![CDATA[
  C_i = L_{i1} \lor  L_{i2} \lor  ... \lor  L_{im}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000m/</fr:uri>
                        <fr:display-uri>000m</fr:display-uri>
                        <fr:route>/notes/000m/</fr:route>
                        <fr:title text="Exponential Blow up problem">Exponential Blow up problem</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>
  When converting a formula to Disjunctive Normal Form (DNF) or Conjunctive Normal Form (CNF), the size of the resulting formula can grow exponentially in the worst case. This is known as the <html:strong>exponential blow up problem</html:strong>. For example, a formula with <fr:tex display="inline"><![CDATA[n]]></fr:tex> variables can result in a DNF or CNF with up to <fr:tex display="inline"><![CDATA[2^n]]></fr:tex> clauses.
</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000s/</fr:uri>
                        <fr:display-uri>000s</fr:display-uri>
                        <fr:route>/notes/000s/</fr:route>
                        <fr:title text="Tseytin's Transformation">Tseytin's Transformation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Tseytin's transformation is a method used in propositional logic to convert any given formula into an equisatisfiable formula in <fr:link href="/notes/000n/" title="Conjunctive Normal Form (CNF)" uri="https://kaierikniermann.github.io/notes/000n/" display-uri="000n" type="local">Conjunctive Normal Form (CNF)</fr:link>. The key idea behind Tseytin's transformation is to introduce new variables to represent subformulas of the original formula, thereby avoiding <fr:link href="/notes/000m/" title="Exponential Blow up problem" uri="https://kaierikniermann.github.io/notes/000m/" display-uri="000m" type="local">an exponential increase in size</fr:link> that can occur with naive CNF conversion methods. There are two key properties of Tseytin's for a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> and its Tseytin transformation <fr:tex display="inline"><![CDATA[F']]></fr:tex>:</html:p>
                        <html:ol><html:li><html:strong>unsatisfiability:</html:strong> <fr:tex display="inline"><![CDATA[F]]></fr:tex> is unsatisfiable if and only if <fr:tex display="inline"><![CDATA[F']]></fr:tex> is unsatisfiable.</html:li>
  <html:li><html:strong>model correspondence:</html:strong> For every satisfying assignment (model) of <fr:tex display="inline"><![CDATA[F']]></fr:tex>, there exists a corresponding satisfying assignment of <fr:tex display="inline"><![CDATA[F]]></fr:tex>, and vice versa, when restricted to the original variables of <fr:tex display="inline"><![CDATA[F]]></fr:tex>.</html:li></html:ol>
                        <html:p>To demonstrate how it works lets consider the following formula</html:p>
                        <fr:tex display="block"><![CDATA[
  \phi  = ((p \lor  q ) \land  r) \to  (\neg  s)
]]></fr:tex>
                        <html:ol><html:li><html:strong>Subformula identification:</html:strong> Identify the subformulas of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> and assign a new variable to each subformula. For our example, we can identify the following subformulas and assign new variables:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & \neg  s \\ 
      & p \lor  q \\
      & (p \lor  q) \land  r \\
      & ((p \lor  q) \land  r) \to  (\neg  s)
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Variable assignment:</html:strong> Assign new variables to each subformula:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & x_1 \text { for } \neg  s \\ 
      & x_2 \text { for } p \lor  q \\
      & x_3 \text { for } (p \lor  q) \land  r \\
      & x_4 \text { for } ((p \lor  q) \land  r) \to  (\neg  s)
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Equivalence clauses:</html:strong> For each subformula, create clauses that enforce the equivalence between the new variable and the subformula it represents. For our example, we would create the following clauses:
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      & (x_1 \leftrightarrow  \neg  s) \\
      & (x_2 \leftrightarrow  (p \lor  q)) \\
      & (x_3 \leftrightarrow  (x_2 \land  r)) \\
      & (x_4 \leftrightarrow  (x_3 \to  x_1))
      \end {align*}
    ]]></fr:tex></html:li>
  <html:li><html:strong>Conjunct of clauses:</html:strong> Combine all the equivalence clauses into a single formula in CNF. The final formula <fr:tex display="inline"><![CDATA[\phi ']]></fr:tex> will be the conjunction of all these clauses along with the clause that asserts the truth of the variable representing the entire formula (in this case, <fr:tex display="inline"><![CDATA[x_4]]></fr:tex>):
    <fr:tex display="block"><![CDATA[
      \phi ' = (x_1 \leftrightarrow  \neg  s) \land  (x_2 \leftrightarrow  (p \lor  q)) \land  (x_3 \leftrightarrow  (x_2 \land  r)) \land  (x_4 \leftrightarrow  (x_3 \to  x_1)) \land  x_4
    ]]></fr:tex></html:li>
  <html:li><html:strong>Conversion to CNF:</html:strong> Finally, convert the combined formula into CNF using standard techniques (like distributing disjunctions over conjunctions). The resulting formula will be in CNF and equisatisfiable to the original formula <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>. For example if we consider the clause 
    <fr:tex display="block"><![CDATA[
      x_2 \leftrightarrow  (p \lor  q)
    ]]></fr:tex> this can be converted to CNF as
    <fr:tex display="block"><![CDATA[
      (x_2 \lor  \neg  p) \land  (x_2 \lor  \neg  q) \land  (\neg  x_2 \lor  p \lor  q)
    ]]></fr:tex></html:li></html:ol>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000t/</fr:uri>
                        <fr:display-uri>000t</fr:display-uri>
                        <fr:route>/notes/000t/</fr:route>
                        <fr:title text="Tseytin's Transformation">Tseytin's Transformation</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Lets consider the following formula</html:p><fr:tex display="block"><![CDATA[
  F \triangleq  (p \land  q) \lor  (p \land  \neg  r \land  s)
]]></fr:tex><html:p>Using Tseytin's transformation, convert the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> into an equisatisfiable formula in CNF.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  For the sake of breavity, lets skip assume the subformula extraction is already done and we created the following equivalence clauses:
  <fr:tex display="block"><![CDATA[
    \begin {align*}
    F_1 &\triangleq  t_1 \leftrightarrow  (\neg  r \land  s) \\
    F_2 &\triangleq  t_2 \leftrightarrow  (p \land  t_1) \\
    F_3 &\triangleq  t_3 \leftrightarrow  (p \land  q) \\
    F_4 &\triangleq  t_4 \leftrightarrow  (t_2 \lor  t_3)
    \end {align*}
  ]]></fr:tex>
  This gives us the following conjunct for the transformed formula:
  <fr:tex display="block"><![CDATA[
    F' \triangleq  F_1 \land  F_2 \land  F_3 \land  F_4 \land  t_4
  ]]></fr:tex>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://kaierikniermann.github.io/notes/000u/</fr:uri>
                <fr:display-uri>000u</fr:display-uri>
                <fr:route>/notes/000u/</fr:route>
                <fr:title text="Lecture 3 - First Order Logic">Lecture 3 - First Order Logic</fr:title>
                <fr:taxon>VU-VFS-2025</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Syntax">Syntax</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000v/</fr:uri>
                        <fr:display-uri>000v</fr:display-uri>
                        <fr:route>/notes/000v/</fr:route>
                        <fr:title text="FOL - Syntax">FOL - Syntax</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We can define a first order language as a tuple of 3 sets <fr:tex display="inline"><![CDATA[\langle  \mathcal  C, \mathcal  F, \mathcal  R\rangle ]]></fr:tex> where:</html:p>
                        <html:ul><html:li><html:strong>Constants</html:strong> (<fr:tex display="inline"><![CDATA[\mathcal  C]]></fr:tex>): the set of constants in the language. E.g., <fr:tex display="inline"><![CDATA[\{a, b, c\}]]></fr:tex></html:li>
  <html:li><html:strong>Function Symbols</html:strong> (<fr:tex display="inline"><![CDATA[\mathcal  F]]></fr:tex>): the set of function symbols in the language. E.g., <fr:tex display="inline"><![CDATA[\{f, g, h\}]]></fr:tex></html:li>
  <html:li><html:strong>Relation Symbols</html:strong> (<fr:tex display="inline"><![CDATA[\mathcal  R]]></fr:tex>): the set of relation symbols in the language. E.g., <fr:tex display="inline"><![CDATA[\{R, S, T\}]]></fr:tex></html:li></html:ul>
                        <html:p>Using BNF we can define the syntax as follows</html:p>
                        <fr:resource hash="18b8dd7c29a3cc72847fbb5fc08ba8f0">
                          <fr:resource-content>
                            <html:img src="/notes/18b8dd7c29a3cc72847fbb5fc08ba8f0.svg" />
                          </fr:resource-content>
                          <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {amsmath}
  \usepackage {eulervm}
]]></fr:resource-source>
                          <fr:resource-source type="latex" part="body"><![CDATA[
{\small  
  \begin {align*}
    \text {Atom} \quad  \alpha  &::= \top  \mid  \bot  \mid  p(t_1, \ldots , t_n) \\
    \text {Formula} \quad  F &::= \alpha  \mid  \neg  F  \mid  (F \land  F) \mid  (F \lor  F) \mid  (F \to  F) \mid  (F \leftrightarrow  F) \mid  \forall  x.\ F \mid  \exists  x.\ F \\
  \end {align*}
}
]]></fr:resource-source>
                        </fr:resource>
                        <html:p>Here the atom <fr:tex display="inline"><![CDATA[p]]></fr:tex> rerpesents an <html:em>atomic predicate</html:em> applied to terms <fr:tex display="inline"><![CDATA[t_1, \ldots , t_n]]></fr:tex>, where <fr:tex display="inline"><![CDATA[p \in  \mathcal  R]]></fr:tex> with an arity of <fr:tex display="inline"><![CDATA[n]]></fr:tex></html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000w/</fr:uri>
                        <fr:display-uri>000w</fr:display-uri>
                        <fr:route>/notes/000w/</fr:route>
                        <fr:title text="First Order Logic - Syntax">First Order Logic - Syntax</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:strong>Which of the following are syntactically valid formulas in first order logic?</html:strong><html:ol><html:li><fr:tex display="inline"><![CDATA[f(x)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(x)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(f(x))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(p(x))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(f(f(x)))]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li><fr:tex display="inline"><![CDATA[f(x)]]></fr:tex>: <html:em>Invalid</html:em>, as <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a function symbol and cannot stand alone as a formula.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(x)]]></fr:tex>: <html:em>Valid</html:em>, as <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a relation symbol applied to the term <fr:tex display="inline"><![CDATA[x]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(f(x))]]></fr:tex>: <html:em>Valid</html:em>, as <fr:tex display="inline"><![CDATA[f(x)]]></fr:tex> is a term and <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a relation symbol applied to that term.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(p(x))]]></fr:tex>: <html:em>Invalid</html:em>, as <fr:tex display="inline"><![CDATA[p(x)]]></fr:tex> is a formula, not a term, and cannot be an argument to <fr:tex display="inline"><![CDATA[p]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(f(f(x)))]]></fr:tex>: <html:em>Valid</html:em>, as <fr:tex display="inline"><![CDATA[f(x)]]></fr:tex> is a term, and applying <fr:tex display="inline"><![CDATA[f]]></fr:tex> again yields another term, which can be an argument to <fr:tex display="inline"><![CDATA[p]]></fr:tex>.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Quantifiers &amp; Scoping">Quantifiers &amp; Scoping</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000x/</fr:uri>
                        <fr:display-uri>000x</fr:display-uri>
                        <fr:route>/notes/000x/</fr:route>
                        <fr:title text="FOL - Quantifiers and Scoping">FOL - Quantifiers and Scoping</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>For quantifiers:</html:p>
                        <fr:tex display="block"><![CDATA[
  \forall  x.\ F \quad  \exists  x.\ F
]]></fr:tex>
                        <html:p>Each variable occuring within the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> known as the <html:em>scope</html:em> is either:</html:p>
                        <html:ul><html:li><html:strong>bound</html:strong>: if it is within the scope of a quantifier that binds it. E.g., in <fr:tex display="inline"><![CDATA[\forall  x.\ P(x, y)]]></fr:tex>, the variable <fr:tex display="inline"><![CDATA[x]]></fr:tex> is bound.</html:li>
  <html:li><html:strong>free</html:strong>: if it is not bound by any quantifier within the formula. E.g., in <fr:tex display="inline"><![CDATA[\forall  x.\ P(x, y)]]></fr:tex>, the variable <fr:tex display="inline"><![CDATA[y]]></fr:tex> is free.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000y/</fr:uri>
                        <fr:display-uri>000y</fr:display-uri>
                        <fr:route>/notes/000y/</fr:route>
                        <fr:title text="Quantifiers and Scoping in FOL">Quantifiers and Scoping in FOL</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the formula</html:p><fr:tex display="block"><![CDATA[
  \forall  y.\ ((\forall  x.\ p(x))) \to  q(x, y)
]]></fr:tex><html:ol><html:li>Is the <fr:tex display="inline"><![CDATA[y]]></fr:tex> bound or free?</html:li>
  <html:li>Is the first occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> bound or free?</html:li>
  <html:li>Is the second occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> bound or free?</html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li><fr:tex display="inline"><![CDATA[y]]></fr:tex> is <html:em>bound</html:em>, as it is within the scope of the quantifier <fr:tex display="inline"><![CDATA[\forall  y]]></fr:tex>.</html:li>
    <html:li>The first occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> is <html:em>bound</html:em>, as it is within the scope of the quantifier <fr:tex display="inline"><![CDATA[\forall  x]]></fr:tex>.</html:li>
    <html:li>The second occurence of <fr:tex display="inline"><![CDATA[x]]></fr:tex> is <html:em>free</html:em>, as it is not within the scope of any quantifier that binds it.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Closed, Open &amp; Ground Formulas">Closed, Open &amp; Ground Formulas</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/000z/</fr:uri>
                        <fr:display-uri>000z</fr:display-uri>
                        <fr:route>/notes/000z/</fr:route>
                        <fr:title text="Closed, Open, and Ground Formulas (FOL)">Closed, Open, and Ground Formulas (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We have 3 important classifications of formulas in First Order Logic (FOL) based on the nature of their variables:</html:p>
                        <html:ul><html:li><html:strong>Closed Formula</html:strong>: A formula with <html:em>no free variables</html:em>. All variables in the formula are bound by quantifiers. E.g., <fr:tex display="inline"><![CDATA[\forall  x.\ \exists  y.\ p(x, y)]]></fr:tex> is a closed formula.</html:li>
  <html:li><html:strong>Open Formula</html:strong>: A formula with <html:em>at least one free variable</html:em>. E.g., <fr:tex display="inline"><![CDATA[p(x, y)]]></fr:tex> is an open formula since both <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> are free.</html:li>
  <html:li><html:strong>Ground Formula</html:strong>: A formula with <html:em>no variables at all</html:em>. E.g., <fr:tex display="inline"><![CDATA[p(a, b)]]></fr:tex> is a ground formula if <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> are constants.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0010/</fr:uri>
                        <fr:display-uri>0010</fr:display-uri>
                        <fr:route>/notes/0010/</fr:route>
                        <fr:title text="FOL - Closed, Open, and Ground Formulas">FOL - Closed, Open, and Ground Formulas</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following formula</html:p><fr:tex display="block"><![CDATA[
  \forall  y.\ ((\forall  x.\ p(x))) \to  (\exists  x.\ q(x, y))
]]></fr:tex><html:p>Is this formula closed, open, or ground?</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  This formula is a <html:strong>closed formula</html:strong> because all variables within the formula are bound by quantifiers. The variable <fr:tex display="inline"><![CDATA[y]]></fr:tex> is bound by the quantifier <fr:tex display="inline"><![CDATA[\forall  y]]></fr:tex>, and both occurrences of <fr:tex display="inline"><![CDATA[x]]></fr:tex> are bound by their respective quantifiers <fr:tex display="inline"><![CDATA[\forall  x]]></fr:tex> and <fr:tex display="inline"><![CDATA[\exists  x]]></fr:tex>. There are no free variables in this formula. 

  A nice example of a ground formula is something like this 
  <fr:tex display="block"><![CDATA[
    p(a, f(b)) \to  q(c)
  ]]></fr:tex>
  We can see here that there are no variables at all; <fr:tex display="inline"><![CDATA[a]]></fr:tex>, <fr:tex display="inline"><![CDATA[b]]></fr:tex>, and <fr:tex display="inline"><![CDATA[c]]></fr:tex> are not bound by any quantifiers, hence the formula is ground since we arent substituting/quantifying over any variables.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Term Evaluation">Term Evaluation</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0012/</fr:uri>
                        <fr:display-uri>0012</fr:display-uri>
                        <fr:route>/notes/0012/</fr:route>
                        <fr:title text="Interpretation (FOL)">Interpretation (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In first order logic a <html:em>Interpretation</html:em>; similar to the case of propositional logic; is a mapping which assigns meaning to the syntax of the language. In this instance its a mapping from constants, function symbols and predicate symbols to specific objects, functions and relations in a given domain. We can define an interpretation as a sort of piecewise function as follows:</html:p>
                        <fr:tex display="block"><![CDATA[
  \begin {align*}
    I &: \mathcal  C \cup  \mathcal  F \cup  \mathcal  R \to  D \cup  (D^n \to  D) \cup  (D^n \to  \{\top , \bot \}) \\
    I(c) & = d \quad  \forall  c \in  \mathcal  C, d \in  D \\
    I(f) & = f_D: D^n \to  D \quad  \forall  f \in  \mathcal  F \\
    I(p) & = p_D: D^n \to  \{\top , \bot \} \quad  \forall  p \in  \mathcal  R \\
  \end {align*}
]]></fr:tex>
                        <html:p>Where <fr:tex display="inline"><![CDATA[D]]></fr:tex> (sometimes also denoted as <fr:tex display="inline"><![CDATA[U]]></fr:tex>) is the <html:em>domain of discourse</html:em> which is a non-empty set of objects over which the quantifiers range. Intuitively the domain of discourse represents what we wish to talk about in our interpretation. We can break this down into 3 parts:</html:p>
                        <html:ul><html:li><html:strong>constants</html:strong> (<fr:tex display="inline"><![CDATA[c \in  \mathcal  C]]></fr:tex>): are mapped to specific elements in the domain <fr:tex display="inline"><![CDATA[d \in  D]]></fr:tex>. For example if <fr:tex display="inline"><![CDATA[c]]></fr:tex> is the constant <fr:tex display="inline"><![CDATA["a"]]></fr:tex> and <fr:tex display="inline"><![CDATA[D = \{1, 2, 3\}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[I(a) = 1]]></fr:tex> could be a valid mapping.</html:li>
  <html:li><html:strong>function symbols</html:strong> (<fr:tex display="inline"><![CDATA[f \in  \mathcal  F]]></fr:tex>): are mapped to functions that take elements from the domain and return elements in the domain. For example if <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a unary function symbol <fr:tex display="inline"><![CDATA["f"]]></fr:tex> and <fr:tex display="inline"><![CDATA[D = \{1, 2, 3\}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[I(f) = f_D]]></fr:tex> where <fr:tex display="inline"><![CDATA[f_D(1) = 2]]></fr:tex>, <fr:tex display="inline"><![CDATA[f_D(2) = 3]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f_D(3) = 1]]></fr:tex> could be a valid mapping.</html:li>
  <html:li><html:strong>relation symbols</html:strong> (<fr:tex display="inline"><![CDATA[p \in  \mathcal  R]]></fr:tex>): are mapped to relations (or predicates) that take elements from the domain and return truth values <fr:tex display="inline"><![CDATA[\{\top , \bot \}]]></fr:tex>. For example if <fr:tex display="inline"><![CDATA[p]]></fr:tex> is a binary relation symbol <fr:tex display="inline"><![CDATA["R"]]></fr:tex> and <fr:tex display="inline"><![CDATA[D = \{1, 2, 3\}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[I(R) = R_D]]></fr:tex> where <fr:tex display="inline"><![CDATA[R_D(1, 2) = \top ]]></fr:tex>, <fr:tex display="inline"><![CDATA[R_D(2, 3) = \bot ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[R_D(3, 1) = \top ]]></fr:tex> could be a valid mapping.</html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0013/</fr:uri>
                        <fr:display-uri>0013</fr:display-uri>
                        <fr:route>/notes/0013/</fr:route>
                        <fr:title text="Structures and Variable Assignments (FOL)">Structures and Variable Assignments (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A <html:strong>structure</html:strong> <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> for a first-order language <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex> consists of:</html:p>
                        <html:ul><html:li>A non-empty domain <fr:tex display="inline"><![CDATA[D]]></fr:tex>, which is the set of objects that the variables can refer to.</html:li>
  <html:li>An interpretation function <fr:tex display="inline"><![CDATA[I]]></fr:tex> that assigns meanings to the non-logical symbols in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>:</html:li>
  <html:ul><html:li>For each constant symbol <fr:tex display="inline"><![CDATA[c]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, <fr:tex display="inline"><![CDATA[I(c)]]></fr:tex> is an element of <fr:tex display="inline"><![CDATA[D]]></fr:tex>.</html:li>
    <html:li>For each n-ary function symbol <fr:tex display="inline"><![CDATA[f]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, <fr:tex display="inline"><![CDATA[I(f)]]></fr:tex> is a function from <fr:tex display="inline"><![CDATA[D^n]]></fr:tex> to <fr:tex display="inline"><![CDATA[D]]></fr:tex>.</html:li>
    <html:li>For each n-ary predicate symbol <fr:tex display="inline"><![CDATA[P]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}]]></fr:tex>, <fr:tex display="inline"><![CDATA[I(P)]]></fr:tex> is a subset of <fr:tex display="inline"><![CDATA[D^n]]></fr:tex>.</html:li></html:ul></html:ul>
                        <html:p>A <html:strong>variable assignment</html:strong> <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> for a structure <fr:tex display="inline"><![CDATA[S]]></fr:tex> is a function that assigns each variable to an element of the domain <fr:tex display="inline"><![CDATA[D]]></fr:tex> of the structure. That is, for each variable <fr:tex display="inline"><![CDATA[x]]></fr:tex>, <fr:tex display="inline"><![CDATA[\sigma (x) \in  D]]></fr:tex>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0011/</fr:uri>
                        <fr:display-uri>0011</fr:display-uri>
                        <fr:route>/notes/0011/</fr:route>
                        <fr:title text="Term evaluation (FOL)">Term evaluation (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In First Order Logic, terms are evaluated based on an <fr:link href="/notes/0012/" title="Interpretation (FOL)" uri="https://kaierikniermann.github.io/notes/0012/" display-uri="0012" type="local">interpretation</fr:link> <fr:tex display="inline"><![CDATA[I]]></fr:tex> and a <fr:link href="/notes/0013/" title="Structures and Variable Assignments (FOL)" uri="https://kaierikniermann.github.io/notes/0013/" display-uri="0013" type="local">variable assignment</fr:link> <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> within a structure <fr:tex display="inline"><![CDATA[S]]></fr:tex> denoted as <fr:tex display="inline"><![CDATA[\langle  I, \sigma \rangle (t)]]></fr:tex>. The evaluation rules are as follows:</html:p>
                        <html:ul><html:li>If <fr:tex display="inline"><![CDATA[t]]></fr:tex> is a constant symbol <fr:tex display="inline"><![CDATA[c]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\langle  I, \sigma \rangle (c) = I(c)]]></fr:tex>.</html:li>
  <html:li>If <fr:tex display="inline"><![CDATA[t]]></fr:tex> is a variable <fr:tex display="inline"><![CDATA[x]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\langle  I, \sigma \rangle (x) = \sigma (x)]]></fr:tex>.</html:li>
  <html:li>If <fr:tex display="inline"><![CDATA[t]]></fr:tex> is a function application <fr:tex display="inline"><![CDATA[f(t_1, t_2, \ldots , t_n)]]></fr:tex>, then 
    <fr:tex display="block"><![CDATA[
      \langle  I, \sigma \rangle (f(t_1, t_2, \ldots , t_n)) = I(f)(\langle  I, \sigma \rangle (t_1), \langle  I, \sigma \rangle (t_2), \ldots , \langle  I, \sigma \rangle (t_n))
    ]]></fr:tex></html:li></html:ul>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0014/</fr:uri>
                        <fr:display-uri>0014</fr:display-uri>
                        <fr:route>/notes/0014/</fr:route>
                        <fr:title text="Term evaluation (FOL)">Term evaluation (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following domain/universe of discourse, variable assignment, and interpretation:</html:p><html:ul><html:li>Universe 
  <fr:tex display="block"><![CDATA[
    U \triangleq  \{1, 2\}
  ]]></fr:tex></html:li>
  <html:li>Variable assignment
    <fr:tex display="block"><![CDATA[
      \sigma  \triangleq  \{x\mapsto  2, y\mapsto  1\}
    ]]></fr:tex></html:li>
  <html:li>
    Interpretation
    <fr:tex display="block"><![CDATA[
      \begin {align*}
        I & \triangleq  \{a \mapsto  1, b \mapsto  2\} \\ 
        I & \triangleq  \{f(1, 1) \mapsto  2, f(1, 2) \mapsto  2, f(2, 1) \mapsto  1, f(2, 2) \mapsto  1\} 
      \end {align*}
    ]]></fr:tex></html:li></html:ul><html:p>What is the evaluation of the following terms under the given interpretation and variable assignment?</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[f(a, y)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[f(x, b)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[f(f(x, b), f(a, y))]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:ol><html:li><fr:tex display="inline"><![CDATA[\langle  I, \sigma  \rangle  (f(a, y)) = I(f)(\langle  I, \sigma  \rangle  (a), \langle  I, \sigma  \rangle  (y)) = I(f)(I(a), \sigma (y)) = I(f)(1, 1) = 2]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\langle  I, \sigma  \rangle  (f(x, b)) = I(f)(\langle  I, \sigma  \rangle  (x), \langle  I, \sigma  \rangle  (b)) = I(f)(\sigma (x), I(b)) = I(f)(2, 2) = 1]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\langle  I, \sigma  \rangle  (f(f(x, b), f(a, y))) = I(f)(\langle  I, \sigma  \rangle  (f(x, b)), \langle  I, \sigma  \rangle  (f(a, y))) = I(f)(1, 2) = 2]]></fr:tex></html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Semantic Entailment">Semantic Entailment</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0015/</fr:uri>
                        <fr:display-uri>0015</fr:display-uri>
                        <fr:route>/notes/0015/</fr:route>
                        <fr:title text="Semantic Entailment \models  (FOL)">Semantic Entailment <fr:tex display="inline"><![CDATA[\models ]]></fr:tex> (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>We evaluate formulas in first order logic <html:em>under</html:em> a structure which consists of a domain and an interpretation function. In addition, we need a variable assignment to evaluate formulas with free variables. To denote truth under a structure <fr:tex display="inline"><![CDATA[S]]></fr:tex> and variable assignment <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex> we write:</html:p><html:ul><html:li><html:strong>True</html:strong>: If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> evaluates to true under <fr:tex display="inline"><![CDATA[U, I, \sigma ]]></fr:tex> we write <fr:tex display="block"><![CDATA[
    U, I, \sigma  \models  F
  ]]></fr:tex></html:li>
  <html:li><html:strong>False</html:strong>: If a formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> evaluates to false under <fr:tex display="inline"><![CDATA[U, I, \sigma ]]></fr:tex> we write <fr:tex display="block"><![CDATA[
    U, I, \sigma  \nvDash  F
  ]]></fr:tex></html:li></html:ul><html:p>We can define semantic entailment inductively as follows:</html:p>
  
    
    <fr:resource hash="bf38ef538d97d37abb4d5740fd4c5e05"><fr:resource-content><html:img src="/notes/bf38ef538d97d37abb4d5740fd4c5e05.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=True]{}{
    U, I, \sigma  \models  \top 
  }
  \and 
  \inferrule *[right=False]{}{
    U, I, \sigma  \not \models  \bot 
  }
  \and 
  \inferrule *[right=Eval]{
    p(t_1, \ldots , t_n) \\ I = \{p \mapsto  \langle  I, \sigma \rangle (t_1), \ldots , \langle  I, \sigma  \rangle (t_n)\}
  }{
    U, I, \sigma  \models  p(t_1, \ldots , t_n)
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0016/</fr:uri>
                        <fr:display-uri>0016</fr:display-uri>
                        <fr:route>/notes/0016/</fr:route>
                        <fr:title text="Semantic Entailment (FOL)">Semantic Entailment (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider constants (free variables) <fr:tex display="inline"><![CDATA[a, b]]></fr:tex> and a unary function <fr:tex display="inline"><![CDATA[f]]></fr:tex>, and a binary predicate <fr:tex display="inline"><![CDATA[p]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[U = \{\alpha , \beta \}]]></fr:tex> and interpretation function <fr:tex display="inline"><![CDATA[I]]></fr:tex> be defined as follows:</html:p><fr:tex display="block"><![CDATA[
  \begin {align*}
    I &= \{a \mapsto  \alpha , b \mapsto  \beta \} \\ 
    I &= \{f(\alpha ) \mapsto  \beta , f(\beta ) \mapsto  \alpha \} \\
    I &= \{p(\beta , \alpha ) \mapsto  \top , p(\beta , \beta ) \mapsto  \top \}
  \end {align*}
]]></fr:tex><html:p>Under the structure <fr:tex display="inline"><![CDATA[S = (U, I)]]></fr:tex> and variable assignment <fr:tex display="inline"><![CDATA[\sigma  = \{x \mapsto  \alpha \}]]></fr:tex> what do the following formulas evaluate to?</html:p><html:ol><html:li><fr:tex display="inline"><![CDATA[p(f(b), f(x))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(f(x), f(b))]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[p(a, f(x))]]></fr:tex></html:li></html:ol>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li><fr:tex display="inline"><![CDATA[p(f(b), f(x))]]></fr:tex> evaluates to <fr:tex display="inline"><![CDATA[\top ]]></fr:tex> because <fr:tex display="inline"><![CDATA[f(b) = f(\beta ) = \alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(x) = f(\alpha ) = \beta ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[p(\alpha , \beta ) = \top ]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(f(x), f(b))]]></fr:tex> evaluates to <fr:tex display="inline"><![CDATA[\top ]]></fr:tex> because <fr:tex display="inline"><![CDATA[f(x) = f(\alpha ) = \beta ]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(b) = f(\beta ) = \alpha ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[p(\beta , \alpha ) = \top ]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[p(a, f(x))]]></fr:tex> evaluates to <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex> because <fr:tex display="inline"><![CDATA[a = \alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[f(x) = f(\alpha ) = \beta ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[p(\alpha , \beta ) = \bot ]]></fr:tex>.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:title text="Semantic argument method">Semantic argument method</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0017/</fr:uri>
                        <fr:display-uri>0017</fr:display-uri>
                        <fr:route>/notes/0017/</fr:route>
                        <fr:title text="Connectives and Quantifiers (FOL)">Connectives and Quantifiers (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>In addition to evaluating atomic formulas, we can define the evaluation of complex formulas using logical connectives and quantifiers as follows:</html:p>
  
    
    <fr:resource hash="6def192365920c45e9f367e6b771acb3"><fr:resource-content><html:img src="/notes/6def192365920c45e9f367e6b771acb3.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Not-True]{
    S, \sigma  \not \models  F
  }{
    S, \sigma  \models  \neg  F
  }
  \and 
  \inferrule *[right=Not-False]{
    S, \sigma  \models  F
  }{
    S, \sigma  \not \models  \neg  F
  }
  \and 
  \inferrule *[right=And-True]{
    S, \sigma  \models  F_1 \\ S, \sigma  \models  F_2
  }{
    S, \sigma  \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=And-False]{
    S, \sigma  \not \models  F_1 \lor  S, \sigma  \not \models  F_2
  }{
    S, \sigma  \not \models  F_1 \land  F_2
  }
  \and 
  \inferrule *[right=Or-True]{
    S, \sigma  \models  F_1 \lor  S, \sigma  \models  F_2
  }{
    S, \sigma  \models  F_1 \lor  F_2 
  }
  \and 
  \inferrule *[right=Or-False]{
    S, \sigma  \not \models  F_1 \\ S, \sigma  \not \models  F_2
  }{
    S, \sigma  \not \models  F_1 \lor  F_2
  }
  \and 
  \inferrule *[right=Imp-True]{
    S, \sigma  \not \models  F_1 \lor  S, \sigma  \models  F_2
  }{
    S, \sigma  \models  F_1 \to  F_2
  }
  \and 
  \inferrule *[right=Imp-False]{
    S, \sigma  \models  F_1 \\ S, \sigma  \not \models  F_2
  }{
    S, \sigma  \not \models  F_1 \to  F_2
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>For the proof rules of quantifiers we have two variants depending on whether we are dealing with free or bound variables:</html:p>
  
    
    <fr:resource hash="ca7213d0553a10c29293a0ea1d9b5c87"><fr:resource-content><html:img src="/notes/ca7213d0553a10c29293a0ea1d9b5c87.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=$\forall $-$\top $]{
    S, \sigma  \models  x.\ F \\ \forall  d \in  D
  }{
    S, \sigma [x \mapsto  d] \models  \forall  F
  }
  \and 
  \inferrule *[right=$\forall $-$\bot $]{
    S, \sigma  \not \models  \exists  x.\ F \\ \exists  d \in  D
  }{
    S, \sigma [x \mapsto  d] \not \models  F
  }
  \and 
  \inferrule *[right=$\exists $-$\top $]{
    S, \sigma  \models  \exists  x.\ F \\ \exists  d \in  D
  }{
    S, \sigma [x \mapsto  d] \models  F
  }
  \and 
  \inferrule *[right=$\exists $-$\bot $]{
    S, \sigma  \not \models  \exists  x.\ F \\ \forall  d \in  D
  }{
    S, \sigma [x \mapsto  d] \not \models  F
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0018/</fr:uri>
                        <fr:display-uri>0018</fr:display-uri>
                        <fr:route>/notes/0018/</fr:route>
                        <fr:title text="Semantic Argument method (FOL)">Semantic Argument method (FOL)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>In first order logic, the <html:em>semantic argument method</html:em> represents a proof by contradiction. The basic idea is as follows:</html:p><html:ol><html:li>We assume that our formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is not valid, i.e., <fr:tex display="inline"><![CDATA[\exists  S, \sigma  \nvDash  F]]></fr:tex></html:li>
  <html:li>Use the proof rules to derive a contradiction from this assumption.</html:li>
  <html:li>If we can indeed derive a contradiction, we conclude that our initial assumption was false, and therefore <fr:tex display="inline"><![CDATA[F]]></fr:tex> must be valid.</html:li></html:ol><html:p>We can express the semantic argument method via the following inference rule:</html:p>
  
    
    <fr:resource hash="d9cae6dd020a28c2f7ee470a5e57854a"><fr:resource-content><html:img src="/notes/d9cae6dd020a28c2f7ee470a5e57854a.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Contradiction]{
    S, \sigma  \models  p(s_1, \ldots , s_n) \\
    S, \sigma  \models  \neg  p(t_1, \ldots , t_n) \\ 
    \langle  I, \sigma \rangle  (t_1) = \langle  I, \sigma \rangle  (s_1), \ldots , \langle  I, \sigma \rangle  (t_n) = \langle  I, \sigma \rangle  (s_n)
  }{
    S, \sigma  \models  \bot 
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>So the idea here being that if we have a predicate and its negation both holding under the same interpretation and variable assignment, we can derive a contradiction. This allows us to conclude that our initial assumption (that the formula is not valid) must be false, thereby proving the validity of the formula.</html:p></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors />
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>22</fr:day>
                        </fr:date>
                        <fr:uri>https://kaierikniermann.github.io/notes/0019/</fr:uri>
                        <fr:display-uri>0019</fr:display-uri>
                        <fr:route>/notes/0019/</fr:route>
                        <fr:title text="Semantic Argument method (FOL)">Semantic Argument method (FOL)</fr:title>
                        <fr:taxon>Quiz</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Consider the following formula:</html:p><fr:tex display="block"><![CDATA[
  F \triangleq  (\forall  x.\ p(x)) \to  (\forall  y.\ p(y))
]]></fr:tex><html:p>Using the semantic argument method, determine whether the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is valid.</html:p>
 
   
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>22</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  We begin by assuming that <fr:tex display="inline"><![CDATA[\exists  S, \sigma  \nvDash  F]]></fr:tex>
  <fr:tex display="block"><![CDATA[
    \begin {align*}
      & S, \sigma  \nvDash  (\forall  x.\ p(x)) \to  (\forall  y.\ p(y)) \\
      & \therefore  S, \sigma  \models  \forall  x.\ p(x) \land  S, \sigma  \nvDash  \forall  y.\ p(y) \\ 
      & \therefore  S, \sigma  \models  \forall  x.\ p(x) \land  S, \sigma  \models  \neg  \forall  y.\ p(y) \\ 
    \end {align*} 
  ]]></fr:tex>
  Since we have <fr:tex display="inline"><![CDATA[p]]></fr:tex> and its negation both holding under the same interpretation and variable assignment, we can derive a contradiction using the Contradiction rule from the semantic argument method. Therefore, our initial assumption that <fr:tex display="inline"><![CDATA[F]]></fr:tex> is not valid must be false. Hence, we conclude that the formula <fr:tex display="inline"><![CDATA[F]]></fr:tex> is valid.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors />
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>11</fr:month>
          <fr:day>23</fr:day>
        </fr:date>
        <fr:uri>https://kaierikniermann.github.io/notes/001a/</fr:uri>
        <fr:display-uri>001a</fr:display-uri>
        <fr:route>/notes/001a/</fr:route>
        <fr:title text="Blog posts">Blog posts</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/001b/</fr:uri>
            <fr:display-uri>001b</fr:display-uri>
            <fr:route>/notes/001b/</fr:route>
            <fr:title text="Understanding recursors with Lean4">Understanding recursors with Lean4</fr:title>
            <fr:taxon>Blog</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>23</fr:day>
                </fr:date>
                <fr:title text="The recursor for natural numbers">The recursor for natural numbers</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Before we define recursors, let's first introduce the idea of an inductive type. We'll do this by examining how lean defines natural numbers. <fr:link href="/notes/vooys2020nnoquasitoposes/" title="Natural Numbers Objects and Quasitoposes" uri="https://kaierikniermann.github.io/notes/vooys2020nnoquasitoposes/" display-uri="vooys2020nnoquasitoposes" type="local">asdasda</fr:link></html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
</html:code></html:pre><html:p>The idea here being that we can construct natural numbers by either using the constructor <html:code>zero</html:code> to get <html:code>0</html:code>, or by applying the constructor <html:code>succ</html:code> to an existing natural number to get its successor. For example, we can construct <html:code>3</html:code> as follows:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def three : Nat := Nat.succ (Nat.succ (Nat.succ Nat.zero))
</html:code></html:pre><html:p>We can equivalently express this definition using the type formation and term intruduction rules:</html:p>
  
    
    <fr:resource hash="33d702bd484db0f38d36a948c284b41e"><fr:resource-content><html:img src="/notes/33d702bd484db0f38d36a948c284b41e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *[right=Form-Nat]{
  }{
    \mathbb {N} : \texttt {type}
  }
  \and  
  \inferrule *[right=Intro-Zero]{}{
    0 : \mathbb {N}
  }
  \and 
  \inferrule *[right=Intro-Succ]{
    n : \mathbb {N}
  }{
    \texttt {succ}\ n : \mathbb {N}
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>While this explanation for inductive types usually gives most people I think enough intuition to understand the basic notions of how to use them to construct something like natural numbers, I think it kind of misses the deeper idea of what an inductive type and by extension a recursor really is. To attempt to explain this we'll take a look into some of the categorical semantics behind inductive types.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001c/</fr:uri><fr:display-uri>001c</fr:display-uri><fr:route>/notes/001c/</fr:route><fr:title text="Natural Number Object (NNO)">Natural Number Object (NNO)</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We assume that <fr:tex display="inline"><![CDATA[\mathcal  L]]></fr:tex> is a category with a <fr:link href="/notes/001d/" title="Terminal Object (Category Theory)" uri="https://kaierikniermann.github.io/notes/001d/" display-uri="001d" type="local">terminal object</fr:link> <fr:tex display="inline"><![CDATA[1]]></fr:tex>. This category has a <html:em>natural number object</html:em> (NNO) if there exists an object <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> together with two morphisms:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[0 : 1 \to  \mathbb {N}]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[s : \mathbb {N} \to  \mathbb {N}]]></fr:tex></html:li></html:ul><html:p>such that, given any global element <fr:tex display="inline"><![CDATA[z : 1 \to  X]]></fr:tex> and any morphism <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, there exists a unique morphism <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> such that the following diagram commutes:</html:p>
 
  
  <html:figure><fr:resource hash="faf709942093ed663cd467e2f00c916b"><fr:resource-content><html:img src="/notes/faf709942093ed663cd467e2f00c916b.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  % String-diagram specific extensions live here. Add diagram tweaks without
 % re-running the full base preamble (to avoid duplicate definitions).

   
 
   \usepackage{eulervm}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{amsmath, amsthm, amsfonts}
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}

  % A TikZ style for curved arrows of a fixed height, due to AndrÃ©C.
  \tikzset{curve/.style={settings={#1},to path={(\tikztostart)
        .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
        and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
    \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
  quiver/.cd,pos/.initial=0.35,height/.initial=0}

  % A TikZ style for shortening paths without the poor behaviour of `shorten <' and `shorten >'.
  \tikzset{between/.style n args={2}{/tikz/spath/at end path construction={
        \tikzset{spath/split at keep middle={current}{#1}{#2}}
  }}}

  % TikZ arrowhead/tail styles.
  \tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
  \tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
  \tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
  % TikZ arrow styles.
  \tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}


  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzcd}
    1 \arrow [r, "0"] \arrow [dr, "z"'] & \mathbb {N} \arrow [d, "u"] \arrow [r, "s"] & \mathbb {N} \arrow [d, "u"] \\
    & X \arrow [r, "f"'] & X
  \end {tikzcd}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter></fr:tree><html:p>While at first this definition seems a bit needlessly abstract, it actually captures what the inductive type of natural numbers really is. The basic thing to recognize is that the two morphisms (just think of them as functions for now) in reality don't have anything to do with natural numbers directly. Instead they act as a kind of blueprint for how we can use the properties or constraints of natural numbers to make anything. Here on a high level we can describe the two functions / constructors as follows:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[0 : 1 \to  \mathbb {N}]]></fr:tex> - The represents the abstract idea of having some starting point or base case. Within natural numbers this is represented by <html:code>0</html:code>, but in reality it denote an abstract concept of having a starting point.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[s : \mathbb {N} \to  \mathbb {N}]]></fr:tex> - This represents the abstract idea of being able to build upon existing things to create new things. Within natural numbers this is represented by the successor function.</html:li></html:ul><html:p>Now this might quite fairly still seem a bit confusing and abstract. How can we <html:em>use properties</html:em> to <html:em>make anything?</html:em>. To describe this more formally lets constrain ourselves to the category of sets, <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex>. If you are unfamiliar with category theory its sufficient to think of this as just a collection of all kinds of sets and functions between them.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kaierikniermann.github.io/notes/001e/</fr:uri><fr:display-uri>001e</fr:display-uri><fr:route>/notes/001e/</fr:route><fr:title text="Natural Number Object (NNO) in Set">Natural Number Object (NNO) in Set</fr:title><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In the category <html:strong>Set</html:strong>, the natural number object (NNO) can be represented by the set of natural numbers <fr:tex display="inline"><![CDATA[\mathbb {N} = \{0, 1, 2, 3, \ldots \}]]></fr:tex>. If we take some arbitrary other set <fr:tex display="inline"><![CDATA[X]]></fr:tex> with some point <fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> (which can be identified with an element of <fr:tex display="inline"><![CDATA[X]]></fr:tex>) and some function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>, we can define a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> as follows:</html:p><fr:tex display="block"><![CDATA[
  u(n) = \begin {cases}
    x & \text {if } n = 0 \\
    f^n(x) & \text {if } n \geq  0
  \end {cases}
]]></fr:tex></fr:mainmatter></fr:tree><html:p>So in plain english what this is saying is that given any set <fr:tex display="inline"><![CDATA[X]]></fr:tex> where we have some starting point <fr:tex display="inline"><![CDATA[x \in  X]]></fr:tex> and some way of building upon existing elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> (the function <fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex>), we can use the properties of natural numbers to create a unique function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> that maps natural numbers to elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> in a way that respects our starting point and building function. A natural next question to have might be </html:p><html:blockquote>
  But what does it mean to <html:em>respect</html:em> the starting point and building function?
</html:blockquote><html:p>Here I'd fast say intuitively you can just imagine construct which has some notion of a start and some way of building upon existing things. For example let's imagine the following graph:</html:p><fr:tex display="block"><![CDATA[
  a \to  b \to  c \to  d \to  e \to  \ldots 
]]></fr:tex><html:p>Clearly here with have:</html:p><html:ul><html:li><html:strong>Starting point</html:strong>: Our start here is the node <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li>
  <html:li><html:strong>Building function</html:strong>: Our building function i.e. successor mechanism here is just following the arrows to the next node.</html:li></html:ul><html:p>So our two morphisms then are:</html:p><html:ul><html:li><fr:tex display="inline"><![CDATA[x : 1 \to  X]]></fr:tex> where <fr:tex display="inline"><![CDATA[x]]></fr:tex> maps to <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li>
  <html:li><fr:tex display="inline"><![CDATA[f : X \to  X]]></fr:tex> where <fr:tex display="inline"><![CDATA[f]]></fr:tex> maps each node to the next node along the arrow. That is
    <html:pre class="code-block language-lean"><html:code class="language-lean">
      f(a) = b
      f(b) = c
      f(c) = d
      f(d) = e
      ...
    </html:code></html:pre></html:li></html:ul><html:p>Creating a minimal replica of this in Lean we could do something like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive Node where
  | start : Node           -- this will play the role of âaâ
  | next  : Node â Node   

  def succNode (v : Node) : Node :=
    Node.next v

  def natToNode : â â Node
    | 0       =&gt; Node.start
    | n + 1   =&gt; succNode (natToNode n)
</html:code></html:pre><html:p>So we can see our function <fr:tex display="inline"><![CDATA[u : \mathbb {N} \to  X]]></fr:tex> here is represented by <html:code>natToNode</html:code>. Where the function maps <html:code>0</html:code> to <html:code>a</html:code> and each successor natural number to the next node along the arrow.</html:p><html:p>Something you might notice here is that if our <html:code>natToNode</html:code> function is replaced by just an identity, i.e.:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToNat : â â â
    | 0       =&gt; 0
    | n + 1   =&gt; n + 1
</html:code></html:pre><html:p>Then we get just the natural numbers themselves as defined by their properties. This is precisely what's expressed by the earlier commuative diagram we say. The two arrows:</html:p><fr:tex display="block"><![CDATA[
  1 \xrightarrow {0} \mathbb {N}
  \quad  \text { and } \quad  \mathbb {N} \xrightarrow {s} \mathbb {N}
]]></fr:tex><html:p>Are just the natural numbers defined by their properties. So in a sense the natural numbers are the most basic instantiation of their own properties. So now a fair thing to wonder is:</html:p><html:blockquote>
  So what does this have to do with recursers?
</html:blockquote><html:p>Well the key insight here is that our functions <html:code>natToNat</html:code> and <html:code>natToNode</html:code> both <html:em>are our recursers</html:em> for the natural numbers. A recursor is just a function that allows us to define functions <html:em>out of</html:em> an inductive type by specifying how to handle each constructor of the inductive type. So equivalently we can express our recursor for natural numbers as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def recNat {C : Type} (z : C) (s : C â C) : â â C
    | 0       =&gt; z
    | n + 1   =&gt; s (recNat z s n)
</html:code></html:pre><html:p>If we examine the actual type signature generated by <html:code>#check Nat.rec</html:code> we have:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  Â«NatÂ».rec.{u} 
  {motive : â â Sort u} 
  (zero : motive Â«NatÂ».zero)
  (succ : (n : â) 
    â motive n 
    â motive n.succ) 
  (t : â) : motive t
</html:code></html:pre><html:p>In our examples above we can see that the <html:code>motive</html:code> is just the type we are mapping to (either <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> or <fr:tex display="inline"><![CDATA[X]]></fr:tex>), the <html:code>zero</html:code> is our starting point (either <html:code>0</html:code> or <html:code>a</html:code>) and the <html:code>succ</html:code> is our building function (either the successor function or following the arrows). So using the recursor we can rewrite our earlier <html:code>natToNat</html:code> and <html:code>natToNode</html:code> functions as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  def natToNat : â â â :=
    Nat.rec 
      0                 -- | 0     =&gt; 0
      (fun n =&gt; n + 1)  -- | n + 1 =&gt; n + 1

  def natToNode : â â Node :=
    Nat.rec 
      Node.start            -- | 0     =&gt; Node.start
      (fun n =&gt; succNode n) -- | n + 1 =&gt; succNode (natToNode n)
</html:code></html:pre></fr:mainmatter>
            </fr:tree>
            <html:p>This for the most part covers the basic idea of recursors for the sake of breviety I won't go into more instances of recursors for other inductive types though conceptually they work the same way. You specify how to handle each constructor of the inductive type and the recursor gives you a function that maps from the inductive type to whatever type you specified.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>23</fr:day>
                </fr:date>
                <fr:title text="The connection to induction">The connection to induction</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A very important property of recursors emerges when we make the motive dependent. To elabroate on what that means let's first consider the situation of simple stepwise induction.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>23</fr:day>
                    </fr:date>
                    <fr:uri>https://kaierikniermann.github.io/notes/001f/</fr:uri>
                    <fr:display-uri>001f</fr:display-uri>
                    <fr:route>/notes/001f/</fr:route>
                    <fr:title text="Stepwise (Mathematical) Induction">Stepwise (Mathematical) Induction</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Stepwise (mathematical/natural/ordinary) induction is a proof technique used to establish the truth of a statement <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> for all natural numbers <fr:tex display="inline"><![CDATA[n \in  \mathbb {N}]]></fr:tex>. The process involves two main steps:</html:p>
                    <html:ol><html:li><html:strong>Base Case:</html:strong> Prove that the statement <fr:tex display="inline"><![CDATA[P(0)]]></fr:tex> is true.</html:li>
  <html:li><html:strong>Inductive Step:</html:strong> Assume that the statement <fr:tex display="inline"><![CDATA[P(k)]]></fr:tex> is true for some arbitrary natural number <fr:tex display="inline"><![CDATA[k \in  \mathbb {N}]]></fr:tex> (this assumption is called the <html:em>inductive hypothesis</html:em>). Then, using this assumption, prove that the statement <fr:tex display="inline"><![CDATA[P(k + 1)]]></fr:tex> is also true.</html:li></html:ol>
                    <html:p>If both the base case and the inductive step are successfully proven, we can conclude that the statement <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds for all natural numbers <fr:tex display="inline"><![CDATA[n \in  \mathbb {N}]]></fr:tex>. The concise formulation of this can be given by the induction principle.</html:p>
                    <fr:tex display="block"><![CDATA[
  (P(0) \land  \forall  k \in  \mathbb {N}.\ (P(k) \to  P(k + 1))) \to  \forall  n \in  \mathbb {N}.\ P(n)
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>Something we can notice here just by superficial observation alone is that this seems to look an awful lot like the recursor for natural numbers we defined earlier. In fact it <html:em>is</html:em> an application of the recursor for natural numbers for the <html:em>dependent</html:em> motive <fr:tex display="inline"><![CDATA[P : \mathbb {N} \to  \texttt {Prop}.]]></fr:tex>. To make this a little more concrete let's define a simple property over natural numbers:</html:p>
                <html:pre class="code-block language-lean">
                  <html:code class="language-lean">
  def P (n : â) : Prop := n + 0 = n
</html:code>
                </html:pre>
                <html:p>Now its important to note that in an abstract sense this is no different then any other function from natural numbers to some type. The dependency comes into play when we try to use the recursor i.e. the properties of naturals with this motive.</html:p>
                <html:pre class="code-block language-lean">
                  <html:code class="language-lean">
  def natToProp (n : â) : (P n) :=
    Nat.rec
      (motive := P)
      (by simp [P])                    -- base case: P 0
      (fun n ih =&gt; by simp [P])        -- inductive step: P n â P (n+1)
      n
</html:code>
                </html:pre>
                <html:p>A few things we can observe here:</html:p>
                <html:ul><html:li>The recursor here represents a <html:em>dependent</html:em> function, which is to say that the return type of the function depends on the input value. Contrasing this to the earlier case where the return type was always just <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> or <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:li>
  <html:li><html:strong>Base case</html:strong> - Importantly here as opposed to providing a function that returns some value of type <fr:tex display="inline"><![CDATA[C]]></fr:tex> for the base case, we instead provide a proof that the property <fr:tex display="inline"><![CDATA[P(0)]]></fr:tex> holds.</html:li>
  <html:li><html:strong>Inductive step</html:strong> - Similarly for the inductive step we provide a function that takes an arbitrary natural number <fr:tex display="inline"><![CDATA[n]]></fr:tex> and a proof that <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds (the inductive hypothesis) and returns a proof that <fr:tex display="inline"><![CDATA[P(n + 1)]]></fr:tex> holds.</html:li></html:ul>
                <html:p>If we view this through the lens of the Curry-Howard correspondence it quite nicely illustrates how our proof here is just a program which constructs witnesses (valid proofs) for each natural number that the property <fr:tex display="inline"><![CDATA[P(n)]]></fr:tex> holds. In the same way that our earlier recursor provided elements on the correct type, this dependent recursor provides proofs on the correct property. As this application of a recursor to a proposition represents said proposition being true for all natural numbers, we can equivalently use this within a theorem.</html:p>
                <html:pre class="code-block language-lean">
                  <html:code class="language-lean">
  theorem add_zero (n : â) : n + 0 = n := natToProp n
</html:code>
                </html:pre>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>23</fr:day>
                </fr:date>
                <fr:title text="Case Study: Evaluating arithmetic expressions">Case Study: Evaluating arithmetic expressions</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>As a little kind of case study I want to give an example of an inductive type (and its recursor) that most people become familiar with; in a sense; as early as primary school: the operational semantics of binary operators. We'll start by defining some of the basic syntax for arithmetic expressions:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  inductive BinOp where 
  | add : BinOp
  | sub : BinOp
  | mul : BinOp
  | div : BinOp

  inductive Expr where
  | const : â â Expr
  | binop : BinOp â Expr â Expr â Expr
</html:code></html:pre><html:p>So here we have defined a simple language of arithmetic expressions consisting of natural number constants and binary operations. This provides us with the means to construct expressions like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  #check Expr.binop BinOp.add (Expr.const 10) (Expr.const 20)
</html:code></html:pre><html:p>If we want to actually define the semantics of how to evaluate these expression we'll need to define a set of rewrite rules that describe how we can take an expression and reduce it to a value i.e. evaluate it. To evaluate an expression we want to traverse the expression tree and whenever we encounter a binary operation with two constant operands we want to apply the operation and replace the entire sub-expression with the resulting constant. We express this as 3 rewrite rules:</html:p><html:ul><html:li><html:strong>Left Evaluation</html:strong>: If the left operand of a binary operation can be reduced, then we reduce it.</html:li>
  <html:li><html:strong>Right Evaluation</html:strong>: If the left operand is a constant and the right operand can be reduced, then we reduce the right operand.</html:li>
  <html:li><html:strong>Operation Evaluation</html:strong>: If both operands are constants, we apply the binary operation and replace the entire sub-expression with the resulting constant.</html:li></html:ul><html:pre class="code-block language-lean"><html:code class="language-lean">
  def eval_op : BinOp â (Nat â Nat â Nat)
  | .add =&gt; Nat.add
  | .sub =&gt; Nat.sub
  | .mul =&gt; Nat.mul
  | .div =&gt; Nat.div

  inductive Step : Expr -&gt; Expr -&gt; Prop
  | ST_BinOp1 (op : BinOp)
      (eâ eâ' eâ : Expr)   
      (h : Step eâ eâ') :  
      Step (Expr.binop op eâ eâ) 
           (Expr.binop op eâ' eâ)
  | ST_BinOp2 (op : BinOp) 
      (vâ : Nat) 
      (eâ eâ' : Expr) 
      (h : Step eâ eâ') :
      Step (Expr.binop op (Expr.const vâ) eâ) 
           (Expr.binop op (Expr.const vâ) eâ')
  | ST_BinOpConst (op : BinOp) (vâ vâ : Nat) :
      Step (Expr.binop op (Expr.const vâ) (Expr.const vâ)) 
           (Expr.const (eval_op op vâ vâ))
</html:code></html:pre><html:p>Since expressions can naturally require multiple evaluations steps it makes sense to define a multi-step evaluation relation as the reflexive transitive closure of the single step evaluation relation defined above. This we can define as:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  abbrev MultiStep := Relation.ReflTransGen Step

  -- helper notation to express multi-step evaluation
  notation:50 e " -&gt;â¿ " e' =&gt;  MultiStep e e'
</html:code></html:pre><html:p>Let's also define a small helper syntax and macro to make it easier to write arithmetic expressions:</html:p>
  
<fr:tree show-metadata="false" expanded="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="A small arithmetic expression grammar">A small arithmetic expression grammar</fr:title></fr:frontmatter><fr:mainmatter><html:pre class="code-block language-lean"><html:code class="language-lean">
declare_syntax_cat arithTm

-- atoms
syntax num                      : arithTm
syntax "(" arithTm ")"          : arithTm

-- multiplicative level (higher precedence)
syntax:70 arithTm:70 "*" arithTm:71 : arithTm
syntax:70 arithTm:70 "/" arithTm:71 : arithTm

-- additive level (lower precedence)
syntax:60 arithTm:60 "+" arithTm:61 : arithTm
syntax:60 arithTm:60 "-" arithTm:61 : arithTm

syntax "ex{" arithTm "}" : term

macro_rules
  -- numerals
  | `(ex{ $n:num }) =&gt;
      `(Expr.const $n)

  -- parentheses
  | `(ex{ ($t:arithTm) }) =&gt;
      `(ex{$t})

  -- addition
  | `(ex{ $eâ:arithTm + $eâ:arithTm }) =&gt;
      `(Expr.binop BinOp.add (ex{$eâ}) (ex{$eâ}))

  -- subtraction
  | `(ex{ $eâ:arithTm - $eâ:arithTm }) =&gt;
      `(Expr.binop BinOp.sub (ex{$eâ}) (ex{$eâ}))

  -- multiplication
  | `(ex{ $eâ:arithTm * $eâ:arithTm }) =&gt;
      `(Expr.binop BinOp.mul (ex{$eâ}) (ex{$eâ}))

  -- division
  | `(ex{ $eâ:arithTm / $eâ:arithTm }) =&gt;
      `(Expr.binop BinOp.div (ex{$eâ}) (ex{$eâ}))
  </html:code></html:pre></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Describing arithmetic evaluation">Describing arithmetic evaluation</fr:title></fr:frontmatter><fr:mainmatter><html:p>Now say that we wanted to evaluate the expression <fr:tex display="inline"><![CDATA[((2 * 3) + 4)]]></fr:tex> on a high level what we would do is rewrite the multiplication to <fr:tex display="inline"><![CDATA[6 + 4]]></fr:tex> and then rewrite that to <fr:tex display="inline"><![CDATA[10]]></fr:tex>. Expressing this in lean we have:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  example : -- ((2 * 3) + 4) -&gt;â¿ 10
  ex{ ((2 * 3) + 4) } -&gt;â¿ ex{ 10 } :=
    .trans (rw_lhs (rw_const .mul 2 3)) (rw_const .add 6 4)
</html:code></html:pre><html:p>Here we say that the expression <fr:tex display="inline"><![CDATA[((2 * 3) + 4)]]></fr:tex> after multiple steps evaluates to <fr:tex display="inline"><![CDATA[10]]></fr:tex> by first rewriting the left hand side multiplication to <fr:tex display="inline"><![CDATA[6 + 4]]></fr:tex> and then rewriting that to <fr:tex display="inline"><![CDATA[10]]></fr:tex>. And we chain these operations together using the <html:code>.trans</html:code> constructor of the multi-step evaluation relation. Now the question becomes, how do we define these rewrite steps? Intuitively we can imagine evaluation as being described by the following sort of graph</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
 +(lhs [op] rhs) 
 |
 +-+(rw_lhs) -&gt;â¿ lhs' [op] rhs    (1) reduce lhs some number of steps
   | 
   +-+(rw_rhs) -&gt;â¿ lhs [op] rhs'  (2) reduce rhs some number of steps
     |
     +- (rw_const) -&gt; value       (3) reduce both to a constant value
</html:code></html:pre><html:p>The idea of each rule being that:</html:p><html:ul><html:li><html:strong>rw_lhs</html:strong>: If the left hand side can be reduced some number of steps we can reduce it while keeping the right hand side the same. This corresponds to the <html:code>ST_BinOp1</html:code> rule defined earlier.</html:li>
  <html:li><html:strong>rw_rhs</html:strong>: If the left hand side is a constant we can reduce the right hand side some number of steps while keeping the left hand side the same. This corresponds to the <html:code>ST_BinOp2</html:code> rule defined earlier.</html:li>
  <html:li><html:strong>rw_const</html:strong>: If both sides are constants we can apply the binary operation and reduce the entire expression to a single constant value. This corresponds to the <html:code>ST_BinOpConst</html:code> rule defined earlier.</html:li></html:ul><html:p>As these rules are defined over the structure of multi-step evaluation our implementation of them will naturally be in terms of the inductive structure of a multistep relationship:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
lemma rw_lhs (lhs_rw : lhs -&gt;â¿ lhs') :
  (lhs [op] rhs) -&gt;â¿ (lhs' [op] rhs) :=
match lhs_rw with
| .refl       =&gt; .refl
| .tail Sâ Sâ =&gt; (rw_lhs Sâ).tail (.ST_BinOp1 Sâ)

lemma rw_rhs (rhs_rw : rhs -&gt;â¿ rhs') :
  ((.const lhs) [op] rhs) -&gt;â¿ ((.const lhs) [op] rhs') :=
match rhs_rw with
| .refl       =&gt; .refl
| .tail Sâ Sâ =&gt; (rw_rhs Sâ).tail (.ST_BinOp2 Sâ)

lemma rw_const (op : BinOp) (lhs rhs : Nat) :
  ((.const lhs) [op] (.const rhs)) -&gt;â¿ .const (eval_op op lhs rhs) :=
.single (.ST_BinOpConst op lhs rhs)
</html:code></html:pre><html:p>Alternatively we can specify the left and right rewrite rules using the recursor or or head induction principle for multi-step evaluation:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
lemma rw_rhs' (rhs_rw : rhs -&gt;â¿ rhs') :
  ((.const lhs) [op] rhs) -&gt;â¿ ((.const lhs) [op] rhs') :=
.rec
  (refl := .refl)
  (tail := by
    intro _ _ _ hcb ih
    exact ih.tail (.ST_BinOp2 hcb)
  ) rhs_rw

lemma rw_rhs'' (rhs_rw : rhs -&gt;â¿ rhs') :
  ((.const lhs) [op] rhs) -&gt;â¿ ((.const lhs) [op] rhs') :=
.head_induction_on
  (refl := .refl)
  (head := by
    intro _ _ hac _ ih
    exact ih.head (.ST_BinOp2 hac)
  ) rhs_rw
</html:code></html:pre><html:p>The motive function here is inferred by Lean via the Lemma, which allos us to avoid having to explicitly specify it. Other then this we can see that the recursors again simply correspond to providing methods to describe what to do for each of the constructors.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Recursors describe usage">Recursors describe usage</fr:title></fr:frontmatter><fr:mainmatter><html:p>So at this point you might I think fairly ask yourself:</html:p><html:blockquote>
  Wait why are you spending so much time on this random example for recursors?
</html:blockquote><html:p>The main reason is that to me it provides one of the most grounded direct examples of what it means for a recursor function to <html:em>eliminate</html:em> a term of an inductive type. In general in type theory we say that <html:em>term elimination</html:em> represents the natural deduction rules for <html:em>how to use</html:em> terms of a given type. Applied to our example we can see that these recursors precisely correspond to the rules of how we evaluate i.e. <html:em>use</html:em> arithmetic expressions.</html:p><html:p>Each rewrite rule describes how we can take an expression and reduce it step by step until we reach a final value. So in a sense the recursor here <html:em>eliminates</html:em> the expression by providing a systematic way to break it down into its constituent parts and evaluate it. This is precisely the essence of what recursors do in type theory; they provide a way to systematically deconstruct and utilize terms of inductive types according to their defined structure and properties.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Proving correct evaluation">Proving correct evaluation</fr:title></fr:frontmatter><fr:mainmatter><html:p>One of the wonderful things we then naturally get from these recusors is that we can use them to describe how a correct evaluation works. So given our evaluation function:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
@[simp]
def eval : Expr -&gt; Nat
  | Expr.const n =&gt; n
  | Expr.binop op eâ eâ =&gt;
      let vâ := eval eâ
      let vâ := eval eâ
      eval_op op vâ vâ
</html:code></html:pre><html:p>We can use the recursors describing the rewrite rules to show that this evaluation function for our expressions both yields a constant and that we have some sequence of reduction steps (application of rewrite rules) to get to said constant. Or expressed formally:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  (e : Expr) : -- for any expression e
    (â v : Nat), -- there exists a value v
      (eval e = v) â§ (e -&gt;â¿ (.const v))
      -- such that eval e = v and e reduces to the constant v
</html:code></html:pre><html:p>The proof of this statement works by induction on the structure of the expression <html:code>e</html:code> if our expression represents a constant then the proof is trivial as we can just take the value of the constant itself. If our expression represents a binary operation then same as we showed for the concrete example we just apply our recursors to first rewrite the lhs, then the rhs and finally apply the operation to get the final constant value. In full the proof looks like:</html:p><html:pre class="code-block language-lean"><html:code class="language-lean">
  theorem eval_correct (e : Expr) :
  â v : Nat, (eval e = v) â§ (e -&gt;â¿ (.const v)) := by
  induction e with
  | const n =&gt; exists n
  | binop op lhs rhs eval_lhs eval_rhs =&gt;
    rcases eval_lhs with â¨lhs_v, â¨rhs_is_v, lhs_rwâ©â©
    rcases eval_rhs with â¨rhs_v, â¨lhs_is_v, rhs_rwâ©â©
    simp [rhs_is_v, lhs_is_v]

    exact
      (rw_lhs lhs_rw).trans (
        (rw_rhs rhs_rw).trans (
          rw_const op lhs_v rhs_v
        )
      )
</html:code></html:pre><html:p>In other words our proof for describing that our evaluation function is correct amounts to essentially simulating or describing quite literally how the evaluation works step by step using the recursors we defined earlier. To see precisely how <html:code>rcases</html:code> works here I'd recommend to paste the code into a Lean environment and examine the types of each of the intermediate values.</html:p></fr:mainmatter></fr:tree></fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>24</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/001g/</fr:uri>
            <fr:display-uri>001g</fr:display-uri>
            <fr:route>/notes/001g/</fr:route>
            <fr:title text="Disambiguating Induction Principles">Disambiguating Induction Principles</fr:title>
            <fr:taxon>Blog</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>Vooys, Geoff</fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>3</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/vooys2020nnoquasitoposes/</fr:uri>
            <fr:display-uri>vooys2020nnoquasitoposes</fr:display-uri>
            <fr:route>/notes/vooys2020nnoquasitoposes/</fr:route>
            <fr:title text="Natural Numbers Objects and Quasitoposes">Natural Numbers Objects and Quasitoposes</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">https://cspages.ucalgary.ca/~robin/class/Topos-readings/Natural%20Numbers%20Objects%20and%20Quasitoposes.pdf</fr:meta>
            <fr:meta name="note">Reading note</fr:meta>
            <fr:meta name="ENTRYTYPE">misc</fr:meta>
            <fr:meta name="ID">vooys2020nnoquasitoposes</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

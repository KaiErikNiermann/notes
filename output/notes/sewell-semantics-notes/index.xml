<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/notes/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/notes/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>Peter Sewell</fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2015</fr:year>
      <fr:month>1</fr:month>
      <fr:day>1</fr:day>
    </fr:date>
    <fr:uri>https://kaierikniermann.github.io/notes/sewell-semantics-notes/</fr:uri>
    <fr:display-uri>sewell-semantics-notes</fr:display-uri>
    <fr:route>/notes/sewell-semantics-notes/</fr:route>
    <fr:title text="Semantics of Programming Languages">Semantics of Programming Languages</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="institution">University of Cambridge, Computer Laboratory</fr:meta>
    <fr:meta name="note">Lecture notes for the Cambridge Computer Science Tripos, Part 1B</fr:meta>
    <fr:meta name="external">https://www.cl.cam.ac.uk/teaching/1516/Semantics/notes-mono.pdf</fr:meta>
    <fr:meta name="ENTRYTYPE">misc</fr:meta>
    <fr:meta name="ID">sewell_semantics_notes</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>25</fr:day>
            </fr:date>
            <fr:uri>https://kaierikniermann.github.io/notes/0025/</fr:uri>
            <fr:display-uri>0025</fr:display-uri>
            <fr:route>/notes/0025/</fr:route>
            <fr:title text="Structural induction">Structural induction</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Structural induction represents <fr:link href="/notes/0026/" title="Well-founded induction" uri="https://kaierikniermann.github.io/notes/0026/" display-uri="0026" type="local">well-founded induction</fr:link> applied to the <fr:link href="/notes/0024/" title="Strict subformula relation" uri="https://kaierikniermann.github.io/notes/0024/" display-uri="0024" type="local">strict subformula relation</fr:link>. To prove that a property <fr:tex display="inline"><![CDATA[P(\phi )]]></fr:tex> holds for all formulas <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, it suffices to show that for every formula <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, if <fr:tex display="inline"><![CDATA[P(\psi )]]></fr:tex> holds for all strict subformulas <fr:tex display="inline"><![CDATA[\psi ]]></fr:tex> of <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[P(\phi )]]></fr:tex> also holds. Formally, this can be expressed as <fr:link href="/notes/bradley2007calculus/" title="The Calculus of Computation: Decision Procedures with Applications to Verification" uri="https://kaierikniermann.github.io/notes/bradley2007calculus/" display-uri="bradley2007calculus" type="local">(1)</fr:link>:</html:p><fr:tex display="block"><![CDATA[
  (\forall  \phi .\ (\forall  \psi .\ \psi  \prec _{\text {sf}} \phi  \to  P(\psi )) \to  P(\phi )) \to  (\forall  \phi .\ P(\phi ))
]]></fr:tex><html:p>Often times the discussion of structural induction specifically refers to (abstract) syntax where we define a finite tree with ordered branches as the structure of expressions. In practical terms this means we define an inductive type for the syntax of expressions, and then we can perform structural induction over this inductive type. When discussing SI through the lens of constructors we can rephrase the above principle as follows.</html:p><html:p>For any property <fr:tex display="inline"><![CDATA[P(e)]]></fr:tex> of some expression <fr:tex display="inline"><![CDATA[e]]></fr:tex>, to prove that:</html:p><fr:tex display="block"><![CDATA[
  \forall  e \in  \texttt {E}.\ P(e)
]]></fr:tex><html:p>it's sufficient to prove that for each tree constructor <fr:tex display="inline"><![CDATA[c]]></fr:tex> if some arity <fr:tex display="inline"><![CDATA[k \geq  0]]></fr:tex> (takes 0 or more args) that if <fr:tex display="inline"><![CDATA[P]]></fr:tex> holds for all subtrees <fr:tex display="inline"><![CDATA[e_1, e_2, \ldots , e_k]]></fr:tex> then it also holds for the tree constructed by applying <fr:tex display="inline"><![CDATA[c]]></fr:tex> to these subtrees <fr:link href="/notes/sewell-semantics-notes/" title="Semantics of Programming Languages" uri="https://kaierikniermann.github.io/notes/sewell-semantics-notes/" display-uri="sewell-semantics-notes" type="local">(2)</fr:link>:</html:p><fr:tex display="block"><![CDATA[
  \forall  c.\ \forall  e_1,\ldots ,e_k.\ (P(e_1) \land  P(e_2) \land  \ldots  \land  P(e_k)) \to  P(c(e_1, e_2, \ldots , e_k)) \to  (\forall  e \in  \texttt {E}.\ P(e))
]]></fr:tex><html:p>We can equivalently express this through a inference rule as follows:</html:p>
  
    
    <fr:resource hash="a102ca496e33f1dc2a8c1ac405cc25cf"><fr:resource-content><html:img src="/notes/a102ca496e33f1dc2a8c1ac405cc25cf.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
     
    \usepackage{eulervm}
  \usepackage{mathtools}
  \usepackage[scaled=0.92]{inconsolata} 
  \usepackage{mathpartir}
  \usepackage{centernot}
  \usepackage[cal=cm]{mathalpha} % force \mathcal to CM-style callig

    ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\begin {mathpar}
  \inferrule *{
    \forall  c.\ \forall  e_1,\ldots ,e_k.\ (P(e_1) \land  P(e_2) \land  \ldots  \land  P(e_k)) 
  }{
    P(c(e_1, e_2, \ldots , e_k)) \to  \forall  e \in  \texttt {E}.\ P(e)
  }
\end {mathpar}]]></fr:resource-source></fr:resource>
  
<html:p>The idea in principle just being that we enumerate through the constructor of the syntax tree and show that if the property holds for all subtrees then it also holds for the tree constructed from them.</html:p></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>

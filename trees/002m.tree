\date{2025-11-27}

\import{base-macros}

\taxon{Definition}
\title{Category}

\p{
  There are a few ways you can define a \em{category}. In the most basic intuitive sense a category consists of a collection of things called \em{objects} and binary relationships (or transitions) between those objects called \em{morphisms} (or \em{arrows}). We can combine these relationships by \em{composing} them, and for each object there is an \em{identity morphism} that acts as a neutral element for composition. [(1)](nlab-category)
}

\p{
  In the context of [\em{quivers}](002l) a category can be defined as a quiver with a rule saying for how we can compose two edges that fit together to get a new edge. Furthermore, each vertex (object) has an edge starting and ending at that vertex (the identity morphism). The classical definition is something like this:
}

\subtree{
  \title{The data}
  \p{
    A \em{category} #{C} consists of:
  }
  \ul{
    \li{
      A collection (or \em{class} [(2)](johnson-yau-2d-categories-2020)) of \strong{objects}, denoted as #{\text{Ob}(C)} or #{C_0}.
    }
    \li{
      A collection (or \em{set} [(2)](johnson-yau-2d-categories-2020)) of \strong{morphisms} (or \em{arrows}), denoted #{C_1} or #{C(x, y)} for #{x, y \in \text{Ob}(C)}.
      \ul{
        \li{
          For every morphism #{f \in C(x, y)}, there are two associated objects: the \em{source} (or \em{domain}) #{x} and the \em{target} (or \em{co-domain}) #{y}. In standard function notation, we write #{f: x \to y} where #{x = \text{dom}(f)} and #{y = \text{cod}(f)}. NLab has a nice convention where it denotes the source #{s} of a morphism as #{s(f)} and the target #{t} as #{t(f)}.
        }
        \li{
          For every pair of morphisms #{f \in C(x, y)} and #{g \in C(y, z)} (s.t. #{t(f) = s(g)} i.e. the morphisms type check), there is a \strong{composition} morphism #{g \circ f \in C(x, z)}. Written out we can denote this as:
          ##{
            C(x, y) \times C(y, z) \to C(x, z)
          }
          in diagrammatic order this is often written as #{f; g} we can equivalently use a more graphical notation:
          \texfig{
          % https://q.uiver.app/#q=WzAsMyxbMCwwLCJ4Il0sWzIsMCwieSJdLFs0LDAsInoiXSxbMCwxLCJmIl0sWzEsMiwiZyJdLFswLDIsImY7ZyIsMCx7ImN1cnZlIjotM31dXQ==
          \[\begin{tikzcd}[column sep=small]
            x && y && z
            \arrow["f", from=1-1, to=1-3]
            \arrow["{f;g}", curve={height=-18pt}, from=1-1, to=1-5]
            \arrow["g", from=1-3, to=1-5]
          \end{tikzcd}\]
        }
        }
        \li{
          For every object #{x \in \text{Ob}} there is an \strong{identity morphism}:
          ##{
            (\text{id}_x : x \to x) \in C(x, x)
          }
        }
      }
      Note: Some additional notations for morphisms include #{\text{hom}(x, y)}, #{\text{hom}_C(x, y)} or #{C_1(x, y)}. Additionally, people use the notation #{\text{Mor(C)}} to denote the following disjoint union
      ##{
        \text{Mor}(C) = \bigsqcup_{x, y \in \text{Ob}(C)} C(x, y)
      }
      Which just expresses the idea that the collection of all morphisms in a category is made up of the morphisms between each pair of objects.
    }
  }
}
\subtree{
  \title{The axioms}
  \p{
    The above are often called \strong{data} of a category. In addition to this data, a category must satisfy the following \strong{axioms} or (\em{conditions}):
  }
  \ul{
    \li{
      Morphisms need to be \strong{associative} which means that for every triple of morphisms #{f \in C(w, x)}, #{g \in C(x, y)}, and #{h \in C(y, z)} the following holds:
      ##{
        h \circ (g \circ f) = (h \circ g) \circ f
      }
    }
    \li{
      For each morphism #{f \in C(x, y)} the identity morphisms act as \strong{neutral elements} for composition:
      ##{
        \text{id}_y \circ f = f = f \circ \text{id}_x
      }
      This is also known as the \em{left} and \em{right} \strong{unit laws} or just \strong{unity} in general.
    }
  }

}

\subtree{
  \title{Remarks}

  \ul{
    \li{
      A category such as the one described above is often also called a 1-category to distinguish it from higher categories such as 2-categories, n-categories.
    }
  }
}

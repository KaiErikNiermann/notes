\date{2025-11-29}

\import{base-macros}

\taxon{Blog}
\title{A simple Bool category in Lean4}

\transclude{002m}
\transclude{002s}

\subtree{
  \taxon{Example}
  \title{The category}
  \subtree{
    \title{The data}
    \p{
      We want to start off by defining the data of our category. On a high level we want to define a category with two objects, \cf{true} and \cf{false}. Starting with the object representation we have:
    }
    \codeblock{lean}{
      /-- A wrapper type to make a custom category on Bool -/
      structure BoolCat : Type where
        val : Bool
      deriving DecidableEq, Repr

      /-- The two objects -/
      def BoolCat.tt : BoolCat := ‚ü®true‚ü©
      def BoolCat.ff : BoolCat := ‚ü®false‚ü©
    }
    \p{
      Next we want to define the morphisms between these objects. For each pair of objects we express 3 kinds of morphisms: the identity morphism, a morphism from \cf{false} to \cf{true}, \cf{false}from \cf{true} to \cf{false}. We can express this in Lean as follows:
    }
    \codeblock{lean}{
      /-- Morphisms: we allow identity on each, plus iso between them -/
      inductive BCHom : BoolCat ‚Üí BoolCat ‚Üí Type
        | id (b : BoolCat) : BCHom b b
        | swap : BCHom BoolCat.tt BoolCat.ff
        | swapInv : BCHom BoolCat.ff BoolCat.tt
    }
    \p{
      Formally what this describes is a kind of piecewise function:
    }
    ##{
      \text{f}(x, y) =
      \begin{cases}
      1_x &: x \to x & \texttt{if } x = y \\
      \texttt{swap} &: \text{tt} \to \text{ff} & \texttt{if } x = \text{tt} \land y = \text{ff} \\
      \texttt{swapInv} &: \text{ff} \to \text{tt} & \texttt{if } x = \text{ff} \land y = \text{tt}
      \end{cases}
    }
  }
  \subtree{
    \title{Composition and Category instance}
    \p{
      Now we have some notion of objects and morphisms between them, we can move on to defining composition of morphisms.
    }
    \codeblock{lean}{
      def comp : {X Y Z : BoolCat} ‚Üí BCHom Y Z ‚Üí BCHom X Y ‚Üí BCHom X Z
        | _, _, _, id _, f => f
        | _, _, _, f, id _ => f
        | _, _, _, swapInv, swap => id _
        | _, _, _, swap, swapInv => id _
    }
    \p{
      This defines composition by pattern matching on the possible morphism combinations. Note that we have to explicitly handle the cases where we compose \cf{swap} and \cf{swapInv} to get the identity morphism on the respective objects. To construct our category we have to provide proofs for the category axioms, namely associativity and identity.
    }
    \codeblock{lean}{
      @[simp] theorem id_comp' {X Y : BoolCat} (f : BCHom X Y) 
          : comp (id Y) f = f := by
        cases f <;> rfl

      @[simp] theorem comp_id' {X Y : BoolCat} (f : BCHom X Y) 
          : comp f (id X) = f := by
        cases f <;> rfl

      theorem assoc'  (f : BCHom W X) (g : BCHom X Y) (h : BCHom Y Z) :
          comp h (comp g f) = comp (comp h g) f := by
        cases f <;> cases g <;> cases h <;> rfl
    }
    \p{
      With all this in place we can finally define our category instance:
    }
    \codeblock{lean}{
      instance : Category BoolCat where
        -- The data
        Hom     := BCHom
        id      := BCHom. id
        comp    := fun f g => BCHom. comp g f

        -- Category laws
        id_comp := fun f     => BCHom.comp_id' f
        comp_id := fun f     => BCHom.id_comp' f
        assoc   := fun f g h => BCHom.assoc' f g h
    }
  }
  \subtree{
    \title{Isomorphisms in the Bool category}
    \p{
      Since we clearly see that the morphisms \cf{swap} and \cf{swapInv} are inverses of each other, we can construct an isomorphism between the two objects \cf{tt} and \cf{ff} as follows:
    }
    \codeblock{lean}{
      def ttFfIso : BoolCat.tt ‚âÖ BoolCat.ff where
        hom := BCHom.swap
        inv := BCHom.swapInv
        hom_inv_id := rfl
        inv_hom_id := rfl
    }
    \p{
      We can see that lean uses a similar notation for isomorphism as we do in our notes, namely the \cf{‚âÖ} symbol between the two objects. We can see that an isomorphism consists of a \cf{hom} and an \cf{inv} morphism along with proofs that composing them in either order yields the respective identity morphism. In Lean4 its defined as follows:
    }
    \codeblock{lean}{
      structure Iso {C : Type u} [Category.{v} C] (X Y : C) where
        /-- The forward direction of an isomorphism. -/
        hom : X ‚ü∂ Y
        /-- The backwards direction of an isomorphism. -/
        inv : Y ‚ü∂ X
        /-- Composition is the identity on the source. -/
        hom_inv_id : hom ‚â´ inv = ùüô X := by cat_disch
        /-- Composition, in reverse, is the identity on the target. -/
        inv_hom_id : inv ‚â´ hom = ùüô Y := by cat_disch

      ...

      /-- Notation for an isomorphism in a category. -/
      infixr:10 " ‚âÖ " => Iso 
    }
    \p{
      We can check out some properties of our isomorphism like so:
    }
    \codeblock{lean}{
      -- Verify it's an isomorphism
      #check ttFfIso           -- BoolCat.tt ‚âÖ BoolCat.ff
      #check ttFfIso.hom       -- BoolCat.tt ‚ü∂ BoolCat.ff
      #check ttFfIso.inv       -- BoolCat.ff ‚ü∂ BoolCat.tt
    }
    \p{
      Furthermore we can also show the identity isomorphism #{tt \cong tt}:
    }
    \codeblock{lean}{
      -- Every object is isomorphic to itself (trivially)
      def ttSelfIso : BoolCat.tt ‚âÖ BoolCat.tt := Iso.refl _

      #check ttSelfIso -- BoolCat.tt ‚âÖ BoolCat.tt
    }
    \p{
      Finally for the sake of completeness we can also demonstrate the isomorphism laws in examples as so:
    }
    \codeblock{lean}{
      -- The isomorphism laws
      example : ttFfIso.hom ‚â´ ttFfIso.inv = ùüô BoolCat.tt 
        := ttFfIso.hom_inv_id

      example : ttFfIso.inv ‚â´ ttFfIso.hom = ùüô BoolCat.ff 
        := ttFfIso.inv_hom_id
    }
  }
}

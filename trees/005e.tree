\date{2025-12-22}

\import{base-macros}

\taxon{Definition} 

\title{[Abstract](005d) strongest postcondition}

\subtree{
  \title{The idea}

  \p{
    Our usual strongest postcondition can be understood as a mapping from a concrete domain to a concrete domain, i.e.
  }
  ##{
    \begin{align}
      \cf{sp} : \cf{Stmt} \times \cf{C} \to C
    \end{align}
  }
  \p{
    Where #{C} represents our concrete domain, in the world of program logic this is typically assertions on the state of some memory environment. The idea behind the \em{abstract} \cf{sp}, is that we have a function
  }
  ##{
    \begin{align}
      \cf{sp}^\# : \cf{Stmt} \times \cf{A} \to \cf{A}
    \end{align}
  }
  \p{
    In other words we are considering the strongest postcondition from within the abstract domain. Intuitively this just means that our predicates or assertions on the memory states (or equivalently the set of states we characterize) will be expressed in abstract terms.
  }
}

\subtree{
  \title{In more detail}

  \p{
    The abstract strongest postcondition, denoted #{\cf{sp}^\#} or #{\textrm{post\#}} is defined as
  }
  ##{
    \cf{sp}^\# (s, a) = \alpha (\cf{sp}(s, \gamma(a)))
  }
  \p{
    Let's explain a bit on how we can derive this, we begin with the idea that for each #{a \in A} and each statement #{s} we want:
  }
  ##{
    \cf{sp}(s, \gamma(a)) \subseteq \gamma(\cf{sp}^\#(s, a))
  }
  \p{
    This expresses \strong{soundness} in other words, the resulting set of states, generated by concretizing the abstraction #{a} must be contained within the prediction of the abstract transformer predicate #{\cf{sp}^\#}. Then using the Galois connection we have between #{\alpha} and #{\gamma}
  }
  ##{
    \forall a \in A, c \in C.\ \alpha(c) \subseteq a \iff c \leq \gamma (a)
  }
  \p{
    which expresses the notion that #{c} is \em{approximated} by #{a}. We can rewrite our earlier soundness condition as:
  }
  ##{
    \alpha(\cf{sp}(s, \gamma(a))) \sqsubseteq \cf{sp}^\# (s, a)
  }
  \p{
    two again denote the same conceptual thing that our abstract predicate transformer #{\cf{sp}^\#} is an over-approximation of the analogous transformer for the concrete domain. As we would preferably like to have the most precise approximation we choose equality. Or stated differently by definition the most precise abstracted approximation of the strongest post-condition we can have for some abstracted state is literally just this state concretized, and the resulting set abstracted. 
  }
  ##{
    \cf{sp}^\# (s, a) = \alpha(\cf{sp}(s, \gamma(a)))
  }
}

\subtree{
  \title{Correctness}

  \p{
    The most important property to remember about the abstract strongest post-condition is that if we \em{do over-approximate an error state} it \strong{does not} allow us to conclude that the program is wrong.
  }
}
